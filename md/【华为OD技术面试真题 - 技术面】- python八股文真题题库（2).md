## 华为OD面试真题精选

专栏：[华为OD面试真题精选](https://blog.csdn.net/banxia_frontend/category_12436481.html)  
目录:
[2024华为OD面试手撕代码真题目录以及八股文真题目录](https://blog.csdn.net/banxia_frontend/article/details/138131520)

#### 文章目录

  * 华为OD面试真题精选
  * 1\. python程序的执行过程
  *     *       * Python执行过程概述
      * 重要的内部机制
  * 2\. 列表和元组的区别
  *     *       * 列表（List）
      * 元组（Tuple）
      * 总结
  * 3\. python的多线程机制？和其他语言的多线程区别？
  *     *       * Python的多线程机制
      *         * 全局解释器锁（GIL）
        * 线程的使用
      * 与其他语言的区别
      *         * Java和C++
        * JavaScript（Node.js）
      * 总结
  * 4\. Python字符串反转的几种操作
  *     *       * 方法1: 切片
      * 方法2: 使用`reversed()`和`join()`
      * 方法3: 递归
      * 方法4: 使用栈
      * 方法5: for循环
  * 5\. python常用的框架
  *     *       * 常用的Python框架
      *         * 1\. Django
        * 2\. Flask
        * 3\. FastAPI
        * 4\. Pyramid
  * 6\. python进程退出的时候，内存是否会全部释放？为什么？
  * 7\. 哪个函数会打乱列表元素的排序。
  * 8\. 闭包的概念
  *     *       * 闭包的三个必要条件：
      * 闭包的一个简单示例：
      * 闭包的应用：
  * 9\. 匿名函数的好处
  *     *       * 示例：

## 1\. python程序的执行过程

#### Python执行过程概述

Python是一种解释型语言，这意味着Python代码在执行时首先被转换成字节码，然后由Python虚拟机（PVM）解释执行。详细的执行过程可以分为以下几个步骤：

  1. **源代码** ：编写的Python文件（`.py`文件）包含了可读的源代码。

  2. **编译** ：Python解释器首先将源代码编译成字节码。这一过程涉及到语法分析和语义分析，确保代码符合Python的语法规则。字节码是一种低级、与平台无关的代码，保存在`.pyc`文件中。

  3. **字节码** ：编译得到的字节码是一种中间表示形式，存储在内存中。字节码的执行比直接解释源代码要快。

  4. **Python虚拟机** ：Python虚拟机（PVM）是Python运行时环境的一部分，负责读取字节码，将其转换成机器码，然后执行。PVM是解释器的核心，它执行存储在`.pyc`文件中的字节码。

  5. **执行** ：PVM逐条执行字节码指令，进行函数调用、内存管理等操作。

#### 重要的内部机制

  * **全局解释器锁（GIL）** ：在CPython（Python的默认实现）中，GIL是一个互斥锁，确保同一时刻只有一个线程执行Python字节码。这意味着即使在多核处理器上，单个Python进程也不能同时执行多个线程。GIL是Python中多线程编程的一个重要限制。

  * **垃圾回收** ：Python使用引用计数和垃圾回收机制来管理内存。引用计数是主要的内存管理形式，当对象的引用计数降到0时，对象就会被立即删除。此外，Python还使用了一种名为“标记-清除”的垃圾回收算法来处理循环引用的情况。

## 2\. 列表和元组的区别

#### 列表（List）

列表是Python中使用最频繁的数据结构之一，主要特点和用途包括：

  1. **可变性** ：列表是可变的，意味着列表创建后，你可以修改其内容，例如添加、删除或更改元素。
  2. **语法** ：列表用方括号`[]`表示，元素之间用逗号分隔。
  3. **性能** ：由于列表的可变性，插入和删除操作可能会比元组慢，特别是当列表很大且在开始或中间位置插入或删除元素时，因为这可能需要移动列表中的其他元素。
  4. **用途** ：由于其灵活性，列表通常用于存储在程序运行期间可能需要修改的数据集合。

#### 元组（Tuple）

元组是与列表类似的另一种数据结构，但有几个关键的不同点：

  1. **不可变性** ：元组是不可变的，这意味着一旦元组被创建，你不能更改其内容——不能添加、删除或修改元素。
  2. **语法** ：元组用圆括号`()`表示，元素之间用逗号分隔。实际上，圆括号是可选的，重要的是元素后的逗号。
  3. **性能** ：由于元组的不可变性，它们通常比列表具有更小的存储开销，并且在可以预期的情况下使用元组（如从函数返回多个值）时，它们的处理速度可能更快。
  4. **用途** ：元组用于存储不需要修改的数据集合。它们经常用于函数返回多个值和存储数据字典的键（因为键需要是不可变的）。

#### 总结

选择列表还是元组，通常取决于是否需要修改数据集合。如果需要一个在整个程序生命周期中都不变的，可以安全地用作映射中键的数据集，那么元组是更好的选择。如果数据集需要动态修改，列表则更加合适。此外，从性能角度考虑，对于固定数据，元组的处理速度和空间效率通常更优。

## 3\. python的多线程机制？和其他语言的多线程区别？

当谈论Python的多线程时，必须提及全局解释器锁（GIL），这是Python（特别是CPython）中实现线程的一个关键概念。

#### Python的多线程机制

##### 全局解释器锁（GIL）

  * **定义和作用** ：在CPython（Python的主要实现）中，GIL是一个互斥锁，保证任何时刻只有一个线程在解释器中执行。这意味着即使在多核处理器上，一个Python进程中的多线程也无法实现真正的并行执行。
  * **目的** ：GIL的主要目的是简化CPython中的内存管理，尤其是垃圾回收，它避免了与并发执行相关的复杂同步和竞争条件问题。
  * **影响** ：GIL是一个常见的批评点，因为它阻止了多线程的并行计算，这对于CPU密集型任务是一个重大限制。

##### 线程的使用

  * **I/O密集型应用** ：在I/O密集型任务中，如文件读写、网络操作或数据库交互等，Python的多线程可以非常有效，因为线程大部分时间都在等待外部I/O操作完成，GIL在这些时期会被释放，允许其他线程执行。
  * **CPU密集型应用** ：对于CPU密集型任务，多线程因为GIL的存在而不是最佳选择。在这种情况下，通常建议使用多进程（利用Python的`multiprocessing`模块），因为每个进程有自己的解释器和内存空间，从而能够真正并行执行。

#### 与其他语言的区别

##### Java和C++

  * **真正的线程并行性** ：在像Java和C++这样的语言中，多线程被操作系统直接管理，能够在多核处理器上实现真正的并行性。
  * **内存管理** ：这些语言提供了更复杂的机制来处理线程之间的同步和内存访问冲突，如互斥锁、信号量等。

##### JavaScript（Node.js）

  * **事件驱动和非阻塞I/O** ：虽然JavaScript在Node.js中是单线程的，它使用事件循环和非阻塞I/O操作，使得它可以非常有效地处理高I/O负载，类似于Python中利用多线程处理I/O密集型任务。

#### 总结

在Python中，多线程适合I/O密集型任务，但不适合CPU密集型任务。

## 4\. Python字符串反转的几种操作

#### 方法1: 切片

Python的切片功能非常强大，可以很容易地反转字符串。

    
    
    def reverse_string(s):
        return s[::-1]
    

这里，`s[::-1]`表示从开始到结束步长为-1的切片，即反向遍历字符串。

#### 方法2: 使用`reversed()`和`join()`

`reversed()`函数返回一个反向迭代器，然后可以用`join()`函数将其组合成一个新的字符串。

    
    
    def reverse_string(s):
        return ''.join(reversed(s))
    

#### 方法3: 递归

使用递归方法反转字符串是一种更复杂的方法，显示了编程的递归思维。

    
    
    def reverse_string(s):
        if len(s) <= 1:
            return s
        else:
            return reverse_string(s[1:]) + s[0]
    

这个方法将字符串除了第一个字符外的剩余部分递归反转，然后将第一个字符添加到最后。

#### 方法4: 使用栈

利用栈的后进先出（LIFO）特性来反转字符串。

    
    
    def reverse_string(s):
        stack = list(s)
        reversed_str = ''
        while stack:
            reversed_str += stack.pop()
        return reversed_str
    

这里，将字符串中的每个字符依次放入栈中，然后依次弹出栈顶元素并拼接，实现字符串的反转。

#### 方法5: for循环

通过for循环遍历字符串并从前向后构建新的反向字符串。

    
    
    def reverse_string(s):
        reversed_str = ''
        for char in s:
            reversed_str = char + reversed_str
        return reversed_str
    

这种方法通过在每次迭代中将当前字符添加到累积结果的前面来反转字符串。

## 5\. python常用的框架

#### 常用的Python框架

##### 1\. Django

  * **用途** ：全栈Web开发框架。
  * **优点** ：提供了大量内置功能，如用户认证、数据库模型、后台管理等，适合开发复杂的大型网站。社区支持强大，插件丰富。

##### 2\. Flask

  * **用途** ：轻量级Web开发框架。
  * **优点** ：灵活性高，易于扩展，适合小型项目和微服务架构。学习曲线低，可以自由选择工具和库来满足项目需求。

##### 3\. FastAPI

  * **用途** ：现代、快速（高性能）的Web框架，用于构建APIs。
  * **优点** ：支持异步编程，易于使用，自动生成文档（Swagger UI），非常适合构建有大量数据交换的现代Web应用。类型系统的使用减少了bug和提供了自动请求解析和验证。

##### 4\. Pyramid

  * **用途** ：适用于大型应用的Web框林。
  * **优点** ：灵活性强，可适用于简单和复杂的项目。提供了许多插件支持不同的需求。

## 6\. python进程退出的时候，内存是否会全部释放？为什么？

> https://blog.csdn.net/weixin_42976139/article/details/101469367
>
> https://www.zhihu.com/question/377384743
>
> https://www.cnblogs.com/insane-Mr-Li/p/12092055.html

## 7\. 哪个函数会打乱列表元素的排序。

在Python中，`random`模块中的`shuffle`函数数会就地打乱列表的顺序，即直接在原列表上进行操作，而不返回新的列表。下面是如何使用`shuffle`函数的一个示例：

    
    
    import random
    
    # 定义一个列表
    my_list = [1, 2, 3, 4, 5]
    # 使用shuffle函数打乱列表
    random.shuffle(my_list)
    
    # 打印打乱后的列表
    print(my_list)
    

在上面的代码中，`shuffle`函数接受一个列表作为参数，并将其元素顺序随机打乱。每次运行这段代码时，`my_list`的元素顺序可能都不同。

需要注意的是，`shuffle`是就地操作，它不返回新的列表，而是直接修改原列表。如果你需要保留原列表的顺序，可以先复制一份列表再进行打乱：

    
    
    import random
    
    # 定义一个列表
    original_list = [1, 2, 3, 4, 5]
    # 复制列表
    shuffled_list = original_list[:]
    
    # 打乱复制的列表
    random.shuffle(shuffled_list)
    
    # 打印原列表和打乱后的列表
    print("Original:", original_list)
    print("Shuffled:", shuffled_list)
    

这样，`original_list`保持原样，而`shuffled_list`为打乱后的版本。这是在需要同时保留原始顺序和随机顺序的情况下的一种实用方法。

## 8\. 闭包的概念

在Python中，闭包是一种函数对象，它记住了它在创建时所在的作用域中的变量，即使在当前作用域之外也能访问这些变量。闭包可以捕获定义时环境中的变量，并在其封闭作用域被调用时仍然能访问这些变量。闭包的特点使得它们在实现数据隐藏和封装功能上非常有用。

#### 闭包的三个必要条件：

  1. **必须有一个内部函数** ：这个内部函数通常定义在另一个函数内部。
  2. **内部函数必须引用外部函数的变量** ：内部函数访问并保持了外部函数作用域中的一个或多个变量的引用。
  3. **外部函数必须返回内部函数** ：这样，内部函数才能在外部函数的作用域之外被调用，同时保持对其作用域中变量的引用。

#### 闭包的一个简单示例：

    
    
    def outer_function(msg):
        message = msg
    
        def inner_function():
            print(message)  # 引用了外部函数的变量
    
        return inner_function  # 返回内部函数，而不是调用它
    
    # 创建闭包
    my_func = outer_function('Hello, world!')
    # 调用闭包
    my_func()  # 输出: Hello, world!
    

在这个例子中，`outer_function`创建了一个局部变量`message`，然后定义了一个内部函数`inner_function`，它访问了外部函数的`message`变量。当`outer_function`被调用时，它返回`inner_function`本身，而不是调用`inner_function`。这样，即使在`outer_function`调用结束后，`inner_function`仍然能够访问`message`变量。

#### 闭包的应用：

闭包常用于创建维护特定状态的函数和隐藏数据，这可以用于编程模式如工厂模式、装饰器等。它们也非常适合用于回调函数和事件处理程序，尤其是在需要维护状态或数据而又不想让这些状态或数据在全局范围内可见时。

## 9\. 匿名函数的好处

匿名函数，通常在Python中指的是通过`lambda`关键字定义的函数。这种函数不需要使用标准的`def`语句进行命名。`lambda`函数可以接收任何数量的参数，但只能有一个表达式。这种函数形式的好处包括：

  1. **简洁性** ：`lambda`函数通过单行表达式就能定义一个函数，使得代码更加简洁。这对于编写少量逻辑的小函数非常有用，可以避免冗长的定义。

  2. **无需命名** ：由于`lambda`是匿名的，因此不需要考虑命名函数，这可以减少命名冲突的可能性，并且使得代码更加直观。

  3. **方便地定义小函数** ：`lambda`函数非常适合在需要定义简单功能的地方使用，特别是在需要函数作为参数传递给高阶函数时（如在`map()`、`filter()`、`sorted()`等函数中使用）。

  4. **提高可读性** ：在某些情况下，使用`lambda`函数可以使代码更易于阅读和理解。例如，在排序函数中用作关键字参数，可以直观地看到排序的依据。

  5. **快速定义局部行为** ：`lambda`允许快速定义一些仅在局部范围内使用的行为，无需定义标准函数，从而保持代码的整洁和组织性。

#### 示例：

下面是一些使用`lambda`函数的例子：

  * **排序** ：
    
        # 根据列表中每个元素的第二个元素进行排序
    a_list = [(1, 2), (3, 1), (5, 0)]
    sorted_list = sorted(a_list, key=lambda x: x[1])
    

  * **映射操作** ：
    
        # 对列表中每个元素乘以2
    nums = [1, 2, 3, 4]
    doubled_nums = list(map(lambda x: x * 2, nums))
    

  * **过滤操作** ：
    
        # 过滤出列表中的偶数
    nums = [1, 2, 3, 4, 5, 6]
    even_nums = list(filter(lambda x: x % 2 == 0, nums))
    

虽然`lambda`函数具有上述优点，但也存在限制，如只能有一个表达式，有时可能限制了它们的使用场景。在需要复杂逻辑或多个表达式的情况下，标准的函数定义（`def`）更为适合。

