## 华为OD面试真题精选

🌟 强烈推荐：华为OD技术面试真题精选 🌟

大家好！今天我给大家推荐一份备受赞誉的华为OD技术面试精选题目。
所有题目均为华为od实际面试过程中出现的问题。这些面试题主要涉及到编程八股文、职业态度以及独特的个性特点。让我们一起深入了解这个精心整理的面试题集吧！😊
希望这些问题能够帮助你在面试中脱颖而出，展现出你的技术实力和独特魅力。加油！💪💼

专栏：[华为OD面试真题精选](https://blog.csdn.net/banxia_frontend/category_12436481.html)

![doutub_gif](https://i-blog.csdnimg.cn/blog_migrate/e9413fcd109f2f3d7297192eab0c0b2a.gif)

## 1\. MySQL存储引擎之间的区别

以下是一些常见MySQL存储引擎之间的区别：

  1. **InnoDB** :

     * 支持事务处理，具备提交、回滚和崩溃恢复能力的事务安全（ACID兼容）。
     * 支持外键，以确保数据的完整性和一致性。
     * 默认使用行级锁定，较好地支持并发处理。
     * 提供了缓冲池功能，可以缓存数据和索引在内存中，提高处理效率。
     * 是MySQL的默认存储引擎（从MySQL 5.5版本开始）。
  2. **MyISAM** :

     * 不支持事务处理。
     * 不支持外键。
     * 默认使用表级锁定，可能在高并发情况下成为瓶颈。
     * 通常具有比InnoDB更快的读取速度，适合于读密集型的应用。
     * 支持全文索引，适合全文搜索。
  3. **MEMORY** :

     * 将所有数据存储在内存中，因此访问速度非常快。
     * 适用于临时表和存储非关键性数据的场景。
     * 支持表级锁定。
     * 重启数据库后数据会丢失，因为数据只是暂时存储在内存中。
  4. **CSV** :

     * 以纯文本形式存储数据，每一行一个记录，每个字段之间用逗号分隔。
     * 可以直接用文本编辑器查看或编辑。
     * 不支持索引，因此查询性能可能不是很好。
  5. **ARCHIVE** :

     * 专为存储大量的归档数据设计，如日志数据。
     * 支持高压缩比，节省存储空间。
     * 只支持INSERT和SELECT操作。
     * 使用行级锁定。

## 2\. MySQL union和union all的区别

在MySQL中，`UNION`和`UNION
ALL`都是用来合并两个或多个`SELECT`语句的结果集的操作符，但它们之间有重要的区别，这些区别影响到结果集的内容以及查询的性能：

  1. **结果集中的重复行** :

     * `UNION`操作会自动去除合并结果集中的重复行，只保留唯一的记录。为了确保结果集中的记录是唯一的，MySQL需要进行额外的工作，如排序或使用临时表，这可能会影响查询性能。
     * `UNION ALL`操作不会去除结果集中的重复行，所有的记录都会被包含在最终的结果集中。由于不需要去重，`UNION ALL`通常比`UNION`更快，尤其是在处理大量数据时。
  2. **使用场景** :

     * 当需要从多个`SELECT`语句中获取一个不包含重复记录的结果集时，应该使用`UNION`。
     * 如果你需要包含所有的记录，包括重复的记录，或者你知道合并的结果集不会有重复记录，那么使用`UNION ALL`会更高效。
  3. **性能考虑** :

     * `UNION`由于需要去重，可能会消耗更多的CPU和内存资源，尤其是在处理大型数据集时。如果对结果集的唯一性没有要求，考虑使用`UNION ALL`来优化性能。
     * `UNION ALL`直接将多个`SELECT`语句的结果集合并起来，不进行任何额外的处理，因此在大多数情况下，它的执行速度要快于`UNION`。

简而言之，`UNION`和`UNION
ALL`的主要区别在于是否去除结果集中的重复行。选择哪一个操作符取决于你的具体需求：如果需要一个去重的结果集，使用`UNION`；如果需要包含所有记录或追求更快的查询速度，使用`UNION
ALL`。

## 3\. StringBuilder和StringBuffer

在Java中，`StringBuilder`和`StringBuffer`都是用来处理可变字符串的，但它们之间存在一些关键的区别，主要体现在性能和线程安全方面。了解这些区别对于Java开发者来说很重要，尤其是在需要优化性能或处理多线程环境下的字符串操作时。

#### 主要区别

  1. **线程安全** :

     * `StringBuffer`是线程安全的，它的大多数公有方法都是通过`synchronized`关键字同步的，这意味着在多线程环境下是安全的，多个线程可以同时访问一个`StringBuffer`对象而不会引发数据不一致的问题。
     * `StringBuilder`不是线程安全的，它没有对方法进行同步处理，因此它的性能比`StringBuffer`要高。在单线程环境下或不共享`StringBuilder`实例的场景中，推荐使用`StringBuilder`。
  2. **性能** :

     * 由于`StringBuffer`的线程安全特性，它在进行大量字符串操作时，相比`StringBuilder`会有一些性能开销。这些开销主要来自于同步控制。
     * `StringBuilder`由于不需要考虑线程同步的问题，通常比`StringBuffer`更快，特别是在进行大量字符串添加或修改操作时。
  3. **使用场景** :

     * 当你在多线程环境中操作字符串，并且不同的线程需要访问同一个字符串对象时，应该使用`StringBuffer`来确保数据的一致性和安全性。
     * 在单线程环境下或者确信字符串对象不会被多个线程同时访问时，使用`StringBuilder`是一个更优的选择，因为它提供了更好的性能。

#### 结论

`StringBuilder`和`StringBuffer`都继承自`AbstractStringBuilder`类，它们的接口和实现非常相似，差别主要在于线程安全和性能方面。

## 4\. 为什么要用事务

在数据库管理和操作中，事务是确保数据完整性和一致性的关键机制。使用事务主要是为了实现以下几个目的：

#### 1\. **保证数据的一致性**

事务确保了数据库从一个一致的状态转换到另一个一致的状态。即使在事务执行过程中发生故障（如系统崩溃或其他错误），事务管理系统也能够确保数据库的一致性不会被破坏。这是通过事务的四个基本特性（ACID特性）来保证的：

  * **原子性（Atomicity）** ：事务中的所有操作要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误时，会被回滚（Rollback）到事务开始前的状态。
  * **一致性（Consistency）** ：事务必须确保数据库从一个一致的状态转换到另一个一致的状态，不违反数据库的约束。
  * **隔离性（Isolation）** ：并发执行的事务之间不会互相影响，使得每个事务都是独立的。
  * **持久性（Durability）** ：一旦事务完成，它对数据库的修改就是永久性的，即使系统发生崩溃也不会丢失。

#### 2\. **支持并发控制**

事务通过隔离级别的概念支持多用户并发访问数据库，同时防止各种并发问题，如更新丢失、脏读、不可重复读和幻读等。不同的隔离级别提供了不同程度的数据保护和性能开销的平衡。

#### 3\. **简化错误恢复**

通过事务的原子性，如果在事务执行过程中发生错误或系统故障，系统可以自动回滚到事务开始之前的状态，从而简化了错误恢复的过程。开发者不需要编写复杂的错误恢复代码，数据库管理系统会处理这些情况。

#### 4\. **提高系统的可靠性**

使用事务可以使应用程序更加可靠。即使在面对系统故障、电源中断或其他异常情况时，通过事务的持久性和原子性保证，可以确保数据不会丢失，也不会出现不一致的情况。

总结来说，事务提供了一种有效的方式来保证数据库操作的完整性和一致性，支持并发控制，简化错误恢复，提高系统的可靠性。

## 5\. left join / right join /inner join

在数据库查询中，连接（JOIN）是一种将来自两个或多个表的行组合起来的操作，根据指定的关联条件。`LEFT JOIN`、`RIGHT
JOIN`和`INNER JOIN`是最常用的连接类型，它们各自有不同的用途和特点。

#### 1\. **INNER JOIN（内连接）**

  * **定义** ：`INNER JOIN`返回两个表中满足连接条件的行。如果在一个表中的行与另一个表中的行相匹配（即满足连接条件），则`INNER JOIN`会返回这些行。
  * **使用场景** ：当你只需要获取两个表中都存在关联的数据时，使用`INNER JOIN`。
  * **示例** ：假设有两个表，一个是员工表（Employees），一个是部门表（Departments）。如果你想要查询所有员工及其对应的部门信息，只包括那些已经分配了部门的员工，就可以使用`INNER JOIN`。

#### 2\. **LEFT JOIN（左连接）**

  * **定义** ：`LEFT JOIN`返回左表中的所有行，即使右表中没有匹配的行。如果左表中的行在右表中没有匹配的行，则结果中这些行的右表部分包含`NULL`。
  * **使用场景** ：当你需要获取左表中的所有记录，和右表中匹配记录的信息时，使用`LEFT JOIN`。对于右表中没有匹配的行，结果中对应字段会是`NULL`。
  * **示例** ：继续上面的员工和部门的例子，如果你想要列出所有员工的信息，以及他们对应的部门信息（即使某些员工没有分配部门），就可以使用`LEFT JOIN`。

#### 3\. **RIGHT JOIN（右连接）**

  * **定义** ：`RIGHT JOIN`返回右表中的所有行，即使左表中没有匹配的行。如果右表中的行在左表中没有匹配的行，则结果中这些行的左表部分包含`NULL`。
  * **使用场景** ：当你需要获取右表中的所有记录，和左表中匹配记录的信息时，使用`RIGHT JOIN`。对于左表中没有匹配的行，结果中对应字段会是`NULL`。
  * **示例** ：如果你想要列出所有部门的信息，以及每个部门对应的员工信息（即使某些部门没有员工），就可以使用`RIGHT JOIN`。

## 6\. redis内存穿透和雪崩

#### Redis内存穿透

##### 定义

内存穿透是指查询一个数据库中不存在的数据。由于缓存是不命中的，在缓存层面不会进行任何记录。因此，这些请求都会穿过缓存，直接请求数据库。如果这种现象在高频率下发生，会导致数据库压力剧增，严重时可能会拖垮数据库。

##### 解决方案

  * **空对象缓存** ：即便是数据库中没有的数据，在缓存中也可以存储一个特殊的空对象或者空值，并设置较短的过期时间。这样可以防止对同一条不存在的数据高频度地访问数据库。
  * **布隆过滤器** ：在缓存之前使用布隆过滤器，布隆过滤器可以很快地判断一个数据是否存在于集合中。如果布隆过滤器判断数据不存在，则不需要查询数据库，从而避免了内存穿透的问题。

#### 缓存雪崩

##### 定义

缓存雪崩是指在我们设置缓存时，大量的缓存数据同时过期，而查询数据量又非常大，导致大量的请求直接落到数据库上，从而引起数据库短时间内大量压力，甚至导致数据库崩溃。

##### 解决方案

  * **缓存数据的过期时间设置为随机** ：这样可以防止大量的缓存数据在同一时间过期。
  * **设置热点数据永不过期** ：对于一些访问频率高的数据，可以将它们设置为永不过期，或者是手动续期。
  * **使用多级缓存策略** ：例如，在Redis缓存之前，可以使用本地缓存（如Caffeine），以减轻Redis缓存的访问压力。
  * **提前使用缓存预热** ：在系统启动之初就加载热点数据到缓存中。
  * **限流降级** ：在缓存失效后，通过限流降级等措施，保护数据库，避免直接被大流量冲垮。

## 7.编程式事务

#### 使用场景

编程式事务管理通常用在以下几种情况：

  * 当需要在方法内部动态决定事务配置（如隔离级别、传播行为）时。
  * 当只有部分业务逻辑需要运行在事务上下文中时。
  * 当需要处理复杂的事务逻辑，例如嵌套事务，或根据特定条件决定是否回滚事务时。

#### 实现方式

在Spring中，编程式事务管理通常可以通过`TransactionTemplate`或`PlatformTransactionManager`接口来实现。

##### 使用`TransactionTemplate`

`TransactionTemplate`是Spring提供的一个简化编程式事务管理的模板类，它封装了事务管理的基本逻辑，使得开发者只需要关注于业务逻辑的实现。

    
    
    public void useTransactionTemplate() {
        TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                // 在这里编写需要执行的业务代码
                // 如果需要回滚事务，可以调用 status.setRollbackOnly();
            }
        });
    }
    

##### 使用`PlatformTransactionManager`

对于需要更细粒度控制的场景，可以直接使用`PlatformTransactionManager`。这种方法需要开发者手动控制事务的开始、提交或回滚。

    
    
    public void useTransactionManager() {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        // 设置事务属性，例如隔离级别和传播行为
        def.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    
        TransactionStatus status = transactionManager.getTransaction(def);
        try {
            // 在这里编写业务代码
            // 正常完成时，提交事务
            transactionManager.commit(status);
        } catch (DataAccessException ex) {
            // 出现异常时，回滚事务
            transactionManager.rollback(status);
            throw ex;
        }
    }
    

## 8\. **Kafka和rabbitmq的区别？**

Apache Kafka和RabbitMQ都是流行的消息队列（Message
Queue）系统，它们在现代的分布式系统中扮演着至关重要的角色，用于在不同的系统或应用组件之间异步传递消息。尽管两者都用于消息传递，但它们在设计理念、架构和适用场景上有着根本的区别。

#### 设计和架构

**Kafka** 设计初衷是为处理高吞吐量的数据流，支持消息的持久化。它基于“发布-
订阅”模式，通过topic进行消息的分类。Kafka的特点是能够支持大量的客户端同时读写消息，同时保持高性能和可扩展性。Kafka的消息是在磁盘上持久化存储的，能够保证消息不会因为服务器故障而丢失。

**RabbitMQ**
是基于AMQP（高级消息队列协议）标准的开源消息队列系统，更侧重于消息的路由、排序、处理和交付。RabbitMQ提供了丰富的消息队列功能，如消息确认、持久化、死信队列等。它支持多种消息传递模式，包括点对点、发布/订阅和路由模式等。RabbitMQ更注重于消息的可靠传递和灵活的消息处理。

#### 性能和可用性

  * **吞吐量** ：Kafka设计用于处理高吞吐量的数据流，因此在大数据处理场景中表现更优。RabbitMQ虽然也能处理高吞吐量，但在极端的负载下可能不如Kafka。

  * **延迟** ：Kafka因为设计为批量处理消息，所以在某些情况下可能会有较高的延迟。而RabbitMQ更注重消息的即时传递，延迟相对较低。

  * **可靠性** ：RabbitMQ提供了更多的消息投递保证，如消息确认机制等，使其在需要确保消息可靠传递的场景下更受欢迎。而Kafka通过分区和副本机制确保数据的可靠性。

#### 适用场景

  * **Kafka** 适合需要处理高吞吐量数据流的场景，如日志聚合、事件源、实时数据分析等。

  * **RabbitMQ** 适合于需要复杂消息路由、消息排序或者需要高级功能如消息确认和持久化的场景，比如电子商务系统的订单处理、银行交易处理等。

## 9\. Redis持久化

Redis支持两种主要的持久化方式：RDB（Redis Database）和AOF（Append Only File）。

#### RDB持久化

RDB持久化通过创建数据集的快照来实现在特定时间点的持久化。

**优点** ：

  * RDB是一个非常紧凑（compact）的文件，它保存了Redis在某一时刻的数据快照。这使得RDB非常适合灾难恢复场景。
  * RDB能够最大化Redis的性能，因为它仅在配置的时间间隔进行快照保存，对CPU资源的消耗较小，在日常操作中几乎不影响Redis的性能。
  * 使用RDB进行数据恢复通常比AOF更快，因为直接将快照文件加载到内存中。

**缺点** ：

  * 如果Redis服务器发生故障，你可能会丢失最后一次快照以来的所有数据。
  * RDB在保存快照时，如果数据集较大，可能会需要较长的时间来保存快照，这可能会影响到服务的可用性。

#### AOF持久化

AOF持久化通过记录服务器所执行的写操作命令来实现数据的持久化，这些命令会被追加到AOF文件的末尾。

**优点** ：

  * AOF可以提供更高级别的数据安全性。通过调整AOF的刷新频率配置，可以在不同的安全级别和性能之间做出权衡。
  * AOF文件是一个只追加的日志文件，即使在追加过程中服务器宕机，也可以通过Redis提供的工具来修复可能出现的任何损坏。
  * AOF能够提供更完整的数据修改记录，可以用于更复杂的数据恢复场景。

**缺点** ：

  * 对于相同的数据集，AOF文件通常比RDB文件大。
  * 根据所使用的fsync策略，AOF可能会比RDB慢。尤其是如果配置为每个写操作都同步到磁盘的话，对性能的影响更为明显。

#### 结合使用RDB和AOF

实际上，许多生产环境中的Redis配置会同时启用RDB和AOF持久化，以便结合两者的优点。例如，可以定期使用RDB进行数据的快照保存，以保证快速的灾难恢复能力，同时使用AOF保证更高的数据安全性，以便在发生故障时尽可能多地恢复数据。

