## 华为OD面试真题精选

专栏：[华为OD面试真题精选](https://blog.csdn.net/banxia_frontend/category_12436481.html)  
目录:
[2024华为OD面试手撕代码真题目录以及八股文真题目录](https://blog.csdn.net/banxia_frontend/article/details/138131520)

#### 文章目录

  * 华为OD面试真题精选
  * **1. Python中的`with`**
  *     * 用途和功能
    *       * 自动资源管理
      * 示例：文件操作
      * 上下文管理协议
      *         * 示例代码
        * 工作流程解析
      * 优点
  * 2\. \\_\\_new\\_\\_ 和 **\\_\\_init\\_\\_** 区别
  *     *       * __new__
      * __init__
      * 区别总结
  * 3\. **切片（Slicing）操作**
  *     *       * 基本切片语法
      * 示例
      * 切片的高级用法
  * 4\. Python 中类方法、类实例方法、静态方法有何区别？
  *     *       * 1\. 实例方法（Instance Methods）
      * 2\. 类方法（Class Methods）
      * 3\. 静态方法（Static Methods）
      * 总结
  * 5\. python中的pass有什么作用
  * 6.什么是解释性语言，什么是编译性语言？
  *     *       * 解释性语言
      *         * 优点：
        * 缺点：
        * 示例：
      * 编译性语言
      *         * 优点：
        * 缺点：
        * 示例：
  * super 函数的作用
  *     *       * Python 3中`super()`的具体作用包括：
      * 使用示例

## **1\. Python中的`with`**

在Python中，`with`
语句用于简化资源管理（如文件操作），并确保使用过程中的清理/关闭动作得以执行。这种语句主要与那些提供了上下文管理协议的对象（即支持
`__enter__()` 和 `__exit__()` 方法的对象）一起使用，其目的是让代码更加简洁且安全。

### 用途和功能

#### 自动资源管理

`with`
语句主要用于确保即使在发生错误的情况下，一段代码运行完毕后资源也能被正确释放或清理。这通常用于文件操作、网络连接、数据库连接等需要明确关闭的操作。

#### 示例：文件操作

最常见的`with`语句用例是文件操作，使用`with`可以自动管理文件的打开和关闭，避免文件未关闭的错误。

    
    
    with open('example.txt', 'r') as file:
        content = file.read()
        print(content)
    
    # 文件在这里已经自动关闭
    

在这个例子中，`open`函数返回一个文件对象，随后在`with`语句块中被使用。当`with`块执行完毕后，`__exit__()`方法会被自动调用，文件会被自动关闭，即使在读取文件时发生异常也是如此。

#### 上下文管理协议

为了使一个对象兼容`with`语句，对象需要实现两个方法：

  * `__enter__(self)`: 进入`with`语句的运行时上下文时被调用，返回的值通常赋给`as`后面的变量。
  * `__exit__(self, exc_type, exc_value, traceback)`: 退出运行时上下文时执行的清理代码，无论是否发生异常都会执行。如果执行过程中发生了异常，这些异常的类型、值和追踪信息会作为参数传递给`__exit__()`。如果`__exit__()`返回`True`，则异常会被清除；否则，异常将被with语句抛出。

让我们创建一个简单的上下文管理器类，用来模拟一个数据库连接的开启和关闭。这个例子将展示如何通过实现 `__enter__` 和 `__exit__`
方法来定义一个符合上下文管理协议的类，使其可以与 `with` 语句一起使用。

##### 示例代码

    
    
    class DatabaseConnection:
        def __init__(self, hostname, port):
            self.hostname = hostname
            self.port = port
            self.connection = None
    
        def __enter__(self):
            # 模拟数据库连接开启
            self.connection = f"Connecting to database at {self.hostname}:{self.port}"
            print(f"Opened connection to {self.hostname}:{self.port}")
            return self.connection
    
        def __exit__(self, exc_type, exc_val, exc_tb):
            # 清理资源，模拟关闭连接
            self.connection = None
            print(f"Closed connection to {self.hostname}:{self.port}")
            # 如果发生异常，返回 False 让异常传播；如果没有异常或处理了异常，可以返回 True
            return False
    
    # 使用自定义的上下文管理器
    with DatabaseConnection("localhost", 5432) as conn:
        print(conn)
        # 在这里进行数据库操作
        # 如果发生异常，__exit__ 方法会被调用，连接将被关闭
    

##### 工作流程解析

  1. **初始化** ：`DatabaseConnection` 类初始化时，接收主机名和端口号，并设置一个初始的 `connection` 属性为 `None`。
  2. **进入上下文** ：当 `with` 语句执行时，`__enter__` 方法被调用。这里，我们模拟了开启数据库连接的过程，并打印了一条连接已开启的信息。`__enter__` 方法返回的值赋给了 `as` 关键字后的变量 `conn`，在 `with` 代码块内部可以使用这个变量。
  3. **代码块执行** ：`with` 语句内部的代码可以使用 `conn` 进行操作。这部分通常会包含对数据库的读写请求。
  4. **退出上下文** ：不管 `with` 代码块内部发生了什么（即使是一个异常），`__exit__` 方法都会被调用来执行清理工作，比如关闭数据库连接。这里我们打印了一条连接已关闭的信息。如果`with`块中发生了异常，这些异常的信息会作为参数传递给 `__exit__` 方法。这个方法可以决定是处理异常还是让它继续传递；通常如果异常被处理了，应该返回 `True`，否则返回 `False`。

这个例子展示了如何通过自定义类实现资源的自动管理，使代码更安全、可读，并且简洁。

#### 优点

  * **代码简洁** ：自动管理资源，减少了重复的代码，如在每个文件操作后调用`file.close()`。
  * **提高安全性** ：即使在代码块中出现错误，也能保证资源正常释放，减少内存泄漏的风险。
  * **可扩展性** ：可以为自定义的类实现上下文管理协议，使得资源管理更加灵活。

总的来说，`with`语句是一种优雅的资源管理手段，它帮助Python程序员写出更安全、更简洁且更可读的代码。

## 2\. __new__ 和 **__init__** 区别

#### **new**

`__new__` 方法是一个静态方法，负责创建一个新的实例。它是在一个对象实例化的时候最先被调用的方法。`__new__`
方法的主要任务是分配空间并返回该类的一个实例。只有当`__new__` 返回一个类的实例时，`__init__` 方法才会被触发。

  * 签名：`__new__(cls, *args, **kwargs)`
  * 返回值：必须返回一个实例（通常是使用 `super().__new__(cls)` 生成的实例）。
  * 应用场景：通常在需要控制对象创建过程的时候使用，例如实现单例模式，或者当继承一个不可变的数据类型且需要在创建时修改数据时。

#### **init**

`__init__` 方法用于初始化对象。在 `__new__` 创建一个实例并将其返回后，`__init__`
方法会被自动调用，用来给这个新创建的对象实例添加初始状态。

  * 签名：`__init__(self, *args, **kwargs)`
  * 返回值：None，`__init__` 不应该有返回值。
  * 应用场景：用于初始化对象属性或执行开始之前必要的准备工作。

#### 区别总结

  * **创建 vs. 初始化** ：`__new__` 负责创建对象，`__init__` 负责初始化对象。
  * **方法类型** ：`__new__` 是一个静态方法（虽然通常不需要显式声明为 @staticmethod），而 `__init__` 是一个实例方法。
  * **返回值** ：`__new__` 必须返回一个实例（通常是通过调用 `super().__new__(cls)` 来实现），而 `__init__` 永远不应该返回任何值，即返回 None。
  * **调用时机** ：只有 `__new__` 返回一个该类的实例时，`__init__` 才会被调用。

## 3\. **切片（Slicing）操作**

#### 基本切片语法

切片操作的基本语法是 `序列[start:stop:step]`，其中：

  * `start` （可选）是切片开始的索引，如果省略，默认从序列的开始处。
  * `stop` （可选）是切片结束的索引，但不包括此索引的元素。如果省略，默认到序列的结束处。
  * `step` （可选）是步长，决定了切片操作中元素的间隔。如果省略，默认为1，表示取每个元素。

#### 示例

假设我们有一个列表：

    
    
    numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    

下面是一些切片的例子：

  1. `numbers[2:5]` \- 这会返回从索引2开始到索引4的元素（不包括索引5），结果是 `[2, 3, 4]`。
  2. `numbers[:3]` \- 这会返回从列表开始到索引2的元素（不包括索引3），结果是 `[0, 1, 2]`。
  3. `numbers[4:]` \- 这会返回从索引4开始到列表的末尾的元素，结果是 `[4, 5, 6, 7, 8, 9]`。
  4. `numbers[-2:]` \- 这会返回从倒数第二个元素开始到列表的末尾的元素，结果是 `[8, 9]`。
  5. `numbers[::2]` \- 这会返回列表中每隔一个元素的元素，从0开始，结果是 `[0, 2, 4, 6, 8]`。
  6. `numbers[1::2]` \- 这会返回列表中每隔一个元素的元素，从1开始，结果是 `[1, 3, 5, 7, 9]`。
  7. `numbers[::-1]` \- 这会返回列表中的元素，倒序排列，结果是 `[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]`。

#### 切片的高级用法

切片操作不仅可以用于获取序列的部分副本，还可以用来修改可变序列的内容。例如，你可以用切片来一次性改变列表中的多个元素：

    
    
    numbers[2:5] = [10, 11, 12]
    print(numbers)  # 输出: [0, 1, 10, 11, 12, 5, 6, 7, 8, 9]
    

此外，切片可以用于删除序列中的元素：

    
    
    del numbers[0:2]
    print(numbers)  # 输出: [10, 11, 12, 5, 6, 7, 8, 9]
    

## 4\. Python 中类方法、类实例方法、静态方法有何区别？

#### 1\. 实例方法（Instance Methods）

实例方法是类中最常见的方法类型。它们至少接收一个参数 `self`，它是对类实例的引用。通过这个 `self`
参数，实例方法可以方便地访问和修改实例的状态。它们也可以访问类本身的任何部分。

    
    
    class MyClass:
        def method(self):
            return 'instance method called', self
    

这种方法依赖于类的一个实例，并且通常用于执行需要访问或修改实例属性的任务。

#### 2\. 类方法（Class Methods）

类方法与实例方法相似，但它们接收一个参数 `cls` 而不是 `self`。这个 `cls`
参数是对类本身的引用，而不是类的一个实例。为了声明一个类方法，需要在方法定义前面使用装饰器 `@classmethod`。

    
    
    class MyClass:
        @classmethod
        def classmethod(cls):
            return 'class method called', cls
    

类方法可以访问和修改类状态，通常用于实现影响整个类而不仅仅是单个实例的行为。

#### 3\. 静态方法（Static Methods）

静态方法不接收特定的参数（如 `self` 或 `cls`）。它们通过使用装饰器 `@staticmethod`
被标记，表明它们既不访问实例状态也不访问类状态。它们功能上类似于包含在类定义中的普通函数。

    
    
    class MyClass:
        @staticmethod
        def staticmethod():
            return 'static method called'
    

静态方法主要用于实现与类的特定实例或类状态无关的功能，它们是一种组织代码的方式，使其保持在类的命名空间下，同时提供一些逻辑上的关联。

#### 总结

  * **实例方法** ：需要通过实例调用，用于处理实例属性。
  * **类方法** ：通过类调用，可以处理类属性，与实例无关。
  * **静态方法** ：既不需要实例也不需要类引用，用于实现与类相关但独立于类和实例的功能。

## 5\. python中的pass有什么作用

  1. **占位符** ：`pass` 最常见的用途是作为占位符。假如你在编写一个新的函数或者类，但还未决定具体实现，可以使用 `pass` 来充当占位符，这样你的代码就可以在不完全实现的情况下编译运行。
    
        def function_that_is_under_development():
        pass
    
    class MyClass:
        pass
    

  2. **维持程序结构** ：在某些情况下，你的代码逻辑可能需要一个语句块不执行任何操作。例如，在你编写一个异常处理或是条件判断时，可能暂时没有代码要执行，此时可以使用 `pass`。
    
        try:
        # 尝试执行某些操作
        operation_that_may_fail()
    except Exception:
        pass  # 异常发生时忽略它
    
    if condition:
        pass  # 如果满足条件，什么也不做
    else:
        handle_alternative_condition()
    

  3. **最小化代码干扰** ：当你需要在一个类或函数中暂时没有内容时，使用 `pass` 可以保持代码的完整性，同时避免因为缺少内容导致的语法错误。

## 6.什么是解释性语言，什么是编译性语言？

在编程语言的世界中，语言通常可以分为两大类：解释性语言和编译性语言。这两类语言的主要区别在于它们如何将高级语言代码转换成机器可以执行的代码。

#### 解释性语言

解释性语言通常是在程序运行时通过一个程序（称为解释器）逐行读取、解释并执行程序代码。这意味着代码在执行之前不会被转换成机器语言。每次运行程序时，解释器都需要重新解释代码，这使得解释性语言通常比编译性语言运行慢，但它们在开发过程中提供了更高的灵活性和更快的调试速度。

##### 优点：

  * **即时执行** ：代码无需编译即可直接运行，简化了开发和调试过程。
  * **平台独立性** ：由于代码由解释器直接执行，只要解释器可用，相同的代码可以在不同的操作系统上运行。
  * **动态性** ：更容易实现动态类型和运行时修改。

##### 缺点：

  * **运行速度慢** ：每次运行程序时都需要解释，增加了执行时间。
  * **资源消耗** ：解释器在运行时需要消耗额外资源。

##### 示例：

Python、Ruby、JavaScript 和 PHP 都是典型的解释性语言。

#### 编译性语言

编译性语言在程序运行之前，需要一个专门的程序（称为编译器）将源代码完整地转换成机器语言代码（通常是二进制格式的可执行文件）。这个转换过程称为编译。编译后的代码可以直接由计算机的硬件执行，无需解释器介入，这使得编译性语言在执行速度上通常优于解释性语言。

##### 优点：

  * **速度快** ：编译后的程序直接由硬件执行，无需解释过程，运行效率高。
  * **优化** ：编译器在编译过程中可以进行深度优化，提高程序性能。
  * **安全性和保密性** ：编译后的代码更难被逆向工程分析。

##### 缺点：

  * **编译时间** ：编译过程可能需要较长时间，尤其是对于大型项目。
  * **平台依赖性** ：编译生成的可执行文件通常只适用于特定的操作系统或硬件。

##### 示例：

C、C++ 和 Java（Java 是一种特例，它首先编译成中间代码（字节码），然后由 Java 虚拟机（JVM）解释或进一步编译执行）是典型的编译性语言。

总结而言，选择解释性语言还是编译性语言取决于项目需求、开发速度、运行速度、跨平台需求等多种因素。

## super 函数的作用

在Python 3中，`super()`
函数是一个非常重要的内置函数，用于在派生类中调用父类的方法。这个函数特别关键，尤其是在处理类的继承时，特别是在多重继承的情况下。通过使用
`super()`，开发者可以保证基类的适当方法被调用，且不必显式地指定这些基类的名称，从而提高代码的可维护性和可扩展性。

#### Python 3中`super()`的具体作用包括：

  1. **访问父类方法** ：`super()` 允许你调用父类的方法，这可以帮助你在子类中覆盖或扩展父类的功能。这种方式非常有用，特别是当你想在子类中扩展而不是完全替换父类方法的功能时。

  2. **自动处理方法解析顺序（MRO）** ：Python 3 使用一种称为C3线性化的算法来确定方法解析顺序。`super()` 自动遵循这一顺序，确保每个父类指定的方法只被调用一次，从而避免在复杂继承结构中的常见错误。

  3. **简化语法** ：在Python 3中，`super()` 可以不带任何参数，Python 解释器会自动识别当前类和方法的上下文。这样，即使在多重继承的情况下，也可以简洁明了地调用超类的方法。

#### 使用示例

以下是一个展示如何在Python 3中使用 `super()` 的示例：

    
    
    class Base:
        def __init__(self, value):
            self.value = value
            print(f"Base initialized with value: {self.value}")
    
    class Derived(Base):
        def __init__(self, value, extra):
            super().__init__(value)  # 无需指定父类或self
            self.extra = extra
            print(f"Derived initialized with extra: {self.extra}")
    
    # 实例化Derived类
    d = Derived(10, 20)
    

在这个例子中，`Derived` 类继承自 `Base` 类。通过在 `Derived` 类的构造器中调用
`super().__init__(value)`，我们能够确保 `Base` 类的构造器被适当地执行，这样可以在 `Base`
类中初始化定义的属性，并接着在 `Derived` 类中添加额外的属性。

总结来说，`super()` 在Python
3中是面向对象编程的一个核心工具，它支持有效地利用继承带来的好处，同时避免了一些常见的编程错误，特别是在多重继承的环境中。正确使用 `super()`
可以大大增强代码的健壮性和清晰度。

