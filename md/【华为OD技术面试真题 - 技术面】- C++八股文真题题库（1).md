## 华为OD面试真题精选

专栏：[华为OD面试真题精选](https://blog.csdn.net/banxia_frontend/category_12436481.html)  
目录:
[2024华为OD面试手撕代码真题目录以及八股文真题目录](https://blog.csdn.net/banxia_frontend/article/details/138131520)

#### 文章目录

  * 华为OD面试真题精选
  * c++ 类的三大特性
  *     *       * 1\. 封装（Encapsulation）
      * 2\. 继承（Inheritance）
      * 3\. 多态（Polymorphism）
  * 虚函数表
  *     *       * 虚函数表的概念
      * 虚函数表的工作原理
      * 虚函数表示例
  * C++的智能指针
  *     *       * 1\. `std::unique_ptr`
      * 2\. `std::shared_ptr`
      * 3\. `std::weak_ptr`
  * vector和deque的区别是什么
  *     *       * 1\. 内部结构
      * 2\. 性能
      * 3\. 使用场景
  * Lambda表达式的参数捕获有哪几种情况
  *     *       * 1\. 值捕获 `[=]`
      * 2\. 引用捕获 `[&]`
      * 3\. 混合捕获
      * 4\. 显式捕获
      * 5\. 默认捕获和显式排除
  * C++ 程序到可执行文件的过程
  * 编译原理，动态链接和静态链接有什么区别
  *     *       * 静态链接（Static Linking）
      * 动态链接（Dynamic Linking）
  * 2 GB 内存的操作系统中，可以分配4 GB 的数组吗
  *     *       * 1\. 32位操作系统
      * 2\. 64位操作系统
  * C++ 程序内存布局是怎么样的？堆和栈有什么区别？
  *     *       * 堆与栈的区别
      * 优缺点

## c++ 类的三大特性

在C++编程中，类的三大特性非常关键，它们是：封装、继承和多态。

#### 1\. 封装（Encapsulation）

封装是指将数据（属性）和操作数据的方法（行为）捆绑在一起的编程技术。在C++中，我们通过创建类来实现封装，类中的数据通常被称为成员变量，操作数据的方法被称为成员函数。

**目的** ：

  * 隐藏内部实现细节。
  * 控制对类成员的访问，通过使用访问修饰符（如 `private`, `protected`, `public`）来实现。

**示例** ：

    
    
    class Account {
    private:
        double balance;  // 私有成员，外部无法直接访问
    
    public:
        Account(double initBalance) : balance(initBalance) {}
    
        void deposit(double amount) {
            if (amount > 0) {
                balance += amount;
            }
        }
    
        double getBalance() const {
            return balance;
        }
    };
    

在这个例子中，`balance` 是私有的，不能直接从类的外部访问，而必须通过公共方法 `deposit` 和 `getBalance` 来操作和访问。

#### 2\. 继承（Inheritance）

继承允许一个类（子类或派生类）继承另一个类（父类或基类）的属性和方法。这样可以在不修改现有类的基础上，通过扩展新的类来增加或修改其功能。

**目的** ：

  * 代码重用。
  * 建立类之间的层次关系。

**示例** ：

    
    
    class Base {
    public:
        void show() {
            std::cout << "Base class show function called." << std::endl;
        }
    };
    
    class Derived : public Base {
    public:
        void show() {
            std::cout << "Derived class show function called." << std::endl;
        }
    };
    

在这个例子中，`Derived` 类继承了 `Base` 类，并覆盖了 `show` 方法。

#### 3\. 多态（Polymorphism）

多态允许我们通过指针或引用调用基类的方法，实现在运行时根据对象的实际类型来调用相应的方法。C++中的多态主要通过虚函数（virtual
functions）实现。

**目的** ：

  * 允许同一个接口使用不同的实例。
  * 增强程序的可扩展性和可维护性。

**示例** ：

    
    
    class Base {
    public:
        virtual void show() {  // 虚函数
            std::cout << "Base class show function called." << std::endl;
        }
    };
    
    class Derived : public Base {
    public:
        void show() override {  // 覆盖基类的虚函数
            std::cout << "Derived class show function called." << std::endl;
        }
    };
    
    void display(Base& b) {
        b.show();  // 多态调用
    }
    

在这个例子中，`display` 函数通过基类引用调用 `show` 方法，具体调用哪个类的方法取决于引用的实际对象类型。

## 虚函数表

在C++中，虚函数表（vtable）是实现多态的重要机制

#### 虚函数表的概念

虚函数表是一个存储指向虚函数的指针的表，每个多态类都会包含这样一个表，用于动态分配调用哪个函数实现。当类中包含虚函数或继承自包含虚函数的基类时，该类对象就会维护一个指向其虚函数表的指针，通常称为虚指针（vptr）。

#### 虚函数表的工作原理

  1. **类的编译时** ：编译器为每个包含虚函数的类生成一个虚函数表。该表中存储了所有虚函数的地址。

  2. **对象的构造时** ：每个对象的虚指针（vptr）被初始化，指向该对象所属类的虚函数表。

  3. **运行时调用** ：当通过基类指针或引用调用虚函数时，编译器实际上会查找该对象的虚指针所指向的虚函数表，然后调用相应表项中的函数指针，实现动态绑定。

#### 虚函数表示例

以下示例展示了多态调用的虚函数表机制：

    
    
    #include <iostream>
    
    class Base {
    public:
        virtual void show() {
            std::cout << "Base class show function called." << std::endl;
        }
    };
    
    class Derived : public Base {
    public:
        void show() override {
            std::cout << "Derived class show function called." << std::endl;
        }
    };
    
    void display(Base& b) {
        b.show();  // 多态调用
    }
    
    int main() {
        Base b;
        Derived d;
        display(b);  // 调用 Base::show()
        display(d);  // 调用 Derived::show()，动态绑定
        return 0;
    }
    

**解释** ：

  * `Base` 类中有一个虚函数 `show`，所以编译器会为 `Base` 和 `Derived` 生成各自的虚函数表。
  * `Derived` 类重写了 `show` 方法，因此其虚函数表将包含对 `Derived::show` 的指针，而 `Base` 的虚函数表则包含对 `Base::show` 的指针。
  * `display` 函数通过基类引用进行多态调用，查找实际对象的虚指针（vptr）来确定调用哪个 `show` 实现。

## C++的智能指针

在C++中，智能指针是一种管理动态分配内存（即使用`new`分配的内存）的工具，通过自动化内存管理来帮助程序员避免内存泄露和指针悬挂等常见错误。C++11标准引入了三种主要的智能指针：`std::unique_ptr`、`std::shared_ptr`和`std::weak_ptr`。

#### 1\. `std::unique_ptr`

`std::unique_ptr`是一种独占所有权的智能指针，意味着同一时间内只能有一个`unique_ptr`指向一个给定的资源。当`unique_ptr`被销毁时（例如，离开作用域时），它指向的对象也会被自动删除。

**优点** ：

  * 防止资源泄漏，自动释放内存。
  * 转移所有权明确，可以使用`std::move`转移所有权。

**示例代码** ：

    
    
    #include <memory>
    
    int main() {
        std::unique_ptr<int> ptr = std::make_unique<int>(10);
        // std::unique_ptr<int> ptr2 = ptr; // 编译错误，不能复制
        std::unique_ptr<int> ptr2 = std::move(ptr); // 所有权转移
        return 0;
    }
    

#### 2\. `std::shared_ptr`

`std::shared_ptr`是一种共享所有权的智能指针，多个`shared_ptr`可以同时指向同一个对象。内部使用引用计数机制来跟踪有多少个`shared_ptr`指向同一个资源，当最后一个这样的指针被销毁时，所指向的对象也会被自动删除。

**优点** ：

  * 允许多个指针共享同一资源。
  * 自动处理资源释放，引用计数为零时释放资源。

**示例代码** ：

    
    
    #include <memory>
    
    int main() {
        std::shared_ptr<int> sptr1 = std::make_shared<int>(20);
        std::shared_ptr<int> sptr2 = sptr1; // 增加引用计数
        return 0;
    }
    

#### 3\. `std::weak_ptr`

`std::weak_ptr`是一种非拥有（不控制生命周期）的智能指针，它设计用来解决`shared_ptr`相互引用导致的循环引用问题。`weak_ptr`不会增加对象的引用计数，因此不会阻止其所指向的对象被释放。

**优点** ：

  * 协助`shared_ptr`管理共享资源，避免循环引用。
  * 可以被升级为`shared_ptr`，从而安全地访问资源。

**示例代码** ：

    
    
    #include <memory>
    
    int main() {
        auto sptr = std::make_shared<int>(30);
        std::weak_ptr<int> wptr = sptr;
        std::shared_ptr<int> sptr2 = wptr.lock(); // 尝试获取一个shared_ptr
        if (sptr2) {
            // 资源未释放，可以安全使用sptr2
        }
        return 0;
    }
    

## vector和deque的区别是什么

在C++中，`vector`和`deque`都是标准模板库（STL）中的序列容器，它们提供了动态数组的功能，但是在内部实现和使用场景上有所不同。

#### 1\. 内部结构

  * **vector** ：`vector`是一个动态数组，它在内存中连续存储所有元素。当`vector`的元素超过当前分配的容量时，它会重新分配一块更大的连续内存空间，将现有元素复制到新的内存地址，并释放旧的内存。
  * **deque** ：`deque`（双端队列）内部通常是由一系列固定大小的数组组成，这些数组的指针存储在一个中心控制块中。因此，`deque`在内存中不保证连续存储。这种结构允许在头部和尾部快速插入和删除，而不需要像`vector`那样频繁地重新分配整个容器。

#### 2\. 性能

  * **vector** ： 
    * 对于尾部的插入和删除操作，`vector`非常高效。
    * 随机访问也非常快，因为内存连续，访问时间为常数时间O(1)。
    * 但是，如果在`vector`的前面或中间插入元素，可能会非常低效，因为这需要移动插入点之后的所有元素。
  * **deque** ： 
    * `deque`支持快速的头部和尾部插入和删除操作，时间复杂度为O(1)。
    * 随机访问虽然也是常数时间O(1)，但通常比`vector`慢，因为需要通过指针进行间接寻址。
    * 在中间插入和删除的效率比`vector`略好，但仍然需要数据移动。

#### 3\. 使用场景

  * **vector** 适合于元素数量相对固定，需频繁访问元素的场景，尤其是当你主要在序列的末尾添加或移除元素时。
  * **deque** 适合于需要频繁在序列两端添加或删除元素的场景，例如实现数据结构如队列和双端队列。

## Lambda表达式的参数捕获有哪几种情况

#### 1\. 值捕获 `[=]`

通过值捕获的方式，Lambda表达式会捕获在其定义时作用域内的所有自动变量的副本。捕获的是变量的值，不是引用，因此在Lambda内部修改这些变量不会影响外部原始变量的值。

    
    
    int x = 10;
    auto lambda = [=]() { return x; }; // x被拷贝到Lambda
    

#### 2\. 引用捕获 `[&]`

引用捕获方式允许Lambda表达式通过引用的方式访问所有外部自动变量。这意味着Lambda内部对这些变量的任何修改都会反映到外部的原始变量上。

    
    
    int x = 10;
    auto lambda = [&]() { x = 20; }; // 外部的x将变为20
    

#### 3\. 混合捕获

Lambda表达式还可以混合使用值捕获和引用捕获，即对某些变量使用值捕获，对其他变量使用引用捕获。

    
    
    int x = 10, y = 20;
    auto lambda = [x, &y]() { y = x + 10; }; // x是通过值捕获，y是通过引用捕获
    

#### 4\. 显式捕获

可以明确指定Lambda表达式捕获哪些变量以及如何捕获（通过值或引用）。这在你只想捕获少数几个变量时非常有用。

    
    
    int x = 10, y = 20;
    auto lambda = [x, &y] { y = x + 10; }; // 仅捕获x和y，x通过值，y通过引用
    

#### 5\. 默认捕获和显式排除

C++14引入了默认捕获与显式排除的功能，允许默认方式捕获大部分变量，但显式地排除一些不需要的变量。

    
    
    int x = 10, y = 20, z = 30;
    auto lambda = [=, &y] { y = x + z; }; // 默认通过值捕获，但y通过引用捕获
    

## C++ 程序到可执行文件的过程

  1. **预处理（Preprocessing）**

     * 这是编译过程的第一步。预处理器处理源代码文件，执行以`#`开头的指令，如宏定义（`#define`）、条件编译（`#ifdef`、`#ifndef`、`#endif`）以及包含头文件的指令（`#include`）。预处理结果是一个“展开”的源代码，其中包含了所有的头文件内容，并替换了所有宏定义。
  2. **编译（Compilation）**

     * 预处理后的文件被送到编译器进行编译。在这一阶段，编译器将完整的源代码转换为汇编指令。编译器还进行语法和语义分析，确保代码遵守C++的规则，并检查类型错误等问题。输出的结果是汇编代码。
  3. **汇编（Assembly）**

     * 汇编器取汇编代码并转换为机器语言指令，通常是目标代码文件（如ELF格式的`.o`文件）。这些目标文件包含了程序的二进制表示，但尚未链接成最终的可执行文件。
  4. **链接（Linking）**

     * 最后阶段是链接。链接器取一个或多个目标文件并将它们与库（可能是动态库或静态库）合并，解决程序中的外部引用问题，生成最终的可执行文件。在这个过程中，链接器处理符号解析和地址绑定，确保所有函数和变量的引用都指向正确的位置。

## 编译原理，动态链接和静态链接有什么区别

#### 静态链接（Static Linking）

静态链接是指在程序编译时将所有用到的外部库（通常是`.lib`或`.a`文件）一同打包进最终的可执行文件中。在这种情况下，最终的可执行文件包含了所有必需的库代码，使得程序可以在没有安装相应库的系统上运行。

**优点：**

  1. **独立性** ：由于所有代码都被包含在一个单独的可执行文件中，因此不依赖于外部的库文件，提高了程序的移植性。
  2. **启动速度** ：程序启动时不需要加载外部库，可以稍微快一些。

**缺点：**

  1. **文件大小** ：静态链接会增加最终可执行文件的大小，因为每一个用到的库都被整体复制到可执行文件中。
  2. **更新问题** ：如果静态链接的库需要更新或修复，整个应用程序需要重新编译和分发。

#### 动态链接（Dynamic Linking）

动态链接是指在程序运行时（而非编译时）将需要的库（通常是`.dll`、`.so`或`.dylib`文件）加载到内存中。只有程序的一个小的引用表在可执行文件中，指向需要用到的库函数。

**优点：**

  1. **节省空间** ：多个程序可以共享同一份库的副本，减少了硬盘空间的占用。
  2. **易于更新** ：更新动态库文件后，所有使用该库的应用程序都可以自动获得更新，无需重新编译。

**缺点：**

  1. **依赖性** ：程序运行依赖于外部的库文件，如果系统没有安装这些库，或者库版本不兼容，程序可能无法运行。
  2. **启动速度** ：加载外部库可能使得程序启动时间略微增加。

## 2 GB 内存的操作系统中，可以分配4 GB 的数组吗

在C++中，是否能在2 GB内存的操作系统中分配4
GB的数组，这个问题取决于多个因素，包括操作系统的类型（32位或64位）、编译器的配置、程序的地址空间布局，以及系统的虚拟内存管理。

#### 1\. 32位操作系统

在32位操作系统中，每个进程通常只能访问最多4
GB的虚拟地址空间。这个地址空间不仅仅用于数据存储（如数组），还需要用于代码、堆栈、堆以及操作系统的映射文件等。因此，实际上用于数据的可用空间会少于4
GB，通常在2 GB左右（取决于操作系统如何划分用户空间和内核空间）。在这种情况下，试图在2 GB内存的32位操作系统中分配4
GB的数组是不可能的，因为虚拟地址空间的限制和物理内存的限制都会阻止这样的操作。

#### 2\. 64位操作系统

在64位操作系统中，每个进程有非常大的虚拟地址空间（理论上高达数TB），这远超过2 GB的物理内存大小。即使是在只有2
GB物理内存的系统上，【理论上也是可以通过虚拟内存机制来分配4
GB的数组的】。虚拟内存允许操作系统使用硬盘空间作为临时存储，从而扩展可用的内存量。然而，这种做法会极大地影响程序的性能，因为从硬盘（即交换空间或页面文件）读写数据的速度远低于从RAM读写。

## C++ 程序内存布局是怎么样的？堆和栈有什么区别？

在C++程序中，内存布局通常包含以下几个区域：

  1. **代码区（Text Segment）** ：存放CPU执行的机器指令。代码区是共享的，即执行同一个程序的所有运行实例可以使用相同的一份代码副本。
  2. **数据区（Data Segment）** ： 
     * **初始化的全局变量和静态变量（Initialized Data Segment）** ：存放程序中已初始化的全局变量和静态变量。
     * **未初始化的全局变量和静态变量（Uninitialized Data Segment，也称为BSS）** ：存放未初始化的全局变量和静态变量。在程序启动前，操作系统将此区域初始化为零。
  3. **堆区（Heap）** ：用于动态内存分配，由程序员分配和释放，若程序员不释放，则程序结束时可能由OS回收。堆的管理由C++的内存管理算法进行，如malloc/free和new/delete。
  4. **栈区（Stack）** ：自动存储函数调用时的参数值、返回地址以及局部变量等。栈是自动管理的数据结构，以LIFO（后进先出）模式运作。

#### 堆与栈的区别

**堆（Heap）** ：

  * **管理方式** ：手动管理。程序员控制何时进行分配和释放。
  * **内存限制** ：堆的大小受到程序可用虚拟内存的限制，通常远大于栈。
  * **分配效率** ：堆内存的分配和释放速度较慢，且容易产生内存碎片。

**栈（Stack）** ：

  * **管理方式** ：自动管理。函数调用时自动分配，函数返回时自动释放。
  * **内存限制** ：栈的大小较小，且在操作系统层面有严格限制（如Linux下通常为8MB）。
  * **分配效率** ：栈内存的分配和释放速度非常快，因为只涉及指针的移动。

#### 优缺点

**堆的优点** ：

  * 可动态分配大量内存。
  * 生命周期灵活，适用于程序生命周期内存储需求未知或非常大的情况。

**堆的缺点** ：

  * 分配效率低下，且易产生内存碎片。
  * 需要手动管理，易出错（如内存泄露、野指针等）。

**栈的优点** ：

  * 分配速度快，管理简单。
  * 内存自动管理，减少内存泄漏的风险。

**栈的缺点** ：

  * 内存大小有限，不能分配大块内存。
  * 可能发生栈溢出，特别是在深度递归或大量局部数据时。

