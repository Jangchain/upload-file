## 华为OD面试真题精选

专栏：[华为OD面试真题精选](https://blog.csdn.net/banxia_frontend/category_12436481.html)  
目录:
[2024华为OD面试手撕代码真题目录以及八股文真题目录](https://blog.csdn.net/banxia_frontend/article/details/138131520)

#### 文章目录

  * 华为OD面试真题精选
  * 多线程中如何使用的锁
  *     *       * 1\. Synchronized 关键字
      * 2\. 显式锁（Lock 接口）
  * 什么是死锁，如何减少这种情况的发生？
  *     *       * 什么是死锁？
      * 死锁的四个必要条件
      * 如何减少死锁的发生？
  * 数据库分表
  *     *       * 1\. 水平分表（Sharding）
      * 2\. 垂直分表
      * 实施分表的考虑因素
      * 技术和工具
  * Redis内存溢出是如何定位解决的
  *     *       * 1\. 监控和识别内存问题
      * 2\. 分析内存使用
      * 3\. 配置适当的内存策略
      * 4\. 优化数据结构和存储模式
      * 5\. 清理不必要的数据
      * 6\. 硬件扩展
  * MQ如何保证信息不丢失的
  *     *       * 1\. 消息持久化
      * 2\. 确认机制
      * 3\. 高可用性和冗余
      * 4\. 事务支持
      * 5\. 死信队列
  * 接口与抽象类的区别
  *     *       * 1\. 基本概念
      * 2\. 主要差异
      * 3\. 使用场景
  * 运行时异常和编译时异常
  *     *       * 1\. 编译时异常（Checked Exceptions）
      * 2\. 运行时异常（Unchecked Exceptions）
  * 创建线程的方式
  *     *       * 1\. 继承 `Thread` 类
      * 2\. 实现 `Runnable` 接口
      * 3\. 使用 `Callable` 和 `FutureTask`
      * 选择建议

## 多线程中如何使用的锁

锁（Locks）在多线程编程中被用来保护共享资源，避免由于并发访问引起的数据不一致性和竞态条件。Java
提供了多种机制来处理锁定，包括内置的同步机制（synchronized 关键字）和 java.util.concurrent 包中的显式锁。

#### 1\. Synchronized 关键字

`synchronized` 是 Java 中最基本的同步机制。它可以用于同步方法和同步块。

  * **同步方法** ：你可以直接在方法声明上使用 `synchronized` 关键字。这时，锁定的是调用该方法的对象（非静态方法）或类的 Class 对象（静态方法）。
    
        public synchronized void method() {
        // 同步代码
    }
    

  * **同步块** ：更细粒度的锁定可以通过 synchronized 块来实现，这允许锁定任何对象。
    
        public void method() {
        synchronized(this) {
            // 访问或修改共享资源
        }
    }
    

#### 2\. 显式锁（Lock 接口）

Java 5 引入了 `java.util.concurrent.locks` 包，提供了更复杂的锁机制，比如
`ReentrantLock`，允许更灵活的结构，比如尝试非阻塞地获取锁，尝试在给定的等待时间内获取锁，以及获取可中断的锁。

    
    
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;
    
    public class Example {
        private final Lock lock = new ReentrantLock();
    
        public void method() {
            lock.lock();
            try {
                // 访问或修改共享资源
            } finally {
                lock.unlock();
            }
        }
    }
    

## 什么是死锁，如何减少这种情况的发生？

#### 什么是死锁？

在多线程编程中，死锁是一种特定的情况，其中两个或更多的线程无限期地等待对方释放由对方持有的资源。这样，每个线程都在等待其他线程释放资源，从而无法向前执行，形成了一个循环等待的局面。

死锁通常涉及多个线程和多个资源。当每个线程持有一部分资源并尝试获取其他线程持有的资源时，如果资源分配顺序不一致，就可能发生死锁。

#### 死锁的四个必要条件

  1. **互斥条件** ：至少有一个资源必须处于非共享模式，即一次只有一个进程可以使用资源。
  2. **至少有一个线程持有一个资源并等待获取一个由其他线程持有的资源** 。
  3. **不可剥夺条件** ：已经分配给一个进程的资源不能被外界强制剥夺，只能由持有该资源的进程主动释放。
  4. **循环等待条件** ：存在一个进程（或线程）的集合，在该集合中每个进程都在等待下一个进程所持有的资源。

#### 如何减少死锁的发生？

  1. **破坏互斥条件** ：尽量使用非互斥的资源或允许资源共享，但这在很多情况下不可能或不实际。

  2. **破坏持有和等待条件** ：

     * 一次性申请所有资源：在开始执行前，让每个线程一次性申请其所需的全部资源。
     * 使用资源预分配策略：尽量确保线程在执行前就已获得所有必需的资源。
  3. **破坏不可剥夺条件** ：

     * 如果线程获取了一部分资源而等待其他资源时，可以让线程释放其持有的资源，再重新申请全部资源。
  4. **破坏循环等待条件** ：

     * 资源排序和按序申请：为系统中的所有资源指定一个固定的线性顺序，并规定所有进程必须按照这种顺序申请资源。
     * 使用锁顺序：编程时确保所有线程以相同的顺序申请锁。
  5. **使用锁超时** ：

     * 在尝试获取锁时使用超时，这样线程在等待锁超过特定时间后会自动放弃，从而减少死锁的可能性。
  6. **死锁检测和恢复** ：

     * 运行时通过各种算法检测系统是否进入死锁状态。一旦检测到死锁，可以采取措施，如终止进程或强制释放资源，来解决死锁。

## 数据库分表

常见的数据库分表策略：

#### 1\. 水平分表（Sharding）

水平分表是将一个表中的行分散到多个结构相同的表中。这种方式通常基于表中某个字段的值来进行切分，这个字段通常被称为分片键。

  * **范围分片** ：根据分片键的值范围来分配数据。例如，按日期、ID范围等。
  * **哈希分片** ：使用哈希函数对分片键的值进行哈希处理，根据哈希值将数据分配到不同的表中。这种方式可以保证数据均匀分布。

#### 2\. 垂直分表

垂直分表是指将一个表中的列拆分到多个表中，每个表存储原表中的部分列。这种方式适用于表中某些列被频繁访问而其他列访问较少的情况。

  * **按功能划分** ：根据列的功能关系将它们分到不同的表中，例如，将用户的基本信息和登录信息分到不同的表中。
  * **按访问频率划分** ：将经常一起访问的列放在同一个表中，将不常访问的列分到其他表中，这样可以优化常用查询的性能。

#### 实施分表的考虑因素

  * **分表的复杂性** ：分表会增加数据库架构的复杂性，需要更多的管理和维护工作。
  * **数据一致性** ：在分表的环境中维护数据一致性比在单一表中更为复杂。
  * **查询跨表** ：如果需要跨多个分表进行查询或联合，可能会降低查询效率和增加查询复杂性。

#### 技术和工具

现代数据库管理系统（如 MySQL, PostgreSQL）和分布式数据库（如 Cassandra,
MongoDB）提供了支持分表的机制。此外，还有专门的中间件和工具，如 Apache ShardingSphere、Vitess
等，可以帮助实现数据库的分片和管理。

## Redis内存溢出是如何定位解决的

在使用Redis作为缓存或存储解决方案时，可能会遇到内存溢出的问题。内存溢出通常表明Redis服务器分配的内存资源不足以存储当前的数据量。定位和解决Redis内存溢出问题的步骤包括以下几个方面：

#### 1\. 监控和识别内存问题

首先，需要使用监控工具来跟踪Redis的内存使用情况。可以通过Redis自带的`INFO`命令来查看内存使用情况，特别是`used_memory`和`maxmemory`两个参数。如果`used_memory`接近或超过了`maxmemory`的值，就可能出现内存溢出的情况。

#### 2\. 分析内存使用

使用`MEMORY`命令（Redis 4.0及以上版本支持）来获取更详细的内存使用信息。例如，`MEMORY
STATS`可以提供内存分配的详细统计，帮助理解内存消耗的具体来源。

另外，还可以使用`redis-cli --bigkeys`命令来找出占用内存最多的几个键，这些键可能是内存溢出的主要原因。

#### 3\. 配置适当的内存策略

Redis提供了多种内存管理策略，可以在`redis.conf`配置文件中设置`maxmemory-policy`参数：

  * `noeviction`: 不进行任何驱逐，如果内存不足时尝试写入将返回错误。
  * `allkeys-lru`: 从所有键中使用LRU算法移除最少使用的键。
  * `volatile-lru`: 只从设置了过期时间的键中选择最少使用的键进行删除。
  * `allkeys-random`: 随机删除任意键。
  * `volatile-random`: 随机删除设置了过期时间的键。
  * `volatile-ttl`: 删除即将到期的键。

选择合适的驱逐策略可以有效地管理内存使用，并防止内存溢出。

#### 4\. 优化数据结构和存储模式

检查和优化存储在Redis中的数据结构。有时候，不合理的数据结构或过大的键值对会导致内存使用效率低下。例如，使用散列（hashes）来存储具有多个字段的对象，而不是为每个字段创建一个独立的键。

#### 5\. 清理不必要的数据

定期检查和删除不再需要的数据或临时键。可以设定键的过期时间（TTL），让Redis自动删除那些过期的数据。

#### 6\. 硬件扩展

如果数据量持续增长，且上述优化措施仍然无法满足需求，可能需要通过增加更多的内存硬件资源来解决问题。在分布式环境中，也可以考虑使用Redis集群来分散数据，从而扩展总体可用内存。

## MQ如何保证信息不丢失的

#### 1\. 消息持久化

消息持久化是确保消息不丢失的基本策略之一。这意味着消息在被发送后，即使发生系统崩溃或其他故障，也会被保存到磁盘或其他持久存储中。在MQ系统中，比如RabbitMQ和Kafka等，可以配置消息持久化。例如，在RabbitMQ中，可以将消息标记为持久化（通过设置delivery
mode为2），并确保队列本身也被声明为持久的。在Kafka中，所有消息默认都存储在磁盘上，不会因为系统故障而丢失。

#### 2\. 确认机制

确保消息被正确处理的一个重要机制是使用消息确认（acknowledgements）。消费者在成功处理消息后发送一个确认信号回MQ服务器。在RabbitMQ中，可以通过显式地设置ACK模式来确保消息在被消费者处理后不会被MQ服务器删除。如果消费者因故障失效，未被确认的消息可以重新被分配给其他消费者。

#### 3\. 高可用性和冗余

部署高可用性的MQ集群是防止消息丢失的另一个策略。例如，在Kafka中，可以通过复制因子（replication
factor）来设置每个消息在多个服务器上的副本数。即使在某些服务器故障的情况下，其他服务器上的副本可以保证消息的可用性。RabbitMQ也支持类似的镜像队列机制，来在多个节点间复制队列的状态。

#### 4\. 事务支持

某些MQ系统提供事务支持，以确保消息在发送或接收过程中的一致性。通过事务，可以保证一组操作要么全部成功，要么全部失败，这有助于在出现故障时保证消息状态的一致性。例如，RabbitMQ支持AMQP协议中的事务。

#### 5\. 死信队列

设置死信队列（DLQ）可以帮助管理无法正常处理的消息。当消息由于某些原因（如重试次数过多）无法被消费时，可以被重定向到死信队列。这不仅防止了消息的丢失，还便于开发人员检查和解决问题。

## 接口与抽象类的区别

#### 1\. 基本概念

  * **接口（Interface）** ：接口是一个完全抽象的类，它允许声明一组方法（在Java 8之前是不能包含实现的），任何实现该接口的类都必须实现这些方法。从Java 8开始，接口也可以包含默认和静态方法。
  * **抽象类（Abstract Class）** ：抽象类是不能被实例化的类，它可以包含抽象方法（无具体实现的方法）和具体方法（有实现的方法）。抽象类是用来捕捉子类的通用特性的。

#### 2\. 主要差异

  * **实现方式** ：一个类可以实现多个接口，但只能继承一个抽象类。这意味着接口支持多重继承的特性，而抽象类则不行。
  * **方法定义** ： 
    * 接口可以包含默认方法（带有实现的方法），静态方法（属于接口，不可被子类或实现类继承）和抽象方法。
    * 抽象类可以包含抽象方法和非抽象方法，这意味着抽象类可以提供某个方法的部分实现，交由子类完成全部实现。
  * **构造函数** ：抽象类可以有构造函数，而接口不能有。
  * **状态存储** ：抽象类可以包含成员变量，这些变量可以是非final的，而接口中的变量默认是public、static和final的。

#### 3\. 使用场景

  * **接口** ：当你希望多个类完全不同的对象实现同一套API时，应该使用接口。例如，各种不同的数据访问对象（DAO）可能实现相同的数据访问接口。
  * **抽象类** ：当几个类有共同的方法和数据（状态）时，或者需要从相同的地方继承一些已实现的功能时，使用抽象类更合适。例如，一个基类为所有的动物提供食物摄入和呼吸的基本行为定义。

## 运行时异常和编译时异常

编译时异常（Checked Exceptions）和运行时异常（Unchecked Exceptions）。

#### 1\. 编译时异常（Checked Exceptions）

编译时异常是那些在编译期间必须被捕获或声明抛出的异常。这类异常通常是外部错误，程序本身无法预防，但必须处理它们以防止程序中断。编译时异常强制程序员在编写代码时就处理这些潜在的错误，增加了程序的健壮性。

**特点** ：

  * 必须在方法的throws子句中声明，或者通过try-catch块捕获。
  * 通常与外部世界的数据交互相关（如文件操作、网络连接等）。

**示例** ：

  * `IOException`：处理输入输出操作时可能发生的异常。
  * `SQLException`：在处理数据库时遇到的异常。

#### 2\. 运行时异常（Unchecked Exceptions）

运行时异常是那些在执行期间可能发生的异常，它们不需要在编译时被捕获或声明。这类异常通常是由程序错误导致的，如逻辑错误或不当的API使用。

**特点** ：

  * 继承自`RuntimeException`。
  * 编译器不要求强制处理这些异常（即不需要throws声明或捕获它们）。
  * 通常是由程序逻辑错误引起的，应该在开发过程中避免。

**示例** ：

  * `NullPointerException`：当程序试图访问一个null对象的成员时抛出。
  * `IndexOutOfBoundsException`：当尝试访问数组或列表的非法索引时抛出。

## 创建线程的方式

在Java中创建线程主要有三种方式 ：

#### 1\. 继承 `Thread` 类

这是创建线程最直接的方式之一。你可以通过继承 `Thread` 类，并覆盖它的 `run()` 方法来定义线程执行的代码。

**示例** ：

    
    
    public class MyThread extends Thread {
        @Override
        public void run() {
            // 线程要执行的任务
            System.out.println("Thread is running.");
        }
    
        public static void main(String[] args) {
            MyThread thread = new MyThread();
            thread.start();  // 启动线程
        }
    }
    

**优点** ：

  * 简单易懂，直接继承并实现 `run()` 方法。

**缺点** ：

  * Java不支持多重继承，如果一个类已经继承了另一个类，就不能再继承 `Thread`。
  * 不够灵活，例如，线程的任务不能轻易地与线程分离。

#### 2\. 实现 `Runnable` 接口

这是创建线程较为常用的一种方式。通过实现 `Runnable` 接口的 `run()` 方法定义线程任务，然后将 `Runnable` 实例传给
`Thread` 类的构造函数。

**示例** ：

    
    
    public class MyRunnable implements Runnable {
        @Override
        public void run() {
            // 线程要执行的任务
            System.out.println("Thread is running.");
        }
    
        public static void main(String[] args) {
            Thread thread = new Thread(new MyRunnable());
            thread.start();  // 启动线程
        }
    }
    

**优点** ：

  * 增加了程序的灵活性，可以将 `Runnable` 对象传给多个线程。
  * 一个类可以实现多个接口，避免了单继承的限制。

**缺点** ：

  * 如果需要访问当前线程，必须使用 `Thread.currentThread()`。

#### 3\. 使用 `Callable` 和 `FutureTask`

`Callable` 类似于 `Runnable`，但它可以返回一个结果，并能抛出检查型异常。`Callable` 需要配合 `FutureTask`
使用，`FutureTask` 是一个实现了 `Future` 和 `Runnable` 的包装器。

**示例** ：

    
    
    import java.util.concurrent.*;
    
    public class MyCallable implements Callable<Integer> {
        @Override
        public Integer call() throws Exception {
            // 线程要执行的任务，并返回结果
            return 123;
        }
    
        public static void main(String[] args) throws ExecutionException, InterruptedException {
            FutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());
            Thread thread = new Thread(futureTask);
            thread.start();  // 启动线程
            System.out.println("Result from thread: " + futureTask.get());  // 获取结果
        }
    }
    

**优点** ：

  * 可以返回值。
  * 可以抛出异常。

**缺点** ：

  * 相对复杂，使用不当可能会导致性能问题，如阻塞等待 `futureTask.get()`。

#### 选择建议

  * 如果不需要返回结果也不抛出检查型异常，通常推荐使用 `Runnable`。
  * 如果需要返回值或抛出异常，选择 `Callable`。
  * 直接继承 `Thread` 的情况较少，除非确实需要扩展 `Thread` 类的其他功能。

