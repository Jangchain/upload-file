## 华为OD面试真题精选

专栏：[华为OD面试真题精选](https://blog.csdn.net/banxia_frontend/category_12436481.html)  
目录:
[2024华为OD面试手撕代码真题目录以及八股文真题目录](https://blog.csdn.net/banxia_frontend/article/details/138131520)

#### 文章目录

  * 华为OD面试真题精选
  * 1.浏览器的缓存机制，涉及浏览器是怎么存放缓存的，强制缓存的概念
  *     *       * 1\. **浏览器缓存机制**
      * 2\. **浏览器缓存的存储位置**
      * 3\. **强制缓存的概念**
      * 4\. **协商缓存**
      * 5\. **缓存更新策略**
  * 2.CSS position属性的值有哪几种分别介绍区别
  *     *       * 1\. **`static`（默认值）**
      * 2\. **`relative`（相对定位）**
      * 3\. **`absolute`（绝对定位）**
      * 4\. **`fixed`（固定定位）**
      * 5\. **`sticky`（粘性定位）**
  * 3.css盒子模型
  *     *       * 1\. **盒子模型的组成部分**
      * 2\. **两种盒子模型：标准盒子模型和怪异盒子模型**
  * 4.隐藏页面元素的方法
  *     *       * 1\. **`display: none;`**
      * 2\. **`visibility: hidden;`**
      * 3\. **`opacity: 0;`**
      * 4\. **`position: absolute;` 结合负值的 `left`、`top` 等属性**
      * 5\. **`z-index` 结合 `position` 属性**
      * 6\. **`clip-path` or `clip`**
      * 7\. **移除元素节点**
      * 8\. **使用 `aria-hidden="true"`**
      * 9\. **`transform: scale(0);` 或 `transform: translateX(-100%);`**
  * 5\. 介绍js的闭包，闭包是怎么样保存私有变量的？
  *     *       * 闭包的定义
      * 闭包的工作原理
      * 闭包如何保存私有变量
      * 分析
  * 6\. js作用域分别有哪些
  *     *       * 1\. **全局作用域（Global Scope）**
      * 2\. **函数作用域（Function Scope）**
      * 3\. **块级作用域（Block Scope）**
      * 4\. **词法作用域（Lexical Scope）**
      * 5\. **模块作用域（Module Scope）**
  * 7\. 箭头函数的特性
  *     *       * 1\. **语法简洁**
      * 2\. **没有自己的 `this` 绑定**
      * 3\. **不能用作构造函数**
      * 4\. **没有 `arguments` 对象**
      * 5\. **不能使用 `yield` 关键字**

![封面](https://i-blog.csdnimg.cn/blog_migrate/82eb94d80bcaaf02b1fc85510bdbccb5.png)

## 1.浏览器的缓存机制，涉及浏览器是怎么存放缓存的，强制缓存的概念

#### 1\. **浏览器缓存机制**

浏览器缓存机制是指浏览器为了提高页面加载速度、减少服务器负载，将已经访问过的资源（如 HTML、CSS、JS
文件，图片等）保存在本地的一种策略。当用户再次访问同一资源时，浏览器可以直接从缓存中读取数据，而不需要再次向服务器请求。

#### 2\. **浏览器缓存的存储位置**

浏览器通常会将缓存存储在以下几个地方：

  * **Memory Cache** （内存缓存）：存储在浏览器的内存中，速度非常快，适合存储一些较小的资源。通常在关闭浏览器时清空。
  * **Disk Cache** （磁盘缓存）：存储在本地磁盘中，存储量较大，可以长期保存，适合大文件和长期需要缓存的资源。
  * **Service Workers Cache** ：借助 Service Workers API，可以在本地保存特定的资源，甚至支持离线访问。
  * **IndexedDB、LocalStorage、SessionStorage** ：这些 Web 存储机制主要用于结构化的数据。

#### 3\. **强制缓存的概念**

强制缓存是指浏览器直接从缓存中读取资源，而不需要向服务器发起请求确认资源的有效性。强制缓存的实现依赖于 HTTP 响应头中的以下两个字段：

  * **Expires** ：使用一个具体的时间戳（如 “Wed, 21 Oct 2023 07:28:00 GMT”）来指定资源的过期时间。在过期时间之前，浏览器会直接使用缓存的资源，不会向服务器发送请求。
  * **Cache-Control** ：这是一个更现代的缓存控制方式，通常替代 Expires。它可以包含多个指令，如 `max-age`（指定资源的最大缓存时间，单位为秒）、`no-cache`（不使用缓存，每次都向服务器确认资源是否有效）、`no-store`（不缓存资源）等。

#### 4\. **协商缓存**

如果强制缓存失效，浏览器会向服务器发送请求，询问资源是否有更新。这时会用到协商缓存机制。常见的协商缓存字段有：

  * **Last-Modified / If-Modified-Since** ：浏览器发送请求时会附带 `If-Modified-Since` 头部，如果资源自上次请求后没有更新，服务器会返回 `304 Not Modified` 状态码，并且不返回资源的内容。
  * **ETag / If-None-Match** ：ETag 是服务器为每个资源生成的唯一标识符。浏览器请求时带上 `If-None-Match`，如果资源未修改，服务器同样返回 `304 Not Modified`。

#### 5\. **缓存更新策略**

浏览器缓存机制的核心目标是平衡性能和资源的实时性。通常，前端开发者会根据业务需求，利用 HTTP 头部来控制缓存策略，以达到最佳的用户体验。例如：

  * 对于静态资源（如图片、CSS 文件），可以设置长时间的强制缓存，并通过文件名的变化来触发缓存更新。
  * 对于频繁变化的资源，可以使用 `Cache-Control: no-cache` 来确保资源的实时性。

## 2.CSS position属性的值有哪几种分别介绍区别

  * **`static`** ：默认定位，元素按文档流排列，不受 `top` 等影响。
  * **`relative`** ：相对定位，基于原始位置偏移，但仍占据原空间。
  * **`absolute`** ：绝对定位，相对于最近的定位祖先元素脱离文档流定位。
  * **`fixed`** ：固定定位，相对于浏览器窗口固定，不随页面滚动。
  * **`sticky`** ：粘性定位，在特定条件下从相对变为固定定位。

#### 1\. **`static`（默认值）**

  * **定义** ：这是所有元素默认的 `position` 值，表示元素会按照正常的文档流进行排列，不会受到 `top`、`right`、`bottom`、`left` 属性的影响。
  * **特点** ：元素的位置由其在 HTML 中的顺序决定。即使你设置了 `top`、`left` 等属性，它们也不会生效，因为 `static` 下元素的位置是不可调整的。

#### 2\. **`relative`（相对定位）**

  * **定义** ：相对定位的元素仍然保留在文档流中，但可以通过 `top`、`right`、`bottom`、`left` 属性相对于它在文档流中的原始位置进行偏移。
  * **特点** ： 
    * 元素在页面上的空间依然被保留（即它仍然占据原来位置的空间）。
    * 相对定位主要用于对元素进行微调而不影响文档流的其他部分。
    * 其他元素仍会按照该元素原来的位置排列。

#### 3\. **`absolute`（绝对定位）**

  * **定义** ：绝对定位的元素脱离了文档流，通过 `top`、`right`、`bottom`、`left` 属性相对于最近的**定位祖先元素** （即设置了 `relative`、`absolute` 或 `fixed` 的父级元素）进行定位。如果没有找到这样的父级元素，则相对于浏览器窗口（或文档的 `<html>` 元素）定位。
  * **特点** ： 
    * 元素不再占据原始位置的空间，因此不会影响其他元素的布局。
    * 绝对定位常用于创建悬浮元素、模态框或自定义组件。

#### 4\. **`fixed`（固定定位）**

  * **定义** ：固定定位的元素相对于浏览器窗口进行定位，即使页面滚动，它也不会移动。
  * **特点** ： 
    * 与 `absolute` 类似，`fixed` 定位的元素脱离了文档流，不会影响其他元素的布局。
    * 常用于创建始终固定在屏幕某个位置的元素，如导航栏、返回顶部按钮等。

#### 5\. **`sticky`（粘性定位）**

  * **定义** ：粘性定位是一种混合定位模式，元素在页面滚动到某个阈值前是相对定位的，当达到阈值后，它会变为固定定位，固定在某个位置。
  * **特点** ： 
    * 结合了 `relative` 和 `fixed` 的特性：在阈值之前是相对定位，达到阈值后变为固定定位。
    * 常用于实现像表头在滚动过程中固定在顶部的效果。
    * 需要注意的是，父容器的 overflow 设为 `hidden`、`scroll` 或 `auto` 时，`sticky` 定位的效果可能会失效。

## 3.css盒子模型

#### 1\. **盒子模型的组成部分**

一个标准的 CSS 盒子模型由以下四个部分组成，从内到外分别是：

  * **Content（内容区域）** ：

    * 包含实际显示的内容，比如文本、图像或其他子元素。`width` 和 `height` 属性直接影响内容区域的尺寸。
  * **Padding（内边距）** ：

    * 内容区域与边框之间的空间。`padding` 属性可以设置内容区域四周的内边距，增加盒子的实际可见尺寸，但不会影响内容区域的大小。
  * **Border（边框）** ：

    * 围绕在内边距外部的边框。通过 `border` 属性可以设置边框的宽度、样式和颜色。边框也会增加盒子的整体尺寸。
  * **Margin（外边距）** ：

    * 盒子与其他元素之间的外部空间。`margin` 属性可以设置元素四周的外边距，控制元素之间的距离。外边距不会影响盒子本身的尺寸，但会影响元素在页面上的间距。

#### 2\. **两种盒子模型：标准盒子模型和怪异盒子模型**

在 CSS 中，盒子模型有两种模式：标准盒子模型和怪异盒子模型。

  * **标准盒子模型（content-box）** ：

    * 默认模式，`width` 和 `height` 只应用于内容区域（Content）。
    * 盒子的总宽度和总高度计算公式： 
      * 总宽度 = `width` \+ `padding-left` \+ `padding-right` \+ `border-left-width` \+ `border-right-width`
      * 总高度 = `height` \+ `padding-top` \+ `padding-bottom` \+ `border-top-width` \+ `border-bottom-width`
  * **怪异盒子模型（border-box）** ：

    * 在这种模式下，`width` 和 `height` 包括内容区域、内边距和边框的总和。
    * 盒子的总宽度和总高度直接等于 `width` 和 `height`，不需要额外计算内边距和边框： 
      * 总宽度 = `width`（已包含内边距和边框）
      * 总高度 = `height`（已包含内边距和边框）
    * 可以通过设置 `box-sizing: border-box;` 来启用这种模型。

## 4.隐藏页面元素的方法

#### 1\. **`display: none;`**

  * **效果** ：元素被完全从文档流中移除，不占据任何空间。页面上的其他元素会填补这个空隙。
  * **特点** ： 
    * 隐藏的元素不会被渲染，也不会响应任何用户交互。
    * 适合需要完全移除元素的场景，例如条件渲染、切换组件等。
    * 注意：使用 `display: none;` 隐藏的元素不会被屏幕阅读器读取，这意味着对无障碍访问有影响。

#### 2\. **`visibility: hidden;`**

  * **效果** ：元素仍然保留在文档流中，占据空间，但不可见。
  * **特点** ： 
    * 元素不可见，但页面布局不会变化，因为元素依然存在并占据空间。
    * 隐藏的元素不会响应点击等用户交互。
    * 可以用在希望保持页面布局不变但临时隐藏内容的场景中。
    * 屏幕阅读器通常仍然会读取 `visibility: hidden;` 的元素，这可能对无障碍访问有用。

#### 3\. **`opacity: 0;`**

  * **效果** ：元素完全透明，不可见，但仍保留在文档流中，占据空间，并且可以响应用户交互。
  * **特点** ： 
    * 元素只是变得透明，仍会触发事件，如点击、hover 等。
    * 页面布局保持不变，元素的存在感可以通过用户交互体验到。
    * 适用于需要保留交互但暂时隐藏视觉内容的场景，例如悬浮效果、淡入淡出动画等。
    * 屏幕阅读器通常仍然会读取该元素。

#### 4\. **`position: absolute;` 结合负值的 `left`、`top` 等属性**

  * **效果** ：通过将元素移动到屏幕之外来隐藏元素，但它仍然在文档流中，并且会影响布局（尽管在视觉上不可见）。
  * **特点** ： 
    * 元素被移出了视口范围，因此不可见，但实际上仍存在于页面结构中。
    * 适用于需要暂时移除可视区域的内容，但仍希望保留元素的其他特性（例如占位、样式、动画等）。
    * 在某些情况下，这种方法可能导致页面滚动条意外出现。

#### 5\. **`z-index` 结合 `position` 属性**

  * **效果** ：通过设置较低的 `z-index` 值（小于其他元素）或较高的 `z-index` 值（超出视口范围）来隐藏元素。
  * **特点** ： 
    * 元素仍在文档流中，只是被其他元素遮挡住或被移到视口外。
    * 适合用于元素层叠顺序管理，在需要动态调整元素层级时使用。

#### 6\. **`clip-path` or `clip`**

  * **效果** ：通过裁剪元素的显示区域，使其不可见。
  * **特点** ： 
    * 可以精确控制元素的可见部分或完全隐藏元素。
    * 常用于图像、动画效果或需要部分显示的场景。
    * 被裁剪的部分不可见，但仍保留在文档流中。

#### 7\. **移除元素节点**

  * **方法** ：通过 JavaScript 或其他动态手段直接从 DOM 中移除元素节点。
  * **效果** ：元素从文档中完全移除，不占据空间。
  * **特点** ： 
    * 页面布局可能会发生变化，其他元素会填补被移除元素的位置。
    * 适用于完全不再需要该元素的场景。
    * 无法通过 CSS 恢复元素，除非重新将元素添加回 DOM。

#### 8\. **使用`aria-hidden="true"`**

  * **效果** ：元素仍然在页面上显示，但对于使用屏幕阅读器的用户不可见。
  * **特点** ： 
    * 适用于无障碍访问控制，隐藏那些不应该被阅读器访问的内容。
    * 不影响元素的可见性和布局。

#### 9\. **`transform: scale(0);` 或 `transform: translateX(-100%);`**

  * **效果** ：通过 CSS 转换来缩放或移动元素，使其不可见。
  * **特点** ： 
    * 可以用于动画效果，通过 CSS transition 或 animation 实现平滑的隐藏或显示效果。
    * 元素仍在文档流中，并占据空间，但视觉上不可见。

## 5\. 介绍js的闭包，闭包是怎么样保存私有变量的？

#### 闭包的定义

闭包是指一个函数能够记住并访问它的词法作用域，即使在函数执行完之后，外部作用域的变量依然可以被访问和操作。闭包通常在以下情况下生成：

  * 一个函数内部定义了另一个函数。
  * 内部函数访问了外部函数的变量。
  * 这个内部函数在外部被调用。

#### 闭包的工作原理

为了理解闭包如何保存私有变量，首先要了解JavaScript的作用域链。每当函数被创建时，函数内部会形成一个闭包。这个闭包由函数和它可以访问的外部环境（也称为词法环境）组成。

当一个函数在外部作用域中被调用时，它依然能够通过闭包访问它原始定义时的环境变量。这是因为当JavaScript函数被创建时，它会在内存中记录下它所能访问的变量，即使外部函数已经执行结束，JavaScript引擎依然会保留这些变量的引用，从而实现变量的持久化。

#### 闭包如何保存私有变量

私有变量可以通过闭包实现，常见的做法是使用一个函数来创建一个局部作用域，然后在这个作用域内定义变量和操作这些变量的函数。外部只能通过闭包暴露出来的函数来访问和修改这些变量，而不能直接访问它们。

以下是一个示例代码，展示了如何使用闭包来保存私有变量：

    
    
    function createCounter() {
        let count = 0; // 私有变量
    
        return {
            increment: function() {
                count++;
                return count;
            },
            decrement: function() {
                count--;
                return count;
            },
            getCount: function() {
                return count;
            }
        };
    }
    
    const counter = createCounter();
    console.log(counter.increment()); // 输出 1
    console.log(counter.increment()); // 输出 2
    console.log(counter.decrement()); // 输出 1
    console.log(counter.getCount());  // 输出 1
    

#### 分析

  * `createCounter` 函数中定义了一个私有变量 `count`，这个变量只在 `createCounter` 的作用域内有效。
  * `createCounter` 返回了一个包含多个方法的对象，这些方法是 `increment`、`decrement` 和 `getCount`，这些方法在定义时形成了闭包，它们可以访问 `count` 变量。
  * 当调用 `counter.increment()` 等方法时，尽管 `createCounter` 函数的执行环境已经结束，但由于闭包的存在，这些方法仍然可以访问并修改 `count` 变量。

## 6\. js作用域分别有哪些

#### 1\. **全局作用域（Global Scope）**

  * **定义** ：在代码的任何地方都可以访问的作用域。所有在函数外部定义的变量和函数都会被添加到全局作用域中。
  * **特点** ： 
    * 全局变量可以在任何地方访问。
    * 全局作用域中的变量会挂载在 `window` 对象（浏览器环境中）或 `global` 对象（Node.js 环境中）上。
    * 全局变量可能引发命名冲突，因此不推荐滥用。

    
    
    var globalVar = 'I am global'; // 全局变量
    function test() {
        console.log(globalVar); // 可以访问到全局变量
    }
    

#### 2\. **函数作用域（Function Scope）**

  * **定义** ：在函数内部定义的变量只能在该函数内部访问，即局部变量。函数作用域在函数调用时才会被创建，并在函数执行结束后销毁。
  * **特点** ： 
    * 函数作用域内的变量和函数只能在该函数内部访问。
    * 不同函数之间的作用域是独立的。
    * 可以通过函数嵌套形成嵌套作用域。

    
    
    function test() {
        var localVar = 'I am local';
        console.log(localVar); // 可以访问到局部变量
    }
    console.log(localVar); // 报错，无法在函数外访问局部变量
    

#### 3\. **块级作用域（Block Scope）**

  * **定义** ：块级作用域是由 `let` 和 `const` 关键字引入的，定义在 `{}` 大括号内的作用域。包括在 `if`、`for`、`while` 等代码块内部。
  * **特点** ： 
    * 变量只在块内部可见。
    * 块级作用域可以避免变量提升问题，减少全局作用域中的变量。
    * `let` 和 `const` 定义的变量在块级作用域之外不可访问。

    
    
    if (true) {
        let blockVar = 'I am block scoped';
        console.log(blockVar); // 可以访问到块级变量
    }
    console.log(blockVar); // 报错，无法在块外访问块级变量
    

#### 4\. **词法作用域（Lexical Scope）**

  * **定义** ：词法作用域指的是函数的作用域在函数定义时就已经确定，而不是在函数调用时确定。函数在定义时“记住”了它创建时的环境，这个环境决定了函数可以访问哪些变量。
  * **特点** ： 
    * 词法作用域是静态的，与函数的调用位置无关。
    * 闭包是词法作用域的一个重要应用。

    
    
    function outerFunction() {
        var outerVar = 'I am outside';
        function innerFunction() {
            console.log(outerVar); // 可以访问到外部函数的变量
        }
        return innerFunction;
    }
    var myFunction = outerFunction();
    myFunction(); // 输出 'I am outside'
    

#### 5\. **模块作用域（Module Scope）**

  * **定义** ：在模块化代码（如 ES6 模块）中，每个模块都有自己的作用域，模块内部定义的变量和函数默认是模块内私有的，除非使用 `export` 关键字将其导出。
  * **特点** ： 
    * 模块作用域与全局作用域隔离，不会污染全局作用域。
    * 通过 `import` 和 `export` 可以控制模块之间的依赖关系和变量共享。
    * 提供了一种封装代码和管理依赖的方式。

    
    
    // module1.js
    const moduleVar = 'I am in a module';
    export function getModuleVar() {
        return moduleVar;
    }
    
    // main.js
    import { getModuleVar } from './module1.js';
    console.log(getModuleVar()); // 输出 'I am in a module'
    

## 7\. 箭头函数的特性

#### 1\. **语法简洁**

  * 箭头函数采用了更简洁的语法，尤其在定义简单的函数时，这种语法显得更为简便。
  * 如果函数体只有一个表达式，甚至可以省略大括号 `{}` 和 `return` 关键字。

    
    
    // 传统函数表达式
    var sum = function(a, b) {
        return a + b;
    };
    
    // 箭头函数
    var sum = (a, b) => a + b;
    

#### 2\. **没有自己的`this` 绑定**

  * 箭头函数不会创建自己的 `this` 上下文，它会捕获（或说“继承”）在定义箭头函数时的外层 `this` 值，即**词法作用域中的`this`**。
  * 这意味着在箭头函数中，`this` 始终指向其外层作用域中的 `this`，而不会根据调用位置的不同而改变。

    
    
    function Person() {
        this.age = 0;
    
        setInterval(() => {
            this.age++; // `this` 指向 `Person` 对象，而不是 `setInterval` 的调用者
            console.log(this.age);
        }, 1000);
    }
    
    var p = new Person();
    

#### 3\. **不能用作构造函数**

  * 箭头函数不能用作构造函数，使用 `new` 关键字调用箭头函数会抛出错误。
  * 传统函数可以通过 `new` 关键字调用创建实例，但箭头函数没有 `[[Construct]]` 内部方法，因此不能用于创建实例。

    
    
    var Foo = () => {};
    var obj = new Foo(); // TypeError: Foo is not a constructor
    

#### 4\. **没有`arguments` 对象**

  * 箭头函数没有自己的 `arguments` 对象，如果需要使用 `arguments` 对象，可以通过外层函数的 `arguments` 对象来访问。
  * 在需要操作参数列表时，通常推荐使用 ES6 的剩余参数语法 `...args`。

    
    
    var func = (...args) => {
        console.log(args); // 使用剩余参数语法替代 `arguments`
    };
    
    func(1, 2, 3); // 输出 [1, 2, 3]
    

#### 5\. **不能使用`yield` 关键字**

  * 箭头函数不能作为生成器函数，因此不能使用 `yield` 关键字。
  * 如果需要生成器功能，必须使用传统的 `function*` 语法。

    
    
    var gen = () => {
        yield 1; // SyntaxError: Unexpected strict mode reserved word
    };
    

