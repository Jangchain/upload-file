## 华为OD面试真题精选

专栏：[华为OD面试真题精选](https://blog.csdn.net/banxia_frontend/category_12436481.html)  
目录:
[2024华为OD面试手撕代码真题目录以及八股文真题目录](https://blog.csdn.net/banxia_frontend/article/details/138131520)

#### 文章目录

  * 华为OD面试真题精选
  * 1\. CSS画椭圆
  * 2\. js会发生阻塞吗
  *     *       *         * 主要阻塞情形：
        * 如何避免阻塞：
  * 3\. 扩展运算符？这种拷贝属于浅拷贝还是深拷贝，扩展运算符为什么算浅拷贝？深拷贝了解吗？
  *     *       *         * 为什么扩展运算符算是浅拷贝？
      * 深拷贝
      *         * 如何实现深拷贝？
  * 4\. setTimeout和setInterval
  *     *       * setTimeout 和 setInterval
      * setTimeout 设置为 0 会发生什么？
      * 为什么会这样？
      * 为什么会有 setTimeout 和 setInterval 这两个API？
  * 5\. 事件循环
  *     *       * 事件循环的工作原理
      * 事件循环的流程
  * 6\. Vue2的虚拟dom
  *     *       * 虚拟 DOM 的基本概念
      * Vue 2 中的虚拟 DOM
      *         * 差异比较算法
        * 更新过程
      * 性能优势
      * 使用虚拟 DOM 的优点
  * 7\. package.json 中的各种 dependencies
  *     *       * 1\. `dependencies`
      * 2\. `devDependencies`
      * 3\. `peerDependencies`
      * 4\. `optionalDependencies`
      * 使用场景总结
  * 8\. 如何处理大量数据？
  *     *       * 1\. 分页和懒加载
      * 2\. 虚拟滚动
      * 3\. 前端数据处理
      * 4\. 数据索引和搜索
      * 5\. 使用高效的数据结构
      * 6\. 减少DOM操作
      * 7\. 缓存策略
  * 9\. package.json中^符号和~符号前缀的区别
  *     *       * `^` 符号（脱字符）
      * `~` 符号（波浪号）
      * 总结
  * 10\. ES6模块化
  *     *       * 1\. 导出（Export）
      *         * 命名导出（Named Exports）
        * 默认导出（Default Exports）
      * 2\. 导入（Import）
      *         * 导入整个模块
        * 导入特定的命名导出
        * 导入默认导出
      * 3\. 动态导入（Dynamic Imports）
      * 4\. 模块的特性

![封面](https://i-blog.csdnimg.cn/blog_migrate/82eb94d80bcaaf02b1fc85510bdbccb5.png)

## 1\. CSS画椭圆

    
    
    .ellipse {
        width: 300px;
        height: 150px;
        background-color: blue;
        border-radius: 50%;
    }
    

## 2\. js会发生阻塞吗

JavaScript是一种单线程语言，意味着在大多数情况下，它在同一时间内只能执行一个任务。由于这个特性，某些操作确实可以造成阻塞，特别是那些耗时的同步任务。

##### 主要阻塞情形：

  1. **长时间运行的同步代码** ：如果JavaScript代码中有长时间运行的同步循环或计算，它会阻塞浏览器的主线程，导致用户界面无法响应用户操作，造成网页卡顿甚至暂时无响应。
  2. **同步API调用** ：例如，使用`alert()`或`prompt()`这类同步API会立即中断代码执行，直到用户响应，期间浏览器无法处理其他任何任务。

##### 如何避免阻塞：

  * **异步编程** ：使用`setTimeout`, `setInterval`, `Promise`, `async/await`等异步编程技术可以帮助避免阻塞。这些技术允许JavaScript启动一个操作，然后在操作完成时通过回调、Promise解决或异步等待来处理结果，而不阻塞代码的其他部分。
  * **Web Workers** ：对于复杂和耗时的任务，可以使用Web Workers。Web Workers允许将一部分JavaScript操作放在后台线程中运行，这个线程是完全独立于主线程的，因此不会影响界面的响应性。

## 3\. 扩展运算符？这种拷贝属于浅拷贝还是深拷贝，扩展运算符为什么算浅拷贝？深拷贝了解吗？

扩展运算符（`...`）在JavaScript中实现的是浅拷贝（shallow
copy）。这意味着当使用扩展运算符复制数组或对象时，它只复制一层属性值。如果被复制的对象中的属性值是基本数据类型（如Number, String,
Boolean），则会复制这些值。然而，如果属性值是引用数据类型（如数组、对象或函数），则复制的是对原数据的引用地址，而非数据本身。

##### 为什么扩展运算符算是浅拷贝？

这是因为当使用扩展运算符复制数据结构（如对象或数组）时，对于数据结构中的每一个引用类型的子元素，扩展运算符仅仅复制其引用，而不是创建一个新的独立对象。这意味着如果原始数据结构中的引用类型的子元素发生变化，那么新复制的数据结构中的相应元素也会发生变化，因为它们指向同一个对象。

#### 深拷贝

深拷贝（deep
copy）在JavaScript中指的是创建一个新对象，其中不仅原始对象的第一层数据被复制，而且所有的嵌套对象也都被递归地复制。这样，新对象与原始对象之间不会共享任何项（包括所有的内部对象），它们是完全独立的。

##### 如何实现深拷贝？

在JavaScript中，实现深拷贝的常见方法包括：

  * 使用`JSON.parse(JSON.stringify(object))`：这种方法通过将对象转换成JSON字符串，然后再将字符串解析回对象，可以实现对象深拷贝。但这种方法有局限性，例如它不能复制函数、undefined、循环引用等。
  * 使用第三方库如Lodash的`_.cloneDeep(object)`：Lodash提供了一个非常有效的深拷贝函数，可以处理各种数据类型和复杂的对象结构。
  * 手动实现递归深拷贝：对于更复杂或特定需求的深拷贝，可以通过递归函数手动实现，以确保所有嵌套对象都被适当复制。

## 4\. setTimeout和setInterval

>
> .setTimeout和setInterval？setTimeout设置0会发生什么？为什么会这样？为什么会有setTimeout和setInterval这两个API

在JavaScript中，`setTimeout`和`setInterval`是两个非常重要的定时器函数，它们允许开发者在代码执行中设置延迟和定期执行任务。这些函数的设计和存在主要是因为JavaScript的单线程特性和非阻塞I/O模型。

#### setTimeout 和 setInterval

**setTimeout:**  
`setTimeout`函数用于在指定的毫秒数后执行一个函数或一段代码。它只执行一次。

**语法示例：**

    
    
    setTimeout(function() {
      console.log("Hello after 3 seconds");
    }, 3000);
    

**setInterval:**  
`setInterval`函数用于每隔指定的毫秒数重复执行指定的函数或执行代码片段，直到`clearInterval()`被调用或窗口被关闭。

**语法示例：**

    
    
    setInterval(function() {
      console.log("Hello every 3 seconds");
    }, 3000);
    

#### setTimeout 设置为 0 会发生什么？

当你为`setTimeout`设置0毫秒时，虽然延迟时间为0，但指定的函数或代码并不会立即执行。JavaScript引擎会将该任务放入事件队列中，在当前执行栈中的所有同步任务完成后，才会执行这个`setTimeout`中的任务。实际上，这为其他正在执行的脚本提供了完成运行的机会，使得UI和其他事件处理程序能够保持响应。

#### 为什么会这样？

这是因为JavaScript是单线程的，使用事件循环来处理任务。即使延迟为0，事件循环也需要先完成所有正在进行的同步执行，然后才能从任务队列中取出下一个任务。这确保了程序的执行顺序是可预测的，并且避免了潜在的竞态条件。

#### 为什么会有 setTimeout 和 setInterval 这两个API？

这些API的设计初衷源于JavaScript的单线程执行模型。JavaScript的主要环境，如浏览器，需要处理大量的用户交互、脚本执行、UI渲染等任务。如果所有这些操作都是同步进行的，那么执行长时间的任务将会阻塞UI，导致糟糕的用户体验。`setTimeout`和`setInterval`允许开发者延迟任务的执行或以固定时间间隔重复执行任务，从而使UI保持响应，同时仍能执行必要的背景计算或处理。这样设计使得JavaScript能够处理复杂的任务，而不会阻塞页面的其余部分，提升了应用的性能和用户体验。

## 5\. 事件循环

JavaScript 的事件循环是其异步编程模型的核心机制，确保了尽管 JavaScript 是单线程的，它仍能执行非阻塞操作。事件循环允许
JavaScript 在执行环境中管理多个任务，通过在事件队列中排队任务，并逐个处理它们来达到这一点。

#### 事件循环的工作原理

  1. **主线程执行堆栈（执行栈）** ：  
JavaScript 的主执行栈是其中运行同步代码的地方。所有的同步任务都在这个栈中按顺序执行。

  2. **任务队列** ：  
当异步事件（如用户交互、定时器触发、网络请求等）发生时，相应的回调函数将被添加到任务队列中。任务队列也被称为消息队列。

  3. **微任务队列** ：  
除了常规的任务队列，还有一个微任务队列，用于处理像 `Promise`
回调这样的微任务。微任务队列的处理速度比常规任务队列更快，且在每次执行栈清空后立即执行。

#### 事件循环的流程

  * 首先，事件循环从执行栈开始，运行其中的所有同步任务。
  * 当执行栈为空时，事件循环检查微任务队列。如果队列中有任务，它们将被连续执行，直到微任务队列为空。
  * 完成所有微任务后，如果主执行栈仍为空，事件循环将移动到任务队列。事件循环从任务队列中取出第一个任务，将其推入执行栈中执行。
  * 每次执行栈清空后，事件循环都会再次检查微任务队列，优先处理这些任务，然后再处理任务队列中的下一个任务。
  * 这个循环持续进行，直到任务队列和微任务队列都为空。

## 6\. Vue2的虚拟dom

Vue.js 是一个流行的前端框架，其使用虚拟 DOM (V-DOM) 技术来优化 DOM 更新，提高应用的性能。在 Vue 2 中，虚拟 DOM
是其响应式系统和渲染机制的核心部分。

#### 虚拟 DOM 的基本概念

虚拟 DOM 是对真实 DOM 的抽象表示。它本质上是一个轻量级的 JavaScript 对象，代表 DOM 树的结构。Vue 使用虚拟 DOM
的主要目的是减少直接操作 DOM 的次数，因为真实的 DOM 操作往往是昂贵的（性能成本高）。

#### Vue 2 中的虚拟 DOM

在 Vue 2 中，每个组件实例都有一个对应的虚拟 DOM 树。这个树反映了组件的结构和当前状态。当组件的数据发生变化时，Vue 会重新生成一个新的虚拟
DOM 树，并与旧树进行比较（称为“差异比较”或“diffing”）。

##### 差异比较算法

Vue 2 使用一种高效的算法来对比新旧虚拟 DOM 树，识别出需要更新的部分。这个过程分为几个步骤：

  1. **节点对比** ：Vue 首先对比新旧虚拟 DOM 树的根节点。如果节点本身相同（例如，标签和key相同），则进行深入比较；如果不同，则直接替换旧节点。

  2. **属性更新** ：如果节点相同，Vue 接着对比节点的属性（如类、样式、监听器等），只更新发生变化的属性。

  3. **子节点对比** ：对子节点进行递归对比。Vue 使用“最小操作原则”，只更新有差异的部分。

##### 更新过程

一旦完成差异比较，Vue 会计算出最小数量的 DOM 操作来应用这些变更。这包括添加、删除和移动 DOM 元素，以反映虚拟 DOM 树的最新状态。

#### 性能优势

通过使用虚拟 DOM，Vue 2 可以极大地减少不必要的 DOM 操作，尤其是在复杂界面和频繁数据更新的场景下。这种更新策略使得 Vue
应用能够保持高效和响应快速，即使是在大规模数据变更时也能保持良好的性能。

#### 使用虚拟 DOM 的优点

  * **性能提升** ：减少实际 DOM 操作，提升渲染效率。
  * **跨平台** ：虚拟 DOM 由纯 JavaScript 对象组成，可以在任何可以运行 JavaScript 的环境中实现，包括服务器端和原生应用。
  * **维护简化** ：通过声明式的数据绑定和组件系统，开发者可以更专注于数据逻辑而非DOM操作细节。

Vue 的虚拟 DOM 系统为开发高性能、响应式的前端应用提供了坚实的基础，同时也简化了开发过程。

## 7\. package.json 中的各种 dependencies

在 `package.json` 文件中，`dependencies`、`devDependencies`、`peerDependencies` 和
`optionalDependencies` 是用来管理 Node.js
项目中依赖包的不同类型。这些字段定义了项目运行和开发所需的外部模块以及它们的版本要求。

#### 1\. `dependencies`

这些是项目运行时必需的依赖。无论是开发还是生产环境，只要项目在运行，这些依赖就是必需的。例如，如果你的应用是一个 Web 服务器，使用了 Express
框架，那么 Express 就应该列在这个部分。

    
    
    "dependencies": {
      "express": "^4.17.1"
    }
    

#### 2\. `devDependencies`

`devDependencies` 列出了仅在开发过程中需要的包，比如测试框架、打包工具和编译器。这些依赖项不会在生产环境中安装。举例来说，如果你使用
Jest 来进行测试，那么 Jest 应该列在这部分。

    
    
    "devDependencies": {
      "jest": "^26.0.1"
    }
    

#### 3\. `peerDependencies`

`peerDependencies`
指定了包与其他包之间的依赖关系，但不会自动安装这些依赖。这常用于插件或扩展包，它们需要主体包的存在才能工作。例如，一个基于 React 的库可能需要声明
React 作为它的 peer 依赖，以确保使用库的项目中已经安装了兼容的 React 版本。

    
    
    "peerDependencies": {
      "react": "^16.0.0"
    }
    

#### 4\. `optionalDependencies`

`optionalDependencies`
是那些即使安装失败也不会影响项目运行的依赖。这对于一些不是必需的功能或在特定平台上可能不可用的依赖很有用。如果安装失败，npm 不会停止整个安装过程。

    
    
    "optionalDependencies": {
      "fsevents": "^1.2.7"
    }
    

#### 使用场景总结

  * **`dependencies`** ：适用于所有需要随应用一起发布的库。
  * **`devDependencies`** ：用于开发过程中的工具，如测试工具、构建工具等。
  * **`peerDependencies`** ：用于插件或需要确保兼容性的扩展库。
  * **`optionalDependencies`** ：适用于那些不关键的依赖，即使安装失败也不会影响应用的主要功能。

## 8\. 如何处理大量数据？

#### 1\. 分页和懒加载

  * **分页** ：将数据分批次加载和显示，每次只向用户展示一小部分数据（如一页显示10条记录），通过分页组件允许用户浏览其他数据。
  * **懒加载（Lazy Loading）** ：只在用户滚动到页面的某部分时才加载该区域的数据，适用于图片、列表等资源。

#### 2\. 虚拟滚动

  * **虚拟滚动** ：仅渲染可视区域内的元素，并在滚动时动态加载和卸载元素。这对于包含数千到数万条数据的长列表特别有效。

#### 3\. 前端数据处理

  * **Web Workers** ：使用 Web Workers 处理复杂计算或数据处理任务，以避免阻塞主线程和影响用户界面的响应性。
  * **防抖和节流** ：对于高频事件（如输入搜索、窗口大小调整等），使用防抖（Debounce）或节流（Throttle）技术来限制事件处理的频率，减少计算需求。

#### 4\. 数据索引和搜索

  * **客户端索引** ：为数据建立索引，以加速搜索和过滤操作，可以使用库如 `lunr.js` 或 `flexsearch`。
  * **服务端搜索** ：对于大数据量，最好的策略是通过 API 在服务器端进行数据处理和搜索，前端只处理展示和用户交互。

#### 5\. 使用高效的数据结构

  * **合适的数据结构** ：使用适合前端操作的数据结构，比如在处理树状数据时使用对象映射或哈希表来加快搜索速度。

#### 6\. 减少DOM操作

  * **使用框架的优势** ：利用现代前端框架如 React、Vue 或 Angular 的虚拟 DOM 来减少直接的 DOM 操作，优化渲染性能。

#### 7\. 缓存策略

  * **客户端缓存** ：使用浏览器的 localStorage 或 IndexedDB 来缓存已加载的数据，减少对服务器的请求。

## 9\. package.json中^符号和~符号前缀的区别

在`package.json`文件中，`^`和`~`是用来控制Node.js项目依赖的版本范围的符号。这些符号帮助npm（Node包管理器）确定在安装依赖时应选择的版本。它们对版本的影响略有不同：

#### `^` 符号（脱字符）

  * **用途** ：当在版本号前加上`^`符号时，它允许npm安装这个版本号指定的主版本（major version）中的最新的次版本（minor version）和补丁版本（patch version）。
  * **例如** ：如果依赖版本是`^1.2.3`，那么npm可以安装从`1.2.3`到`1.999.999`的任何版本，但不会安装`2.0.0`或更高版本，因为这将是下一个主版本。

#### `~` 符号（波浪号）

  * **用途** ：当在版本号前加上`~`符号时，它允许npm安装这个版本号指定的次版本（minor version）中的最新补丁版本（patch version）。
  * **例如** ：如果依赖版本是`~1.2.3`，那么npm可以安装从`1.2.3`到`1.2.999`的任何版本，但不会安装`1.3.0`或更高的版本，因为这将是下一个次版本。

#### 总结

  * `^`符号适用于想要自动接收新功能但不引入主版本更改（可能破坏现有功能）的项目。
  * `~`符号适用于更保守的项目，这些项目只希望自动接收bug修复，而不引入新功能，这些新功能可能带来不稳定性。

## 10\. ES6模块化

ECMAScript 6 (ES6)
引入了一种官方的JavaScript模块化标准，这是对之前广泛使用的CommonJS和AMD规范的一种改进。ES6模块化的主要目标是提高代码的可维护性、重用性和封装性。以下是ES6模块化的一些核心概念：

#### 1\. 导出（Export）

在ES6中，你可以使用`export`关键字导出函数、变量、类等，使它们可以在其他文件中被导入（import）。有两种导出方式：

##### 命名导出（Named Exports）

允许模块导出多个值，每个值都有其对应的名称。导入时需要使用相同的名称。

    
    
    // 文件: lib.js
    export const sqrt = Math.sqrt;
    export function square(x) {
      return x * x;
    }
    export function diag(x, y) {
      return sqrt(square(x) + square(y));
    }
    

##### 默认导出（Default Exports）

每个模块可以有一个默认导出，当导入时不需要知道具体的名称。

    
    
    // 文件: User.js
    export default class User {
      constructor(name, age) {
        this.name = name;
        this.age = age;
      }
    }
    

#### 2\. 导入（Import）

使用`import`关键字可以导入其他模块导出的值。可以根据需要导入整个模块、单个（或多个）命名导出、或默认导出。

##### 导入整个模块

    
    
    // 文件: main.js
    import * as lib from './lib.js';
    console.log(lib.square(11)); // 输出: 121
    console.log(lib.diag(4, 3)); // 输出: 5
    

##### 导入特定的命名导出

    
    
    import { square, diag } from './lib.js';
    console.log(square(11)); // 输出: 121
    console.log(diag(4, 3)); // 输出: 5
    

##### 导入默认导出

    
    
    import User from './User.js';
    const user = new User('John', 30);
    console.log(user.name); // 输出: John
    

#### 3\. 动态导入（Dynamic Imports）

ES6模块也支持动态导入，即在需要时才加载某个模块。这对于按需加载功能、减少启动时间等场景非常有用。

    
    
    async function loadModule() {
      const { diag } = await import('./lib.js');
      console.log(diag(4, 3)); // 输出: 5
    }
    loadModule();
    

#### 4\. 模块的特性

  * **静态结构** ：模块的依赖关系在代码运行前就已确定，允许静态分析工具和JavaScript引擎优化加载和编译。
  * **严格模式** ：ES6模块自动运行在严格模式下，不需要指定`"use strict";`。
  * **文件和模块一一对应** ：每个JS文件被视为一个独立的模块。

