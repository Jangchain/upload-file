# C卷

## 1.山峰题

------

#### 🎃题目描述

> 给一个数组，判断山峰的个数，数组的每个元素的值代表海拔高度，0代表平地，数值越高，海拔越高，山峰的定义为当某个位置左右的海拔低于自己的海拔的时候，这个位置就是山峰，数组的起始和末尾如果符合条件也算山峰

------

#### 🎃输入输出

> 输入
> 一个整数数组
>  
> 输出
> 符合条件的山峰个数

------

#### 🎃样例1

```java
输入
0,1,2,3,2,4

输出
2
12345
```

------

#### 🎃样例2

```java
输入
3,0,3,4,1

输出
2
12345
```

------

### 二、思路参考

------

1. 创建一个变量`peaks`，用于记录山峰的个数，初始值为0。
2. 使用循环遍历数组中的每个元素，循环变量为`i`，取值范围为0到数组长度减1。
3. 在每一次循环中，判断当前元素是否为山峰。判断条件是当前元素大于其前一个元素，并且大于其后一个元素。可以使用逻辑运算符`and`来组合两个条件。
4. 如果当前元素满足山峰条件，将山峰个数`peaks`加1。
5. 循环结束后，返回山峰个数`peaks`作为结果。



~~~java
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String[] input = scanner.nextLine().split(",");
            int[] arr = new int[input.length];
            for (int i = 0; i < input.length; i++) {
                arr[i] = Integer.parseInt(input[i]);
            }
            int result = countPeaks(arr);
            System.out.println(result);
        }
        scanner.close();
    }

    public static int countPeaks(int[] arr) {
        int n = arr.length;
        int peaks = 0;
        for (int i = 0; i < n; i++) {
            // 判断是否为山峰
            if ((i == 0 || arr[i] > arr[i-1]) && (i == n-1 || arr[i] > arr[i+1])) {
                peaks++;
            }
        }
        return peaks;
    }
}
~~~



## 2。密码题

#### 🎃题目描述

> 给定用户密码输入流input，输入流中字符’<'表示退格，可以清除前一个输入的字符，请你编写程序，输出最终得到的密码字符，并判断密码是否满足如下的密码安全要求。
>
> 密码安全要求如下：
>
> 1、密码长度>=8；
>
> 2、密码至少需要包含1个大写字母；
>
> 3、密码至少需要包含1个小写字母；
>
> 4、密码至少需要包含1个数字；
>
> 5、密码至少需要包含1个字母和数字以外的非空白特殊字符；
>
> 注意空串退格后仍然为空串，且用户输入的字符串不包含 ‘<’ 字符和空白字符；

------

#### 🎃输入输出

> 输入
> 用一行字符串表示输入的用户数据，输入的字符串中 ‘<’ 字符标识退格，用户输入的字符串不包含空白字符，例如：ABC<c89%000<
>  
> 输出
> 输出经过程序处理后，输出的实际密码字符串，并输出改密码字符串是否满足密码安全要求。两者间由’，'分隔， 例如：ABc89%00,true

------

#### 🎃样例1

```java
输入
ABC<c89%000<


输出
ABc89%00,true

说明:多余的C和0由于退格被去除,最终用户输入的密码为ABc89%00，且满足密码安全要求，输出true
12345678
```

------

### 二、思路参考

------

1、首先，定义了一个`isValidPassword`方法来判断密码的安全性。在该方法中，通过遍历密码的每个字符，判断是否包含大写字母、小写字母、数字和特殊字符，并记录下来。同时，还要判断密码的长度是否大于等于8。如果所有条件都满足，则返回`true`，表示密码是安全的；否则返回`false`，表示密码不安全。

2、接下来，定义了一个`processInput`方法来处理输入的数据。该方法接收一个字符串作为输入，并将其转换为一个字符列表。然后，遍历字符列表中的每个字符，如果遇到退格符号`<`，则移除列表中的最后一个字符；否则，将字符添加到列表中。接着，将字符列表转换为字符串，并调用`isValidPassword`方法来判断最终的密码是否满足安全要求。最后，将最终的密码和安全性的判断结果以字符串的形式返回。

~~~java
import java.util.*;

public class Main {
    
    public static boolean isValidPassword(String password) {
        boolean hasUpper = false;  // 是否包含大写字母
        boolean hasLower = false;  // 是否包含小写字母
        boolean hasDigit = false;  // 是否包含数字
        boolean hasSpecial = false;  // 是否包含特殊字符
        
        for (char c : password.toCharArray()) {
            if (Character.isUpperCase(c)) {
                hasUpper = true;
            } else if (Character.isLowerCase(c)) {
                hasLower = true;
            } else if (Character.isDigit(c)) {
                hasDigit = true;
            } else {
                hasSpecial = true;
            }
        }
        
        int length = password.length();
        return hasUpper && hasLower && hasDigit && hasSpecial && length >= 8;
    }
    
    public static String processInput(String input) {
        List<Character> password = new ArrayList<>();  // 用于构建最终密码的字符列表
        
        for (char c : input.toCharArray()) {
            if (c == '<') {
                if (!password.isEmpty()) {
                    password.remove(password.size() - 1);  // 移除最后一个字符
                }
            } else {
                password.add(c);  // 添加字符到密码列表中
            }
        }
        
        StringBuilder finalPassword = new StringBuilder();
        for (char c : password) {
            finalPassword.append(c);  // 将字符转换为字符串并添加到最终密码中
        }
        
        boolean valid = isValidPassword(finalPassword.toString());  // 检查密码是否满足安全要求
        return finalPassword.toString() + "," + String.valueOf(valid).toLowerCase();  // 返回最终的密码和是否满足要求
    }
    
    public static void main(String[] args) {
        String input = "ABC<c89%000<";  // 输入数据
        String output = processInput(input);  // 处理输入数据
        System.out.println(output);  // 输出结果
    }
}
~~~



## 3.最长子字符串的长度

#### 🎃题目描述

> 给你一个字符串s，首位相连成一个环形，在环中找出 “o” 字符出现了偶数次最长子字符串的长度

------

#### 🎃输入输出

> 输入
> 输入小写字母组成的字符串
> 输出
> 一个整数

------

#### 🎃样例1

```java
输入
alolobo

输出
6
12345
```

------

#### 🎃样例2

```java
输入
looxdolx

输出
7
12345
```

------

#### 🎃样例3

```java
输入
bcbcbc

输出
6
12345
```

------

### 二、思路参考

------

1. 从标准输入读取一行字符串。
2. 使用 `count` 变量记录字符串中字符 ‘o’ 的数量。
3. 如果 `count` 是偶数，则输出字符串的长度；否则，输出字符串的长度减去 1。



~~~java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();

        // 计算字符串中字符'o'的数量
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == 'o') {
                count++;
            }
        }

        // 判断count是否为偶数，根据结果输出对应的长度
        if (count % 2 == 0) {
            System.out.println(s.length());
        } else {
            System.out.println(s.length() - 1);
        }
    }
}
~~~



## 4.寿司转盘问题

#### 🎃题目描述

> 寿司店周年庆，正在举办优惠活动回馈新老客户。
>  
> 寿司转盘上总共有n盘寿司，prices[i] 是第 i 盘寿司的价格，如果客户选择了第i盘寿司，寿司店免费赠送客户距离 第 i 盘 寿司最近的下一盘寿司 j ，前提是prices[ j ] < prices[ i ]，如果没有满足条件的 j，则不赠送寿司
>  
> 每个价格的寿司都可无限供应

------

#### 🎃输入输出

> 输入
> 输入的每一个数字代表每盘寿司的价格，每盘寿司的价格之间使用空格分隔
>  
> 寿司的盘数n范围为：1 <= n <= 500
> 每盘寿司的价格price范围为：1 <= price <= 1000
>  
> 输出
> 输出享受优惠后的一组数据，每个值表示客户选择第i盘寿司时实际得到的寿司的总价格

------

#### 🎃样例1

```java
输入
3 15 6 14 

输出
3 21 9 17


说明
- 第1盘寿司的价格是3，没有比它价格更低的寿司，所以总价格就是它自己的价格，即3
- 第2盘寿司的价格是15，离它最近的价格更低的寿司是第3盘（价格6），所以总价格是15+6=21
- 第3盘寿司的价格是6，离它最近的价格更低的寿司是第1盘（价格3），所以总价格是6+3=9
- 第4盘寿司的价格是14，离它最近的价格更低的寿司是第1盘（价格3），所以总价格就是14+3=17

12345678910111213
```

------

#### 🎃样例2

```java
输入
3 10 5 7

输出
3 15 8 10
12345
```

------

### 二、思路参考

------

1. 创建一个名为 `findNextCheaper` 的方法，接受两个参数：`prices` 数组和当前位置 `i`。

2. 获取 `prices` 数组的长度，并将其保存在变量 `n` 中。

3. 使用一个循环从 1 到 `n-1`，作为向前和向后搜索的距离 `d`。

4. 在循环中，首先使用取余运算计算向后搜索的位置 `j`，即 `(i + d) % n`。

5. 判断 `prices[j]` 是否小于 `prices[i]`，如果是，则返回 `prices[j]`，表示找到了更便宜的寿司。

6. 如果向后搜索没有找到更便宜的寿司，使用取余运算和加法计算向前搜索的位置 `j`，即 `(i - d + n) % n`。

7. 再次判断 `prices[j]` 是否小于 `prices[i]`，如果是，则返回 `prices[j]`。

8. 如果循环结束后仍然没有找到更便宜的寿司，返回 0，表示不赠送。

9. 创建一个名为 `calculateTotalPrices` 的方法，接受一个参数 `prices` 数组。

10. 创建一个空的整型数组 `totalPrices`，用于存储每盘寿司的总价格。

11. 使用一个循环遍历

     

    ```
    prices
    ```

     

    数组的每个元素，并在每次循环中执行以下操作：

    - 调用 `findNextCheaper` 方法，传入 `prices` 数组和当前位置 `i`，获取更便宜的寿司价格，并将其保存在变量 `freeSushiPrice` 中。
    - 计算当前盘寿司的总价格，即 `prices[i] + freeSushiPrice`，将结果保存在 `totalPrice` 中。
    - 将 `totalPrice` 添加到 `totalPrices` 数组中。

12. 返回 `totalPrices` 数组作为结果。

13. 在 `main` 方法中，读取输入并将其存储在 `prices` 数组中。

14. 调用 `calculateTotalPrices` 方法，传入 `prices` 数组，并将结果保存在 `result` 数组中。

15. 使用循环遍历 `result` 数组的每个元素，并使用 `System.out.print` 输出结果，元素之间用空格分隔。

~~~java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // 读取输入
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        String[] inputPrices = input.split(" ");
        int[] prices = new int[inputPrices.length];
        for (int i = 0; i < inputPrices.length; i++) {
            prices[i] = Integer.parseInt(inputPrices[i]);
        }

        // 计算并输出结果
        int[] result = calculateTotalPrices(prices);
        for (int i = 0; i < result.length; i++) {
            System.out.print(result[i]);
            if (i < result.length - 1) {
                System.out.print(" ");
            }
        }
    }

    public static int[] calculateTotalPrices(int[] prices) {
        int[] totalPrices = new int[prices.length];
        for (int i = 0; i < prices.length; i++) {
            // 计算第i盘寿司的总价格
            int freeSushiPrice = findNextCheaper(prices, i);
            int totalPrice = prices[i] + freeSushiPrice;
            totalPrices[i] = totalPrice;
        }
        return totalPrices;
    }

    public static int findNextCheaper(int[] prices, int i) {
        int n = prices.length;
        // 从当前位置向前和向后搜索最近的更便宜的寿司
        for (int d = 1; d < n; d++) {
            // 向后查找
            int j = (i + d) % n;
            if (prices[j] < prices[i]) {
                return prices[j];
            }
            // 向前查找
            j = (i - d + n) % n;
            if (prices[j] < prices[i]) {
                return prices[j];
            }
        }
        // 如果没有找到，返回0，表示不赠送
        return 0;
    }
}
~~~



## 5.机器人搬砖

#### 🎃题目描述

> 机器人搬砖，一共有N堆砖存放在N个不同的仓库中，第 i 堆砖中有bricks[i]块砖头， 要求在8小时内搬完。机器人每小时能搬砖的数量取决于有多少能量格，机器人一个小时中只能在一个仓库中搬砖，机器人的能量格每小时补充一次且能量格只在这一个小时有效，为使得机器人损耗最小化尽量减小每次补充的能量格数为了保障在8小时内能完成搬砖任务，请计算每小时给机器人充能的最小能量格数
>  
> 说明：
> 1、无需考虑机器人补充能量格的耗时
> 2、无需考虑机器人搬砖的耗时
> 3、机器人每小时补充能量格只在这一个小时中有效

------

#### 🎃输入输出

> 输入
> 第一行为一行数字，空格分隔
>  
> 输出
> 机器人每小时最少需要充的能量格，若无法完成任务，输出-1

------

#### 🎃样例1

```java
输入
30 12 25 8 19

输出
15
12345
```

------

#### 🎃样例2

```java
输入
10 12 25 8 19 8 6 4 17 19 20 30

输出
-1
12345
```

------

### 二、思路参考

------

1、首先，我们定义了`canComplete`方法用于检查给定的能量是否足以让机器人在规定时间内搬运所有砖块。在这个方法中，我们使用了天花板除法`-(-brick // energy)`来计算每堆砖块需要的小时数。然后，我们将每堆砖块需要的小时数累加到`totalHours`中，并与规定的时间进行比较，如果总小时数小于等于规定时间，则返回`true`，否则返回`false`。

2、接下来，我们定义了`findMinEnergy`方法用于找到机器人搬运所有砖块所需的最小能量值。在这个方法中，我们首先计算了所有砖块的总和`totalBricks`。然后，我们从能量值1开始逐一尝试每个能量值，调用`canComplete`方法判断当前能量值是否有效，如果有效则返回当前能量值作为最小有效能量值。如果找不到有效的能量值，返回-1。

3、在主函数中，我们首先读取输入的砖块堆数量并转换为整数列表。然后，调用`findMinEnergy`方法找到最小能量值并打印结果。



~~~java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取砖块堆数量
        System.out.println("请输入砖块堆的数量，使用空格分隔：");
        String bricksInput = scanner.nextLine();

        // 将输入的砖块堆数量字符串转换为整数列表
        String[] bricksStr = bricksInput.split(" ");
        int[] bricks = new int[bricksStr.length];
        for (int i = 0; i < bricksStr.length; i++) {
            bricks[i] = Integer.parseInt(bricksStr[i]);
        }

        int hours = 8; // 规定的时间（小时）

        // 调用方法找到机器人搬运所有砖块所需的最小能量值
        int minEnergy = findMinEnergy(bricks, hours);

        // 打印结果
        System.out.println(minEnergy);

        scanner.close();
    }

    private static boolean canComplete(int[] bricks, int energy, int hours) {
        int totalHours = 0; // 总共需要的小时数
        for (int brick : bricks) {
            totalHours += (int) Math.ceil((double) brick / energy); // 使用天花板除法计算每堆砖块需要的小时数
        }
        return totalHours <= hours; // 如果总小时数小于等于规定时间，则返回true
    }

    private static int findMinEnergy(int[] bricks, int hours) {
        int totalBricks = 0; // 所有砖块的总和
        for (int brick : bricks) {
            totalBricks += brick;
        }

        for (int energy = 1; energy <= totalBricks; energy++) { // 从1开始逐一尝试每个能量值
            if (canComplete(bricks, energy, hours)) { // 如果当前能量值有效
                return energy; // 返回当前的能量值作为最小有效能量值
            }
        }

        return -1; // 如果找不到有效的能量值，返回-1
    }
}
~~~



## 6.小明找位置

#### 🎃题目描述

> 小朋友出操，按学号从小到大排成一列；小明来迟了，请你给小明出个主意，让他尽快找到他应该排的位置。

------

#### 🎃输入输出

> 输入
> 第一行：输入已排成队列的小朋友的学号（正整数），以 “，” 隔开；
> 第二行：小明学号
>  
> 输出
> 输出一个数字，代表队列位置（从1开始）

------

#### 🎃样例1

```java
输入
93 95 97 100 102 123 155
110

输出
6
123456
```

------

### 二、思路参考

------

首先，在主函数中读取输入的数字字符串和小明的位置。然后，调用`findPosition`方法找到小明的位置。在`findPosition`方法中，我们首先将输入的字符串转换为整数列表。然后，使用二分查找的方式寻找小明的位置。我们使用两个指针`left`和`right`来表示查找的范围，初始时，`left`指向0，`right`指向数字列表的长度。在每次迭代中，计算中间位置`mid`，然后判断中间位置对应的数字是否小于小明的位置，如果是，则将`left`指向`mid+1`，否则将`right`指向`mid`。最终，当`left`与`right`相等时，指向的位置即为小明的位置。由于题目要求的位置从1开始计数，所以最后返回`left+1`。



~~~java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取输入的数字字符串
        String numbers = scanner.nextLine();
        // 读取小明的位置
        int xiaoming = Integer.parseInt(scanner.nextLine());

        // 调用方法找到小明的位置
        int position = findPosition(numbers, xiaoming);

        // 输出结果
        System.out.println(position);

        scanner.close();
    }

    private static int findPosition(String numbers, int xiaoming) {
        // 将输入的字符串转换为整数列表
        String[] numberStrs = numbers.split(" ");
        int[] numberList = new int[numberStrs.length];
        for (int i = 0; i < numberStrs.length; i++) {
            numberList[i] = Integer.parseInt(numberStrs[i]);
        }

        // 用二分查找的方式寻找小明的位置
        int left = 0;
        int right = numberList.length;
        while (left < right) {
            int mid = (left + right) / 2;
            if (numberList[mid] < xiaoming) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left + 1;
    }
}

~~~



## 7.最多购买宝石数目

#### 🎃题目描述

> 橱窗里有一排宝石，不同的宝石对应不同的价格，宝石的价格标记为gems[i]，0<=i<n，n = gems.length， 宝石可同时出售0个或多个，如果同时出售多个，则要求出售的宝石编号连续；
>  
> 例如客户最大购买宝石个数为m，购买的宝石编号必须为gems[i]，gems[i+1]…gems [i+m-1] (0<=i<n，m<=n)
> 假设你当前拥有总面值为value的钱，请问最多能购买到多少个宝石,如无法购买宝石，则返回0

------

#### 🎃输入输出

> 输入
> 第一行输入n，参数类型为int，取值范围：[0,10的6次方]，表示橱窗中宝石的总数量
>  
> 之后n行分别表示从第0个到第n-1个宝石的价格，即gems[0]到gems[n-1]的价格
>  
> 之后一行输入v，表示你拥有的钱。
>  
> 输出
>  
> 输出表示最大可购买的宝石数量。

------

#### 🎃样例1

```java
输入
7
8
4
6
3
1
6
7
10

输出
3

说明
gems = [8,4,6,3,1,6,7], value = 10
最多购买的宝石为gems[2]至gems[4]或者gems[3]至gems[5]
1234567891011121314151617
```

------

#### 🎃样例2

```java
输入
0
1

输出
0
123456
```

------

#### 🎃样例3

```java
输入
9
6
1
3
1
8
9
3
2
4
15

输出
4
123456789101112131415
```

------

#### 🎃样例4

```java
输入
9
1
1
1
1
1
1
1
1
1
10

输出
9
123456789101112131415
```

------

### 二、思路参考

------

首先，在主函数中读取输入的宝石数量、宝石列表和钱的面值。然后，调用`maxGems`方法找到最大可购买的宝石数量。在`maxGems`方法中，我们使用两个指针`left`和`right`来表示窗口的左边界和右边界，初始时，`left`和`right`都指向0。我们还定义了一个变量`total`来记录当前窗口内的宝石总价值，初始时，`total`为0。我们还定义了一个变量`maxGemsCount`来记录最大可购买的宝石数量，初始时，`maxGemsCount`为0。然后，我们使用一个循环遍历宝石列表中的每个宝石。在每次迭代中，我们将当前宝石的价值加到`total`上，并检查`total`是否超过了给定的面值。如果超过了，我们需要移动窗口的左边界来减小`total`。我们通过一个循环来移动左边界，直到`total`小于等于给定的面值。在每次移动左边界时，我们从`total`中减去左边界对应的宝石的价值，并将左边界向右移动一位。最后，我们计算当前窗口内的宝石数量，并更新`maxGemsCount`为当前窗口内宝石数量和`maxGemsCount`的较大值。最终，当遍历完所有宝石后，`maxGemsCount`即为最大可购买的宝石数量。

~~~java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取输入
        int n = Integer.parseInt(scanner.nextLine());
        int[] gems = new int[n];
        for (int i = 0; i < n; i++) {
            gems[i] = Integer.parseInt(scanner.nextLine());
        }
        int value = Integer.parseInt(scanner.nextLine());

        // 调用方法并输出结果
        int maxGems = maxGems(gems, value);
        System.out.println(maxGems);

        scanner.close();
    }

    private static int maxGems(int[] gems, int value) {
        int left = 0; // 窗口的左边界
        int total = 0; // 当前窗口内宝石的总价值
        int maxGemsCount = 0; // 最大可购买的宝石数量
        for (int right = 0; right < gems.length; right++) {
            total += gems[right]; // 将当前宝石的价值加到总价值上
            while (total > value) {
                total -= gems[left]; // 移动左边界，减去左边界宝石的价值
                left++; // 左边界向右移动一位
            }
            maxGemsCount = Math.max(maxGemsCount, right - left + 1); // 更新最大可购买的宝石数量
        }
        return maxGemsCount;
    }
}

~~~



## 8.寻找最富裕的小家庭

#### 🎃题目描述

> 在一棵树中，每个节点代表一个家庭成员，节点的数字表示其个人的财富值，一个节点及其直接相连的子节点被定义为一个小家庭
>  
> 现给你一棵树，请计算出最富裕的小家庭的财富和

------

#### 🎃输入输出

> 输入
> 第一行为一个数N，表示成员总数，成员编号1-N，1<=N<=1000
> 第二行为N个空格分隔的数，表示编号1-N的成员的财富值。0<=财富值<= 1000000
>  
> 接下来N-1行，每行两个空格分隔的整数(N1 N2)，表示N1是N2的父节点
>  
> 输出
> 最富裕的小家庭的财富和

------

#### 🎃样例1

```java
输入
4
100 200 300 500
1 2
1 3
2 4


输出
700

说明：
成员1,2, 3组成的小家庭财富值为600
成员2,4组成的小家庭财富值为700
1234567891011121314
```

------

#### 🎃样例2

```java
输入
4
100 200 300 500
1 2
1 3
1 4


输出
1100

说明：
成员1,2,3,4组成的小家庭财富值为1100
12345678910111213
```

------

### 二、思路参考

------

1、首先从输入中读取成员总数N，并初始化一个大小为N+1的数组wealth来存储每个成员的财富值。数组的索引表示成员编号，对应的值表示该成员的财富值。

2、接下来从输入中读取N个空格分隔的数，表示每个成员的财富值，并将其存储到wealth数组中。

3、构建树结构，使用一个HashMap来存储节点及其子节点的列表。对于每个成员，从输入中读取其父节点和子节点，然后将子节点添加到父节点的子节点列表中。如果父节点不在HashMap中，则先初始化其子节点列表。

4、接下来，使用一个循环遍历每个节点。对于每个节点，调用calculateWealth方法来计算该节点及其子节点的财富总和。

5、在calculateWealth方法中，首先初始化familyWealth为当前节点的财富值。然后判断当前节点是否有子节点，如果有，则通过遍历子节点的方式计算其财富总和，并累加到familyWealth中。

6、最后，在每次计算财富总和时，使用Math.max函数来更新最大财富值。

7、最后，输出最富裕的小家庭的财富和。

~~~java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

public class Main {
    // 读取成员总数
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取成员总数 N
        int N = Integer.parseInt(scanner.nextLine().trim());

        // 读取成员财富值，使用数组来存储财富值，其中index 0的位置不使用
        int[] wealth = new int[N + 1];
        String[] wealthInput = scanner.nextLine().trim().split(" ");
        for (int i = 1; i <= N; i++) {
            wealth[i] = Integer.parseInt(wealthInput[i - 1]);
        }

        // 构建树结构，使用HashMap存储节点及其子节点的列表
        Map<Integer, List<Integer>> tree = new HashMap<>();
        for (int i = 0; i < N - 1; i++) {
            String[] parentChildPair = scanner.nextLine().trim().split(" ");
            int parent = Integer.parseInt(parentChildPair[0]);
            int child = Integer.parseInt(parentChildPair[1]);

            // 如果parent不在map中，先初始化其子节点列表
            if (!tree.containsKey(parent)) {
                tree.put(parent, new ArrayList<>());
            }
            // 将child添加到parent的子节点列表中
            tree.get(parent).add(child);
        }

        // 查找最富裕的小家庭的财富和
        int maxWealth = 0;
        for (int node = 1; node <= N; node++) {
            maxWealth = Math.max(maxWealth, calculateWealth(node, wealth, tree));
        }

        // 输出结果
        System.out.println(maxWealth);
    }

    // 计算每个节点及其子节点的财富总和
    private static int calculateWealth(int node, int[] wealth, Map<Integer, List<Integer>> tree) {
        int familyWealth = wealth[node];
        // 如果当前节点有子节点，则递归地计算子节点的财富值
        if (tree.containsKey(node)) {
            for (int child : tree.get(node)) {
                familyWealth += wealth[child];
            }
        }
        return familyWealth;
    }
}
~~~



## 9.园区参观路径

#### 🎃题目描述

> 园区某部门举办了Family Day，邀请员工及其家属参加；将公司园区视为一个矩形，起始园区设置在左上角，终园区设置在右下角；家属
> 参观园区时，只能向右和向下园区前进，求从起始园区到终园区会有多少条不同的参观路径：
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/842df60c43f5471ea0b49c43837cec78.png)

------

#### 🎃输入输出

> 输入
> 第一行为园区长和宽；后面每一行表示该园区是否可以参观，0表示可以参观，1表示不能参观
>  
> 输出
> 输出为不同的路径数量

------

#### 🎃样例1

```java
3 3
0 0 0
0 1 0
0 0 0


输出
2
12345678
```

------

### 二、思路参考

------

1、首先，通过Scanner类读取输入并解析数据，获取园区的行数和列数，以及园区的布局。

2、然后，初始化一个二维数组dp，dp[i][j]表示从起始点到(i, j)的路径数量。设定起始点(0, 0)的路径数为1，如果起始点是可参观的(即grid[0][0]为0)，则dp[0][0]为1，否则为0。

3、接下来，填充第一行和第一列的路径数。对于第一行，如果当前位置可参观(即grid[i][0]为0)，则路径数等于上一个位置的路径数，即dp[i][0] = dp[i-1][0]；否则路径数为0。对于第一列，同理。

4、最后，使用动态规划的思想填充其他单元格的路径数。对于每个位置(i, j)，如果当前位置可参观(即grid[i][j]为0)，则路径数等于上方位置的路径数加上左方位置的路径数，即dp[i][j] = dp[i-1][j] + dp[i][j-1]；否则路径数为0。

5、最终，返回dp[rows-1][cols-1]，即从起始园区到终园区的路径数量。

~~~java
import java.util.Scanner;

public class Main {
    public static int countPaths(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;

        // 初始化dp数组，设定起始点的路径数为1
        int[][] dp = new int[rows][cols];
        dp[0][0] = grid[0][0] == 0 ? 1 : 0;

        // 填充第一行和第一列
        for (int i = 1; i < rows; i++) {
            dp[i][0] = grid[i][0] == 0 ? dp[i-1][0] : 0;
        }
        for (int j = 1; j < cols; j++) {
            dp[0][j] = grid[0][j] == 0 ? dp[0][j-1] : 0;
        }

        // 动态规划填充其他单元格
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                if (grid[i][j] == 0) {
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                } else {
                    dp[i][j] = 0;
                }
            }
        }

        return dp[rows-1][cols-1];
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取输入并且解析数据
        String firstLine = scanner.nextLine().trim();
        int rows = Integer.parseInt(firstLine.split(" ")[0]);
        int cols = Integer.parseInt(firstLine.split(" ")[1]);

        // 创建园区的grid，0表示可参观，1表示不可参观
        int[][] grid = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            String line = scanner.nextLine().trim();
            String[] nums = line.split(" ");
            for (int j = 0; j < cols; j++) {
                grid[i][j] = Integer.parseInt(nums[j]);
            }
        }

        // 计算并输出路径数量
        System.out.println(countPaths(grid));

        scanner.close();
    }
}
~~~



## 10. 分割均衡字符串

#### 🎃题目描述

> 均衡串定义：字符串只包含两种字符，且两种字符的个数相同
>  
> 给定一个均衡字符串，请给出可分割成新的均衡子串的最大个数
>  
> 约定字符串中只包含大写的X和Y两种字符

------

#### 🎃输入输出

> 输入
> 给定的字符串均为均衡串
>  
> 输出
> 可分割为两个子串最大个数

------

#### 🎃样例1

```java
输入
XXYYXY

输出
2

说明：
可以分割两个子串：
XXYY
XY
分割后的子串，是原字符串的连续子串
1234567891011
```

------

### 二、思路参考

------

1. 初始化count_X为0，count_Y为0，balancedSubstrings为0，用来分别统计字符’X’的数量、字符’Y’的数量和平衡子串的数量。
2. 遍历字符串s的每个字符：
   - 如果字符是’X’，则count_X加1。
   - 如果字符是’Y’，则count_Y加1。
3. 在遍历过程中，每次count_X和count_Y相等时，说明找到了一个平衡子串：
   - 平衡子串数量balancedSubstrings加1。
   - 将count_X和count_Y重置为0，为下一个平衡子串做准备。
4. 遍历完整个字符串后，返回平衡子串的数量balancedSubstrings。
5. 在主函数main中，定义一个示例字符串s，并调用maxNumberOfBalancedSubstrings方法计算平衡子串的数量。

~~~java
public class Main{
    public static int maxNumberOfBalancedSubstrings(String s) {
        int count_X = 0; // 统计X的数量
        int count_Y = 0; // 统计Y的数量
        int balancedSubstrings = 0; // 统计平衡子串的数量

        for (char c : s.toCharArray()) { // 遍历字符串的每个字符
            if (c == 'X') {
                count_X++; // 如果字符是X，X的数量加1
            } else {
                count_Y++; // 如果字符是Y，Y的数量加1
            }

            if (count_X == count_Y) { // 如果X和Y的数量相等，说明找到了一个平衡子串
                balancedSubstrings++; // 平衡子串数量加1
                count_X = 0; // 重置X的数量
                count_Y = 0; // 重置Y的数量
            }
        }

        return balancedSubstrings; // 返回平衡子串的数量
    }

    public static void main(String[] args) {
        String s = "XXYYXY";
        System.out.println(maxNumberOfBalancedSubstrings(s));
    }
}
~~~



## 11. 游戏分组

#### 🎃题目描述

> 部门准备举勒一场王者荣耀表演赛，有10名游戏爱好者参与，分别为两队，每队5人。每位参与者都有一个评分， 代表着他的游戏水
> 平。为了表演赛尽可能精彩，我们需要把10名参赛者分为实力尽量相近的两队，一队的实可以表示为这一队5名队员的评分总和
>  
> 现在给你10名参与者的游戏水平评分，请你根据上述要求分队最后输出这两组的实力差绝对值

------

#### 🎃输入输出

> 输入
> 10个整数，表示10名参与者的游戏水平评分
>  
> 输出
> 1个整数，表示分组后两组实力差绝对值的最小值

------

#### 🎃样例1

```java
输入
1 2 3 4 5 6 7 8 9 10

输出
1
12345
```

------

### 二、思路参考

------

1、首先，将所有玩家的评分总和计算出来，记为totalSum。

2、然后，目标是将评分分成两个子集，使得这两个子集的评分总和尽可能接近totalSum的一半。

3、定义dp数组，dp[i][j]表示前i个玩家的评分中，是否存在一个子集，使得评分总和等于j。

4、接下来使用动态规划的思路进行填表：

- 初始化dp[0][0]为true，表示前0个玩家的评分中存在一个空子集，使得评分总和为0。
- 对于dp[i][j]，如果j小于等于scores[i-1]，则dp[i][j]的值与dp[i-1][j]相同，表示当前玩家的评分太大无法加入子集，保持前i-1个玩家的评分总和不变。
- 如果j大于等于scores[i-1]，则可以选择将当前玩家的评分加入子集，此时需要判断dp[i-1][j-scores[i-1]]是否为true，表示前i-1个玩家的评分中存在一个子集，使得评分总和为j-scores[i-1]。如果存在，将dp[i][j]设置为true，表示当前玩家的评分可以加入子集，使得评分总和为j。
- 在填表过程中，如果dp[i][halfSum]为true，表示前i个玩家的评分中存在一个子集，使得评分总和等于halfSum，即totalSum的一半。因此，dp[scores.length][halfSum]给出了最接近总和一半的评分总和。

5、最后，根据总评分和totalSum和最接近总和一半的评分总和closestHalfSum，计算出实力差的绝对值minDiff = totalSum - 2 * closestHalfSum，即评分的最小差异。



~~~java
import java.util.Scanner;

public class Main {

    public static int minDifference(int[] scores) {
        int totalSum = 0;
        for (int score : scores) {
            totalSum += score;
        }

        int halfSum = totalSum / 2;
        int[][] dp = new int[scores.length + 1][halfSum + 1];

        // 动态规划填表过程
        for (int i = 1; i <= scores.length; i++) {
            for (int j = 1; j <= halfSum; j++) {
                if (scores[i - 1] <= j) {
                    // 如果当前玩家的评分可以加入子集
                    // 取前i-1个玩家达到j的最大值 或 加入第i个玩家后的新总和
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - scores[i - 1]] + scores[i - 1]);
                } else {
                    // 如果当前玩家的评分太大，不能加入子集，就保留前i-1个玩家的值
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        // dp表的最后一行给出了最接近总和一半的评分总和
        int closestHalfSum = dp[scores.length][halfSum];
        // 计算实力差的绝对值
        int minDiff = totalSum - 2 * closestHalfSum;
        return minDiff;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] scores = new int[10];
        for (int i = 0; i < 10; i++) {
            scores[i] = scanner.nextInt();
        }

        System.out.println(minDifference(scores));
    }
}
~~~



## 12.开源项目热度榜单

#### 🎃题目描述

> 某个开源社区希望将最近热度比较高的开源项目出一个榜单，推荐给社区里面的开发者，对于每个开源项目，开发者可以进行关注(watch)、收藏(star)、 fork、 提issue、 提交合并请求(MR)等
>  
> 数据库里面统计了每个开源项目关注、收藏、fork、 issue、 MR的数量，开源项目的热度根据这5个维度的加权求和进行排序
>  
> 公式：H= (Wwatch * #watch) + (Wstar * #star) + (Wfork * #fork) + (Wissue * #issue) + (Wmr * #mr)
> H表示热度值
>  
> Wwatch、Wstar、 Wfork、 Wissue、 Wmr分别表示5个统计维度的权重
>  
> \#watch、#star、 #fork、 #issue、 #mr分别表示5个统计维度的统计值
>  
> 榜单按照热度值降序排序，对于热度值相等的，按照项目名字转换为全小写字母后的字典序排序(a，b，c，…，x，y，z)

------

#### 🎃输入输出

> 输入
>  
> 第一行输入为N，开源项目的个数，0 < N < 100
>  
> 第二行输入为权重值列表，一共5个整型值，分别对应关注、收藏、fork、 issue、 MR的权重，权重取值 0 < W≤50
>  
> 第三开始接下来的N行为开源项目的统计维度，每行的格式为：name nr_watch nr_start nr_fork nr_issue nr_mr
>  
> 其中name为开源项目的名字，由英文字母组成，长度≤50，其中5个整型值分别为该开源项目关注、收藏、fork、 issue、 MR的数量，数量取值0 <nr≤1000
>  
> 输出描
> 按照热度降序，输出开源项目的名字,对于热度值相等的,按照项目名字转换为全小写后的字典序排序(a，b，c，…，x，y，z)

------

#### 🎃样例1

```java
输入
4
8 6 2 8 6
camila 66 70 46 158 80
victoria 94 76 86 189 211
anthony 29 17 83 21 48
emily 53 97 1 19 218


输出
victoria
camila
emily
anthony


说明：
排序热度值计算:
camila: 66*8+ 70*6 + 46*2 + 158*8 + 80*6 = 2784
victoria: 94*8+ 76*6+ 86*2 + 189*8 + 211*6= 4158
anthony: 29*8+ 17*6+ 83*2 + 21*8 + 48*6= 956
emily: 53*8+97*6+ 1*2 + 19*8 + 218*6 = 2468
12345678910111213141516171819202122
```

------

#### 🎃样例2

```java
输入
5
5 6 6 1 2
camila 13 88 46 26 169
grace 64 38 87 23 103
lucas 91 79 98 154 79
leo 29 27 36 43 178
ava 29 27 36 43 178



输出
lucas
grace
camila
ava
leo



说明：
排序热度值计算:
camila: 13*5+ 88*6 + 46*6+ 26*1 + 169*2= 1233
grace: 64*5+ 38*6 + 87*6+ 23*1 + 103*2= 1299
lucas: 91*5+ 79*6+ 98*6+ 154*1 + 79*2= 1829
leo: 29*5+ 27*6+ 36*6+ 43*1 + 178*2= 922
ava 29*5+ 27*6+ 36*6+ 43*1 + 178*2= 922 
123456789101112131415161718192021222324252627
```

------

### 二、思路参考

------

1. 首先读取项目的个数 `N` 和权重值，将权重值存入一个数组 `weights` 中。
2. 创建一个 `Project` 类，用来存储每个项目的名字和根据公式计算出的热度值。
3. 使用一个列表 `projects` 来存储所有的项目对象。
4. 逐个读取每个项目的数据，包括项目名和各个统计维度的值，然后使用公式计算热度值，并将项目名和热度值存储到一个新的 `Project` 对象中。
5. 将所有 `Project` 对象添加到列表 `projects` 中。
6. 使用 `Collections.sort` 对 `projects` 列表进行排序。排序规则是先按照热度值降序排列，如果热度值相同，则按照项目名称的字典序排列。
7. 最后，遍历排序后的列表，输出每个项目的名称。

~~~java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt(); // 读取开源项目的个数
        int[] weights = new int[5]; // 权重数组
        for (int i = 0; i < 5; i++) {
            weights[i] = sc.nextInt(); // 读取5个权重值
        }

        // 创建一个列表存储项目及其热度值
        List<Project> projects = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            // 读取每个项目的统计维度
            String name = sc.next();
            int nr_watch = sc.nextInt();
            int nr_star = sc.nextInt();
            int nr_fork = sc.nextInt();
            int nr_issue = sc.nextInt();
            int nr_mr = sc.nextInt();

            // 计算项目的热度值
            int hotness = nr_watch * weights[0] + nr_star * weights[1] + nr_fork * weights[2]
                    + nr_issue * weights[3] + nr_mr * weights[4];

            // 创建项目对象并添加到列表中
            projects.add(new Project(name, hotness));
        }

        // 对项目列表按照热度值降序排序，如果热度相等则按字典序排序
        Collections.sort(projects, (a, b) -> {
            if (b.hotness != a.hotness) {
                return b.hotness - a.hotness; // 热度值降序
            } else {
                return a.name.toLowerCase().compareTo(b.name.toLowerCase()); // 字典序排序
            }
        });

        // 输出项目名称
        for (Project project : projects) {
            System.out.println(project.name);
        }
    }

    // 创建一个Project类来存储项目名称和热度值
    static class Project {
        String name;
        int hotness;

        Project(String name, int hotness) {
            this.name = name;
            this.hotness = hotness;
        }
    }
}
~~~



## 13.分配土地

#### 🎃题目描述

> 从前有个村庄，村民们喜欢在各种田地上插上小旗子，旗子上标识了各种不同的数字，某天全体村民决定将覆盖相同数字的最小矩阵形的土地的分配给为村里做出巨大贡献的村民，请问：此次分配土地，做出贡献的村民中最大会分配多大面积?

------

#### 🎃输入输出

> 输入
> 第一行输入m和n，m代表村子的土地的长，n代表土地的宽
> 第二开始输入地图上的具体标识
>  
> 输出
> 输出要分配的土地面积，包含相桐数字旗子的最小矩阵中的最大面积

------

#### 🎃样例1

```java
输入
3 3
1 0 1
0 0 0
0 1 0

输出
9

说明：
土地上的旗子为1, 其坐标分别为(0,0), (2,1)以及(0,2), 为了覆盖所有旗子，矩阵需要覆盖的横坐标为0和2,纵坐标为0和2,所以面积为9,即(2-0+1)*(2-0+1)=9
1234567891011
```

------

#### 🎃样例2

```java
输入
3 3
1 0 2
0 0 0
0 3 4


输出
1

说明:
不存在成对的旗子，返回1
123456789101112
```

------

### 二、思路参考

------

1. 首先，我们需要遍历整个矩阵，找到每个旗子的位置以及其边界。
2. 创建一个字典（HashMap）来存储每个旗子的最小矩阵边界。字典的键为旗子的标识，值为一个字典，包含旗子的最小x坐标、最大x坐标、最小y坐标和最大y坐标。
3. 在遍历矩阵的过程中，如果当前位置有旗子，则更新或初始化其边界。如果旗子是第一次出现，则在字典中添加一个新的键值对，键为旗子的标识，值为一个包含最小和最大边界的字典。如果旗子已经出现过，则更新其边界。
4. 遍历完整个矩阵后，我们得到了每个旗子的最小矩阵边界。
5. 接下来，我们遍历字典中的所有旗子，并计算每个旗子的最小覆盖矩阵面积。最小覆盖矩阵的面积可以通过计算最小x坐标与最大x坐标之间的差加上1，再乘以最小y坐标与最大y坐标之间的差加上1来得到。
6. 在计算最小覆盖矩阵面积时，我们同时更新最大面积的值。
7. 最后，如果没有旗子出现（即最大面积为0），则返回1作为结果；否则返回最大面积作为结果。

~~~java
import java.util.*;

public class Main {
    
    public static void main(String[] args) {
        // 读取输入数据
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt(); // 矩阵的行数
        int n = scanner.nextInt(); // 矩阵的列数
        int[][] grid = new int[m][n]; // 存储矩阵数据的二维数组
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = scanner.nextInt(); // 读取矩阵的每个元素
            }
        }
        scanner.close();

        // 计算要分配的土地面积并输出
        int result = calculateLargestArea(m, n, grid);
        System.out.println(result);
    }

    public static int calculateLargestArea(int m, int n, int[][] grid) {
        // 创建一个字典来存储每个数字旗子的最小矩阵边界
        Map<Integer, Map<String, Integer>> flags = new HashMap<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int flag = grid[i][j];
                // 如果当前位置有旗子
                if (flag != 0) {
                    // 如果旗子是第一次出现，初始化其边界
                    if (!flags.containsKey(flag)) {
                        Map<String, Integer> coords = new HashMap<>();
                        coords.put("min_x", i); // 最小x坐标
                        coords.put("max_x", i); // 最大x坐标
                        coords.put("min_y", j); // 最小y坐标
                        coords.put("max_y", j); // 最大y坐标
                        flags.put(flag, coords);
                    } else {
                        // 更新旗子的边界
                        Map<String, Integer> coords = flags.get(flag);
                        coords.put("min_x", Math.min(coords.get("min_x"), i)); // 更新最小x坐标
                        coords.put("max_x", Math.max(coords.get("max_x"), i)); // 更新最大x坐标
                        coords.put("min_y", Math.min(coords.get("min_y"), j)); // 更新最小y坐标
                        coords.put("max_y", Math.max(coords.get("max_y"), j)); // 更新最大y坐标
                    }
                }
            }
        }

        // 遍历所有旗子，计算它们的最小覆盖矩阵面积，并找到最大值
        int maxArea = 0;
        for (Map.Entry<Integer, Map<String, Integer>> entry : flags.entrySet()) {
            int flag = entry.getKey();
            Map<String, Integer> coords = entry.getValue();
            int area = (coords.get("max_x") - coords.get("min_x") + 1) * (coords.get("max_y") - coords.get("min_y") + 1);
            maxArea = Math.max(maxArea, area);
        }

        // 如果没有旗子，则返回1
        return maxArea > 0 ? maxArea : 1;
    }
}
~~~





## 14.剩余银饰的重量

#### 🎃题目描述

> 有N块二手市场收集的银饰，每块银饰的重量都是正整数，收集到的银饰会被熔化用于打造新的饰品。
> 每一回合，从中选出三块 最重的 银饰，然后一起熔掉。假设银饰的重量分别为 x 、y和z，且 x <= y <= z。那么熔掉的可能结果如下：
>  
> 如果 x == y == z，那么三块银饰都会被完全熔掉；
> 如果 x == y 且 y != z，会剩余重量为 z - y 的银块无法被熔掉；
> 如果 x != y 且 y == z，会剩余重量为 y - x 的银块无法被熔掉；
> 如果 x != y 且 y != z，会剩余重量为 z - y 与 y - x 差值 的银块无法被熔掉
>  
> 最后，如果剩余两块，返回较大的重量（若两块重量相同，返回任意一块皆可）；如果只剩下一块，返回该块的重量；如果没有剩下，就返回 0

------

#### 🎃输入输出

> 输入
>  
> 输入数据为两行
>  
> 第一行为银饰数组长度n，1 ≤ n ≤ 40，
>  
> 第二行为n块银饰的重量，重量的取值范围为[1，2000]，重量之间使用空格隔开
>  
> 输出
>  
> 如果剩余两块，返回较大的重量（若两块重量相同，返回任意一块皆可）；如果只剩下一块，返回该块的重量；如果没有剩下，就返回 0。

------

#### 🎃样例1

```java
输入
3
1 1 1

输出
0

说明：
选出1 1 1，得到 0，最终数组转换为 []，最后没有剩下银块，返回0
123456789
```

------

#### 🎃样例2

```java
输入
3
3 7 10

输出
1

说明：
选出 3 7 10，需要计算 (7-3) 和 (10-7) 的差值，即(7-3)-(10-7)=1，所以数组转换为 [1]，剩余一块，返回该块重量，返回1


1234567891011
```

------

### 二、思路参考

------

1. 首先，读取输入数据，包括银饰的数量和每个银饰的重量。
2. 将银饰重量列表进行排序，以便每次选择最重的三块银饰进行熔化。
3. 使用一个循环来不断选择最重的三块银饰进行熔化，直到剩余的银饰数量不足三块为止。
4. 在每次循环中，从银饰重量列表中选择最重的三块银饰，并将其分别赋值给变量z、y、x。
5. 根据题目描述，我们需要移除这三块银饰。可以通过使用列表切片的方式将这三块银饰从银饰重量列表中移除。切片操作将返回一个新的列表，其中包含从索引3开始到列表末尾的所有元素。
6. 然后，我们需要根据题目的规则判断这三块银饰是否需要重新添加到银饰重量列表中。
7. 首先，判断x、y、z是否完全相等。如果相等，说明这三块银饰都可以被熔化掉，不需要重新添加到列表中。
8. 如果x、y、z不完全相等，我们需要根据题目的规则选择要添加回列表的银饰。
   - 如果x和y相等，则z-y无法被熔化掉，所以我们将z-y添加回银饰重量列表中。
   - 如果y和z相等，则y-x无法被熔化掉，所以我们将y-x添加回银饰重量列表中。
   - 如果x、y、z三者都不相等，则z-y和y-x的差值无法被熔化掉，所以我们将|z-y-(y-x)|的结果添加回银饰重量列表中。
9. 完成一次循环后，重新对银饰重量列表进行排序，以便下次循环时选择最重的三块银饰。
10. 当剩余的银饰数量不足三块时，跳出循环。
11. 最后，根据剩余的银饰数量返回结果。如果剩余两块银饰，返回最大值；如果只剩一块银饰，返回该值；如果没有剩余银饰，返回0。

~~~java
import java.util.*;

public class Main {

    public static void main(String[] args) {
        // 读取输入数据
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt(); // 银饰的数量
        List<Integer> silverWeights = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            silverWeights.add(scanner.nextInt()); // 读取每个银饰的重量
        }
        scanner.close();

        // 调用函数并打印结果
        int result = meltSilver(silverWeights);
        System.out.println(result);
    }

    public static int meltSilver(List<Integer> silverWeights) {
        // 排序银饰数组，使得我们可以每次选择最重的三块
        Collections.sort(silverWeights, Collections.reverseOrder());

        while (silverWeights.size() > 2) {
            // 选出最重的三块
            int z = silverWeights.get(0);
            int y = silverWeights.get(1);
            int x = silverWeights.get(2);
            // 根据题目描述，移除这三块银饰
            silverWeights = silverWeights.subList(3, silverWeights.size());

            // 如果x、y、z不完全相等，我们需要将剩余的银块按照题目的规则添加回数组
            if (x != y || y != z) {
                if (x == y) {  // 如果 x 和 y 相等，则 z - y 无法被熔掉
                    silverWeights.add(z - y);
                } else if (y == z) {  // 如果 y 和 z 相等，则 y - x 无法被熔掉
                    silverWeights.add(y - x);
                } else {  // 如果三者都不相等，z - y 与 y - x 的差无法被熔掉
                    silverWeights.add(Math.abs((z - y) - (y - x)));
                }
            }

            // 重新排序银饰数组，以便下次迭代选择最重的三块
            Collections.sort(silverWeights, Collections.reverseOrder());
        }

        // 按照题目的要求返回剩余的银饰
        if (silverWeights.size() == 2) {
            return Math.max(silverWeights.get(0), silverWeights.get(1));
        } else if (silverWeights.size() == 1) {
            return silverWeights.get(0);
        } else {
            return 0;
        }
    }
}
~~~



## 15.传递悄悄话

#### 🎃题目描述

> 给定一个二叉树，每个节点上站着一个人，节点数字表示父节点到该节点传递悄悄话需要花费的时间。
>  
> 初始时，根节点所在位置的人有一个悄悄话想要传递给其他人，求二叉树所有节点上的人都接收到悄悄话花费的时间。

------

#### 🎃输入输出

> 输入
> 给定二叉树
>  
> 输出
> 返回所有节点都接收到悄悄话花费的时间

------

#### 🎃样例1

```java
输入
0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2

输出
38

说明：-1表示空节点
1234567
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/83e652dd875d4d239876671d98ca606c.png)

------

### 二、思路参考

------

1. 首先，从用户输入中读取二叉树节点列表，并将其转换为整数列表。
2. 创建两个空列表，一个用于存放所有路径，一个用于存放当前路径。
3. 调用递归函数speak，计算所有路径，并将结果存放在路径列表中。
4. speak函数的参数包括路径列表b、当前路径a、当前节点索引index和节点列表nds。
5. 在speak函数中，首先判断当前节点索引是否超出范围或当前节点是否为空节点。如果是，则将当前路径添加到路径列表b，并返回。
6. 否则，将当前节点的值添加到当前路径a。
7. 然后，递归处理当前节点的左子树，传递的参数为路径列表的副本b、当前路径的副本a、左子节点的索引index * 2 + 1和节点列表nds。
8. 接着，递归处理当前节点的右子树，传递的参数为路径列表的副本b、当前路径的副本a、右子节点的索引index * 2 + 2和节点列表nds。
9. 在主函数中，初始化最大路径和为0。
10. 遍历路径列表中的每个路径。
11. 对于每个路径，计算当前路径的和，并将其与最大路径和进行比较。
12. 如果当前路径的和大于最大路径和，更新最大路径和。
13. 最后，打印最大路径和。



~~~java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Main {
    public static void speak(List<List<Integer>> b, List<Integer> a, int index, List<Integer> nds) {
        // 如果当前节点索引超出范围或当前节点为空节点，将当前路径添加到路径列表并返回
        if (index >= nds.size() || nds.get(index) == -1) {
            b.add(new ArrayList<>(a));
            return;
        }
        // 将当前节点的值添加到当前路径
        a.add(nds.get(index));
        // 递归处理当前节点的左子树，传递的参数为路径列表的副本、当前路径的副本、左子节点的索引和节点列表
        speak(b, new ArrayList<>(a), index * 2 + 1, nds);
        // 递归处理当前节点的右子树，传递的参数为路径列表的副本、当前路径的副本、右子节点的索引和节点列表
        speak(b, new ArrayList<>(a), index * 2 + 2, nds);
    }

    public static void main(String[] args) {
        // 从用户输入中读取二叉树节点列表，并将其转换为整数列表
        Scanner scanner = new Scanner(System.in);
        String st = scanner.nextLine();
        String[] nodesArray = st.split(" ");
        List<Integer> nodes = new ArrayList<>();
        for (String node : nodesArray) {
            nodes.add(Integer.parseInt(node));
        }
        // 创建两个空列表，一个用于存放所有路径，一个用于存放当前路径
        List<List<Integer>> ps = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        // 调用speak函数计算所有路径，并将结果存放在路径列表中
        speak(ps, path, 0, nodes);
        // 初始化最大路径和为0
        int max_value = 0;
        // 遍历路径列表中的每个路径
        for (List<Integer> pp : ps) {
            // 计算当前路径的和
            int sum_value = 0;
            for (int value : pp) {
                sum_value += value;
            }
            // 如果当前路径的和大于最大路径和，更新最大路径和
            if (sum_value > max_value) {
                max_value = sum_value;
            }
        }
        // 打印最大路径和
        System.out.println(max_value);
    }
}
~~~



## 16.小华地图寻宝、小华最多能得到多少克黄金

#### 🎃题目描述

> 小华按照地图去寻宝，地图上被划分成m行和n列的方格，横纵坐标范围分别是[0， n-1]和[0， m-1]
>  
> 在横坐标和纵坐标的数位之和不大于k的方格中存在黄金(每个方格中仅存在一克黄金) ，但横坐标和纵坐标之和大于k的方格存在危险不可进入。小华从入口(0,0)进入，任何时候只能向左，右，上，下四个方向移动一格
>  
> 请问小华最多能获得多少克黄金?

------

#### 🎃输入输出

> 输入
> 坐标取值范围如下：0≤m≤50，0≤n≤50
> k的取值范围如下：0≤k≤100
> 输入中包含3个字数，分别是m， n， k
>  
> 输出
> 输出小华最多能获得多少克黄金

------

#### 🎃样例1

```java
输入
40 40 18


输出
1484
123456
```

------

#### 🎃样例2

```java
输入
5 4 7


输出
20
123456
```

------

### 二、思路参考

------

1. 首先，从主函数中获取输入的行数m、列数n和数位之和的阈值k。
2. 然后，初始化访问标记数组visited，将所有位置标记为未访问。
3. 接下来，定义一个辅助函数sumOfDigits，用于计算一个数的数位之和。
4. 然后，定义递归函数searchGold，用于搜索符合条件的黄金位置数。
   - 如果当前位置越界或者已经访问过，直接返回。
   - 如果当前位置的坐标数位之和大于k，直接返回。
   - 将当前位置标记为已访问，并将黄金数增加。
   - 递归搜索当前位置的四个邻居位置（上、下、左、右）。
5. 最后，在主函数中调用searchGold函数，从(0,0)位置开始搜索。
6. 输出黄金数的值。

~~~java
import java.util.Scanner;

class Main {
    static int m, n, k;
    static int gold = 0;
    static int[][] visited;

    public static int sumOfDigits(int x) {
        int sum = 0;
        while (x != 0) {
            sum += x % 10;
            x /= 10;
        }
        return sum;
    }

    public static void searchGold(int x, int y) {
        // 越界或者访问过的点直接返回
        if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] == 1) return;

        // 检查坐标数位之和是否符合条件
        if (sumOfDigits(x) + sumOfDigits(y) > k) return;

        // 标记当前位置已访问
        visited[x][y] = 1;
        // 黄金数增加
        gold++;

        // 向四个方向递归搜索
        searchGold(x + 1, y);
        searchGold(x - 1, y);
        searchGold(x, y + 1);
        searchGold(x, y - 1);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        m = scanner.nextInt(); // 输入行数
        n = scanner.nextInt(); // 输入列数
        k = scanner.nextInt(); // 输入数位之和的阈值

        // 初始化访问标记数组
        visited = new int[m][n];

        // 从(0,0)开始搜索
        searchGold(0, 0);

        // 输出结果
        System.out.println(gold);
    }
}
~~~



## 17.内存冷热标记

#### 🎃题目描述

> 现代计算机系统中通常存在多级的存储设备，针对海量workload的优化的一种思路是将热点内存页优先放到快速存储层级，这就需要对内存页进行冷热标记。
>  
> 一种典型的方案是基于内存页的访问频次进行标记，如果统计窗口内访问次数大于等于设定值，则认为是热内存页，否则是冷内存页
>  
> 对于统计窗口内跟踪到的访存序列和阈值现在需要实现基于频次的冷热标记。内存页使用页框号作为标识。

------

#### 🎃输入输出

> 输入
> 第一行为输入为N表示访存序列的记录条数0<N<=10000
> 第二行为访存序列，空格分割的N个内存页框号
>  
> 输出
> 第一行输出标记为热内存的内存页个数，如果没有被标记为热内存的，则输出0
> 如果第一行>0， 则接下来按照访问频次降序输出内存页框号，一行一个， 频次一样的页框号，页框号小的排前面。

------

#### 🎃样例1

```java
输入
10
1 2 1 2 1 2 1 2 1 2
5


输出
2
1
2

说明：
内存页框号1和2都被访问了5次，达到了阈值，因此它们被标记为热内存页;
输出首先是热内存页的数量2,然后是按照访问频次降序排列的页框号1和2(频次-样的页框号，页框号小的排前面)。

123456789101112131415
```

------

#### 🎃样例2

```java
输入
5
1 2 3 4 5
3


输出
0


说明：
没有任何内存页的访问次数达到阈值3,因此没有热内存页，输出为0
123456789101112
```

------

### 二、思路参考

------

1. 首先，从输入中读取访存序列的记录条数N。
2. 创建一个大小为10001的Page数组，用于存储内存页框号和访问次数。其中Page是一个内部类，实现了Comparable接口，用于进行排序。
3. 初始化pages数组，将每个内存页框号及其访问次数都初始化为0。
4. 读取访存序列，并对每个内存页的访问次数进行统计。将访存序列中的页框号作为索引，访问次数加1。
5. 从输入中读取阈值threshold。
6. 使用Arrays.sort对pages数组进行排序。排序的规则是首先按照访问次数降序排序，如果访问次数相同，则按页框号升序排序。
7. 统计热内存页的个数hot_pages_count。遍历pages数组，如果访问次数大于等于阈值，则热内存页个数加1。
8. 输出热内存页的个数hot_pages_count。
9. 如果存在热内存页，按顺序输出它们的页框号。遍历pages数组，输出访问次数大于等于阈值的页框号。

~~~java
import java.util.Arrays;
import java.util.Scanner;

class Main {
    // 定义一个内部类来存储内存页框号和访问次数
    static class Page implements Comparable<Page> {
        int page_frame;
        int count;

        public Page(int page_frame, int count) {
            this.page_frame = page_frame;
            this.count = count;
        }

        @Override
        public int compareTo(Page other) {
            if (this.count == other.count) {
                // 如果访问次数相同，则按页框号升序排序
                return this.page_frame - other.page_frame;
            } else {
                // 访问次数不同，按访问次数降序排序
                return other.count - this.count;
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt(); // 读取访存序列的记录条数

        // 创建一个足够大的数组来存储所有可能的内存页框号及其访问次数
        Page[] pages = new Page[10001];

        // 初始化pages数组
        for (int i = 0; i < 10001; i++) {
            pages[i] = new Page(i, 0);
        }

        // 读取访存序列并统计每个内存页的访问次数
        for (int i = 0; i < N; i++) {
            int page_frame = scanner.nextInt();
            pages[page_frame].count++;
        }

        int threshold = scanner.nextInt(); // 读取阈值

        // 使用Arrays.sort排序
        Arrays.sort(pages);

        // 统计热内存页的个数
        int hot_pages_count = 0;
        for (int i = 0; i < 10001 && pages[i].count >= threshold; i++) {
            hot_pages_count++;
        }

        // 输出热内存页的个数
        System.out.println(hot_pages_count);

        // 如果有热内存页，按顺序输出它们的页框号
        for (int i = 0; i < hot_pages_count; i++) {
            System.out.println(pages[i].page_frame);
        }
    }
}
~~~



## 18.学生排名、智能成绩表 | 机试真题+思路参考+代码解析（C卷）

#### 🎃题目描述

> 小明来到学校当老师，需要将学生按考试总分或单科分数进行排名，你能帮帮他吗?

------

#### 🎃输入输出

> 输入
> 第1行输入两个整数，学生人数n和科目数量m，0<n< 100，0<m< 10
>  
> 第2行输入m个科目名称，彼此之间用空格隔开
>  
> 注意：
> ● 科目名称只由英文字母构成，单个长度不超过10个字符
> ● 科目的出现顺序和后续输入的学生成绩一一对应
> ●不会出现重复的科目名称
>  
> 第3行开始的n行，每行包含一个学生的姓名和该生m个科目的成绩(空格隔开)
> ● 学生不会重名。
> ● 学生姓名只由英文字母构成，长度不超过10个字符
> ● 成绩是0~100的整数,依次对应第2行种输入的科目
>  
> 第n+2行，输入用作排名的科目名称。若科目不存在，则按总分进行排序
>  
> 输出
> 输出一行，按成绩排序后的学生名字，空格隔开，成绩相同的按照学生姓名字典顺序排序

------

#### 🎃样例1

```java
输入
3 2
yuwen shuxue
fangfang 95 90
xiaohua 88 98
minmin 100 82
shuxue

输出
xiaohua fangfang minmin

1234567891011
```

------

#### 🎃样例2

```java
输入
3 2
yuwen shuxue
fangfang 95 90
xiaohua 88 95
minmin 90 95
zongfen



输出
fangfang minmin xiaohua


说明:
排序科目不存在，按总分排序，fangfang和minmin总分相同，按姓名的字典序顺序，fangfang 排在前面

1234567891011121314151617
```

------

### 二、思路参考

------

1. 读取学生人数n和科目数量m。
2. 读取m个科目名称，存入subjects数组。
3. 创建一个空HashMap，用于存储学生的姓名和对应的成绩。
4. 读取每个学生的姓名和成绩，将其存入HashMap中。每个学生的成绩以一个int数组存储。
5. 读取用作排名的科目名称，存入rankSubject变量。
6. 判断排名科目是否存在于科目名称中。
   - 如果存在，获取排名科目在科目名称中的索引，存入index变量。
   - 如果不存在，将index设为-1。
7. 创建一个ArrayList，用于存储学生姓名和对应的总分或指定科目的分数。将HashMap的条目转化为ArrayList的条目存储。
8. 根据index的值进行排序。
   - 如果index不等于-1，表示存在指定科目，根据指定科目的分数进行排序。如果指定科目分数相同，则按照姓名升序排序。
   - 如果index等于-1，表示不存在指定科目，根据总分进行排序。如果总分相同，则按照姓名升序排序。
9. 输出排序后的学生姓名。
   - 遍历排序后的ArrayList，获取每个条目的键（学生姓名），将其存入ArrayList中。
10. 输出排序后的学生姓名，使用String的join方法将ArrayList中的元素连接成一个字符串，以空格分隔。

~~~java
import java.util.*;

class Main {
    // 定义学生类
    static class Student {
        String name; // 学生姓名
        int[] scores; // 学生各科成绩
        int total; // 学生总分

        public Student(String name, int[] scores) {
            this.name = name;
            this.scores = scores;
            this.total = 0;
            for (int score : scores) {
                this.total += score;
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt(); // 学生人数
        int m = scanner.nextInt(); // 科目数量

        String[] subjects = new String[m]; // 科目名称数组
        for (int i = 0; i < m; i++) {
            subjects[i] = scanner.next();
        }

        Student[] students = new Student[n]; // 学生数组
        for (int i = 0; i < n; i++) {
            String name = scanner.next(); // 学生姓名
            int[] scores = new int[m]; // 学生各科成绩
            for (int j = 0; j < m; j++) {
                scores[j] = scanner.nextInt();
            }
            students[i] = new Student(name, scores);
        }

        String subject = scanner.next(); // 用于排名的科目名称

        sortStudents(students, n, subject, subjects, m); // 调用排序函数对学生进行排序

        for (int i = 0; i < n; i++) {
            System.out.print(students[i].name + " ");
        }
        System.out.println();
    }

    // 排名函数
    static void sortStudents(Student[] students, int n, String subject, String[] subjects, int m) {
        int subjectIndex = findSubjectIndex(subject, subjects, m); // 查找指定科目的索引
        Student temp;

        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                int cmp = 0;
                if (subjectIndex != -1) {
                    // 按指定科目成绩排序
                    cmp = students[j].scores[subjectIndex] - students[i].scores[subjectIndex];
                } else {
                    // 按总分排序
                    cmp = students[j].total - students[i].total;
                }

                // 如果成绩相同，按字典序排序
                if (cmp == 0) {
                    cmp = students[i].name.compareTo(students[j].name);
                }

                if (cmp > 0) {
                    temp = students[i];
                    students[i] = students[j];
                    students[j] = temp;
                }
            }
        }
    }

    // 查找科目索引函数
    static int findSubjectIndex(String subject, String[] subjects, int m) {
        for (int i = 0; i < m; i++) {
            if (subjects[i].equals(subject)) {
                return i;
            }
        }
        return -1; // 如果科目不存在，返回-1
    }
}
~~~



## 19.攀登者

#### 🎃题目描述

> 攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰
> 地图表示为一维数组，数组的索引代表水平位置，数组的高度代表相对海拔高度。其中数组元素0代表地面。
>  
> 例如 [0,1,2,4,3,1,0,0,1,2,3,1,2,1,0]，代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5和8,9,10,11,12,13，最高峰高度分别为 4,3。最高峰位置分别为3,10
>  
> 一个山脉可能有多座山峰(高度大于相邻位置的高度，或在地图边界且高度大于相邻的高度)
>  
> 登山时会消耗登山者的体力(整数)，上山时，消耗相邻高度差两倍的体力，下坡时消耗相邻高度差一倍的体力，平地不消耗体力，登山者体力消耗到零时会有生命危险
>  
> 例如，上图所示的山峰，从索引0，走到索引1，高度差为1，需要消耗2X1=2的体力，从索引2高度2走到高度4索引3需要消耗2X2=4的体力。如果是从索引3走到索引4则消耗1X1=1的体力
>  
> 登山者想要知道一张地图中有多少座山峰

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/be020e4af2104daaa973beef2c7c936b.png)

------

#### 🎃输入输出

> 输入
> 一行数组
> 第二行为N个空格分隔的整数，每个数的范围为[1,10000]
>  
> 输出
> 有多少座山峰

------

#### 🎃样例1

```java
输入
[0,1,4,3,1,0,0,1,2,3,1,2,1,0]

输出
3

说明:
山峰所在的索引分别为 2,10,12
12345678
```

------

### 二、思路参考

------

1. 通过`Scanner`类从控制台读取输入的一行字符串，该字符串代表地图数组。
2. 使用`substring`方法去除字符串的首尾方括号，得到一个不包含方括号的字符串。
3. 使用`split`方法将字符串按逗号分割，得到一个字符串数组。
4. 创建一个整型数组`mapArr`，其长度与字符串数组相同。
5. 使用循环遍历字符串数组，将每个元素转换为整型并存入`mapArr`数组中。
6. 调用`countPeaks`方法，传入`mapArr`数组，计算山峰的数量。
7. 在`countPeaks`方法中，初始化山峰数量`peakCount`为0。
8. 使用循环遍历`mapArr`数组，从索引1开始，到倒数第二个索引结束。
9. 检查当前点是否比左右两边的点都高，如果是，则将`peakCount`加1，表示找到了一个山峰。
10. 如果当前点在数组的左边界（索引1），并且比右边的点高，也将`peakCount`加1。
11. 如果当前点在数组的右边界（倒数第二个索引），并且比左边的点高，同样将`peakCount`加1。
12. 返回最终的山峰数量`peakCount`。
13. 在`main`方法中，打印输出山峰数量。

~~~java
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        // 读取输入
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        // 解析输入为数组
        String[] arr = input.substring(1, input.length() - 1).split(",");
        int[] mapArr = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            mapArr[i] = Integer.parseInt(arr[i].trim());
        }
        // 调用函数计算山峰数量
        System.out.println(countPeaks(mapArr));
    }

    // 计算山峰数量的函数
    static int countPeaks(int[] mapArr) {
        int peakCount = 0; // 初始化山峰数量为0
        for (int i = 1; i < mapArr.length - 1; i++) {
            // 如果当前点比左右两边的点都高，那么它就是一个山峰
            if (mapArr[i] > mapArr[i - 1] && mapArr[i] > mapArr[i + 1]) {
                peakCount++;
            }
            // 如果当前点在数组的左边界，并且比右边的点高，那么它也是一个山峰
            else if (i == 1 && mapArr[i] > mapArr[i + 1]) {
                peakCount++;
            }
            // 如果当前点在数组的右边界，并且比左边的点高，那么它也是一个山峰
            else if (i == mapArr.length - 2 && mapArr[i] > mapArr[i - 1]) {
                peakCount++;
            }
        }
        return peakCount;
    }
}
~~~



## 20.跳房子1

#### 🎃题目描述

> 跳房子，也叫跳飞机，是一种世界性的儿童游戏，游戏参与者需要分多个回合按顺序跳到第1格直到房子的最后一格
>  
> 跳房子的过程中，可以向前跳，也可以向后跳，假设房子的总格数是count，小红每回合可能连续跳的步教都放在数组steps中，请问数组中是否有一种步数的组合， 可以让小红两个回合跳到最后一格?
>  
> 如果有，请输出索引和最小的步数组合
>  
> 注意：
> 数组中的步数可以重复，但数组中的元素不能重复使用
> 提供的数据保证存在满足题目要求的组合，且索引和最小的步数组合是唯一的

------

#### 🎃输入输出

> 输入
> 第一行输入为每回合可能连续跳的步数，它是int整数数组类型
> 第二行输入为房子总格数count，它是int整数类型
>  
> 输出
> 返回索引和最小的满足要求的步数组合(顺序保持steps中原有顺序)

------

#### 🎃样例1

```java
输入
[1,4,5,2,2]
7

输出
[5,2]
123456
```

------

#### 🎃样例2

```java
输入
[-1,2,4,9,6]
8

输出
[-1,9]
123456
```

------

### 二、思路参考

------

1. 首先，定义一个结果列表results，用于存储已找到的步数组合及其索引之和。
2. 使用双重循环遍历数组中的所有可能的两个步数组合。外层循环变量i从0到数组长度-1，内层循环变量j从i+1到数组长度-1。这样可以确保不重复使用相同的步数。
3. 在循环中，判断当前步数组合是否满足要求。即判断steps[i] + steps[j]是否等于目标和count。
4. 如果满足要求，将该组合及其索引之和添加到结果列表results中。使用数组来存储组合和索引之和，形式为new int[]{steps[i], steps[j], i + j + 2}。索引之和需要加2的原因是索引从1开始计数，而数组索引从0开始计数。
5. 如果存在多个满足条件的组合，找到索引和最小的组合。通过遍历结果列表results，将第一个组合设为初始的索引和最小组合minSumIndex，然后依次比较每个组合的索引和与minSumIndex的索引和，如果更小则更新minSumIndex。
6. 最后，将索引和最小的组合中的步数部分提取出来，存入一个新的列表minCombination中，并返回该列表作为最终的结果。
7. 如果没有满足条件的组合，即结果列表results为空，返回一个空列表作为最终结果。

~~~~java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        int[] steps = {1, 4, 5,2 ,2};
        int count = 7;
        List<Integer> result = findMinStepsCombination(steps, count);
        System.out.println(result);
    }

    /**
     * 查找数组中两个数之和等于指定值的最小索引和的组合
     *
     * @param steps 给定的步骤数组
     * @param count 要查找的目标和
     * @return 返回索引和最小的步骤组合，如果不存在则返回空列表
     */
    public static List<Integer> findMinStepsCombination(int[] steps, int count) {
        // 存储已找到的步数组合及其索引之和
        List<int[]> results = new ArrayList<>();

        // 使用双重循环遍历数组中所有可能的两步组合
        for (int i = 0; i < steps.length; i++) {
            for (int j = i + 1; j < steps.length; j++) { // 确保不重复使用相同的步数
                // 检查当前步数组合是否满足要求
                if (steps[i] + steps[j] == count) {
                    // 将组合及其索引之和添加到结果列表中
                    results.add(new int[]{steps[i], steps[j], i + j + 2}); // 索引从1开始计数，所以需要加2
                }
            }
        }

        // 如果存在多个满足条件的组合，找到索引和最小的组合
        if (!results.isEmpty()) {
            int[] minSumIndex = results.get(0);
            for (int[] result : results) {
                if (result[2] < minSumIndex[2]) {
                    minSumIndex = result;
                }
            }
            // 返回索引和最小的步数组合
            List<Integer> minCombination = new ArrayList<>();
            minCombination.add(minSumIndex[0]);
            minCombination.add(minSumIndex[1]);
            return minCombination;
        } else {
            // 如果没有满足条件的组合，返回空列表
            return new ArrayList<>();
        }
    }
}
~~~~



## 21.跳房子2

#### 🎃题目描述

> 跳房子，也叫跳飞机，是一种世界性的儿童游戏。
>  
> 游戏参与者需要分多个回合按顺序跳到第1格直到房子的最后一格，然后获得一次选房子的机会，直到所有房子被选完，房子最多的人获胜。
>  
> 跳房子的过程中，如果有踩线等违规行为，会结束当前回合，甚至可能倒退几步。假设房子的总格数是count，小红每回合可能连续跳的步数都放在数组steps中，请问数组中是否有一种步数的组合，可以让小红三个回合跳到最后一格?
>  
> 如果有，请输出索引和最小的步数组合(数据保证索引和最小的步数组合是唯一的

------

#### 🎃输入输出

> 输入
> 第一行输入为房子总格数count，它是int整数类型
> 第二行输入为每回合可能连续跳的步数，它int整数数组类型
>  
> 输出
> 返回索引和最小的满足要求的步数组合 (顺序保持steps中原有顺序)

------

#### 🎃样例1

```java
输入
9
[1,4,5,2,0,2]


输出
[4,5,0]
1234567
```

------

#### 🎃样例2

```java
输入
9
[1,5,2,0,2,4]


输出
[5,2,2]
1234567
```

------

#### 🎃样例3

```java
输入
12
[-1,2,4,9]




输出
[-1,4,9]
123456789
```

------

#### 🎃样例4

```java
输入
15
[1,9,4,25,10,8,7,5]



输出
[1,4,10]
12345678
```

------

### 二、思路参考

------

1. 首先生成所有可能的三元素组合的索引。这里使用了递归的方法，从0开始遍历到n-1，每次选取一个数字加入到当前组合中，并递归调用生成组合的函数，直到达到所需的组合长度为止。
2. 遍历所有索引组合，计算每个组合对应的步数总和。将选取的索引对应的步数加起来，得到步数总和。
3. 如果步数总和等于房子总格数，计算当前索引和。将选取的索引加起来，得到索引和。
4. 检查当前索引和是否为最小索引和，如果是则更新最小值和对应的步数组合。如果当前索引和小于最小索引和，更新最小索引和和对应的步数组合。
5. 返回索引和最小的组合。将最小索引和对应的步数加入到一个新的数组中，作为最终的结果。

~~~java
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

public class Main {
    public static void main(String[] args) {
        // 输入示例
        int count =9;
        List<Integer> steps = Arrays.asList(1,4,5,2,0,2);

        // 找到步数组合
        List<Integer> combination = findStepsCombination(count, steps);

        // 输出结果
        System.out.println(combination);
    }

    private static List<Integer> findStepsCombination(int count, List<Integer> steps) {
        // 生成所有可能的三元素组合的索引
        List<List<Integer>> combIndices = generateCombinations(steps.size(), 3);

        // 初始化最小索引和以及对应的步数组合
        int minIndexSum = Integer.MAX_VALUE;
        List<Integer> minComb = new ArrayList<>();

        // 遍历所有索引组合
        for (List<Integer> indices : combIndices) {
            // 计算当前索引组合的步数总和
            int stepSum = 0;
            for (int index : indices) {
                stepSum += steps.get(index);
            }
            // 如果步数总和等于房子总格数
            if (stepSum == count) {
                // 计算当前索引和
                int indexSum = 0;
                for (int index : indices) {
                    indexSum += index;
                }
                // 检查是否为最小索引和，如果是则更新最小值和对应的组合
                if (indexSum < minIndexSum) {
                    minIndexSum = indexSum;
                    minComb = new ArrayList<>();
                    for (int index : indices) {
                        minComb.add(steps.get(index));
                    }
                }
            }
        }

        // 返回索引和最小的组合
        return minComb;
    }

    // 生成指定长度的数组的所有可能的k元素组合
    private static List<List<Integer>> generateCombinations(int n, int k) {
        List<List<Integer>> combinations = new ArrayList<>();
        generateCombinations(combinations, new ArrayList<>(), 0, n, k);
        return combinations;
    }

    // 递归方法来生成组合
    private static void generateCombinations(List<List<Integer>> combinations, List<Integer> current, int start, int n, int k) {
        if (k == 0) {
            // 如果达到所需的组合长度，添加到结果中
            combinations.add(new ArrayList<>(current));
            return;
        }
        for (int i = start; i < n; ++i) {
            current.add(i);
            generateCombinations(combinations, current, i + 1, n, k - 1);
            current.remove(current.size() - 1);
        }
    }
}

~~~



## 22.API集群负载统计

#### 🎃题目描述

> 某个产品的 RESTful API 集合部署在服务器集群的多个节点上，近期对客户端访问日志进行了采集，需要统计各个 API 的访问频次，根据热点信息在服务器节点之间做负载均衡，现在需要实现热点信息统计查询功能。
>  
> RESTful API 的由多个层级构成，层级之间使用/连接，如/A/B/C/D这个地址，A 属于第一级，B 属于第二级，C 属于第三级，D 属于第四级。
>  
> 现在负载均衡模块需要知道给定层级上某个名字出现的频次，未出现过用 0 次表示，实现这个功能

------

#### 🎃输入输出

> 输入
> 第一行为 N，表示访问历史日志的条数，0<N<=100。
>  
> 接下来 N 行，每一行为一个 RESTful API 的 URL 地址，约束地址中仅包含英文字母和连接符/，最大层级为 10，每层级字符串最大长度为 10。
>  
> 最后一行为层级 L 和要查询的关键字。
>  
> 输出
> 输出给定层级上，关键字出现的频次，使用完全匹配方式（大小写敏感）

------

#### 🎃样例1

```java
输入
5
/huawei/computing/no/one
/huawei/computing
/huawei
/huawei/cloud/no/one
/huawei/wireless/no/one
2 computing



输出
2

说明:
在第二层级上，computing 出现了 2 次，因此输出 2
12345678910111213141516
```

------

#### 🎃样例2

```java
输入
5
/huawei/computing/no/one
/huawei/computing
/huawei
/huawei/cloud/no/one
/huawei/wireless/no/one
4 two


输出
0

说明:
存在第四层级的 URL 上，没有出现 two，因此频次是 0
123456789101112131415
```

------

### 二、思路参考

------

1. 首先初始化频次为0。
2. 遍历日志列表apiLogs，对每条API日志进行处理。
3. 将每条API日志按’/'分割成层级列表levels。
4. 如果层级数大于或等于所查询的层级l，则进行下一步操作。
5. 检查对应层级的名称是否与关键字keyword完全匹配。如果匹配，则频次加1。
6. 继续遍历下一条API日志，重复步骤3到步骤5。
7. 返回最终频次。

~~~java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // 读取输入
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt(); // 日志条数
        List<String> apiLogs = new ArrayList<>(); // API 日志列表
        for (int i = 0; i < N; i++) {
            apiLogs.add(scanner.next()); // 添加日志到列表
        }
        int L = scanner.nextInt(); // 读取层级
        String keyword = scanner.next(); // 读取关键字

        // 计算频次并输出结果
        int frequency = countApiFrequency(N, apiLogs, L, keyword);
        System.out.println(frequency);
    }

    private static int countApiFrequency(int n, List<String> apiLogs, int l, String keyword) {
        // 初始化频次为0
        int frequency = 0;

        // 遍历日志列表
        for (String api : apiLogs) {
            // 将每条API日志按'/'分割成层级列表
            String[] levels = api.split("/");
            // 如果层级数大于或等于所查询的层级
            if (levels.length > l) {
                // 检查对应层级的名称是否与关键字完全匹配
                if (levels[l].equals(keyword)) {
                    // 如果匹配，则频次加1
                    frequency++;
                }
            }
        }

        // 返回最终频次
        return frequency;
    }
}
~~~



## 23.掌握的单词个数

#### 🎃题目描述

> 有一个字符串数组 words 和一个字符串 chars 。
>  
> 假如可以用 chars 中的字母拼写出 words 中的某个“单词”（字符串），那么我们就认为你掌握了这个单词。
>  
> words 的字符仅由 a-z 英文小写字母组成，例如 “abc” chars 由 a-z 英文小写字母和 “?” 组成。其中英文问号 “?” 表示万能字符，能够在拼写时当做任意一个英文字母。例如：“?” 可以当做 “a” 等字母。
>  
> 注意：每次拼写时，chars 中的每个字母和万能字符都只能使用一次。
>  
> 输出词汇表 words 中你掌握的所有单词的个数。没有掌握任何单词，则输出 0。

------

#### 🎃输入输出

> 输入
> 第 1 行输入数组 words 的个数，记为 N。 从第 2 行开始到第 N+1 行一次输入数组 words 的每个字符串元素
> 第 N+2 行输入字符串 chars。
>  
> 输出
> 输出一个整数，表示词汇表 words 中你掌握的单词个数。

------

#### 🎃样例1

```java
输入
4
cat
bt
hat
tree
atach



输出
2

说明:
atach可以拼写出单词cat和hat，因此掌握的单词是2个。
123456789101112131415
```

------

#### 🎃样例2

```java
输入
4
cat
bt
hat
tree
at?ch


输出
3

说明:
at?ch可以拼写出单词cat、hat和bt，因此掌握的单词是3个。
1234567891011121314
```

------

#### 🎃样例3

```java
输入
4
cat
bt
hat
tree
atach??



输出
3

说明:
可以拼写字符串 cat、bt、hat
123456789101112131415
```

------

#### 🎃样例4

```java
输入
3
hello
world
cloud
welldonehohneyr


输出
2

说明:
可以拼写字符串"hello"和"world"
12345678910111213
```

------

#### 🎃样例5

```java
输入
3
apple
car
window
welldoneapplec?




输出
2

说明:
可以拼写字符串 "apple" 和 "car"
123456789101112131415
```

------

### 二、思路参考

------

1. 首先定义一个函数 `canSpell(word, chars)`，用来判断是否可以用 `chars` 拼写出 `word`。
2. 在 `canSpell` 函数中，首先创建一个 `char_count` 字典来统计 `chars` 中每个字符的出现次数。
3. 遍历 `word` 中的每个字符，检查该字符是否在 `char_count` 中存在且计数大于0。如果存在且计数大于0，则将该字符的计数减1。
4. 如果字符在 `char_count` 中不存在，但是 `'?'` 存在且计数大于0，则将 `'?'` 的计数减1。
5. 如果以上两种情况都不满足，说明字符无法在 `chars` 中找到或者没有足够的 `'?'`，返回 `False` 表示不能拼写出 `word`。
6. 如果遍历完 `word` 中的每个字符都能在 `chars` 中找到或者使用 `'?'`，则返回 `True` 表示能够拼写出 `word`。
7. 在主程序中，读取输入的 `words` 的个数 `N`，以及每个单词 `words` 和 `chars`。
8. 初始化掌握的单词个数 `count` 为0。
9. 遍历单词列表 `words`，对每个单词调用 `canSpell` 方法检查是否能够拼写。
10. 如果 `canSpell` 返回 `True`，则将 `count` 加1，表示掌握了这个单词。
11. 最后，输出掌握的单词个数 `count`。

~~~java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // 读取输入
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt(); // words的个数
        List<String> words = new ArrayList<>(); // words列表
        for (int i = 0; i < N; i++) {
            words.add(scanner.next()); // 添加单词到列表
        }
        String chars = scanner.next(); // chars字符串

        // 初始化掌握的单词个数为0
        int count = 0;

        // 遍历words中的每个单词，检查是否能够拼写
        for (String word : words) {
            if (canSpell(word, chars)) {
                count++; // 如果能够拼写，掌握单词个数加1
            }
        }

        // 输出掌握的单词个数
        System.out.println(count);
    }

    private static boolean canSpell(String word, String chars) {
        // 对chars中的每个字符进行计数
        Map<Character, Integer> charCount = new HashMap<>();
        for (char c : chars.toCharArray()) {
            charCount.put(c, charCount.getOrDefault(c, 0) + 1);
        }

        // 检查word中的每个字符是否可以在chars中找到
        for (char w : word.toCharArray()) {
            if (charCount.containsKey(w) && charCount.get(w) > 0) {
                charCount.put(w, charCount.get(w) - 1);
            } else if (charCount.containsKey('?') && charCount.get('?') > 0) {
                charCount.put('?', charCount.get('?') - 1);
            } else {
                // 如果word中的字符在chars中找不到，或者没有足够的'?'
                // 则返回false，表示不能拼写出word
                return false;
            }
        }

        return true;
    }
}
~~~



## 24.积分奖励

#### 🎃题目描述

> 现有N个任务需要处理，同一时间只能处理一个任务, 处理每个任务所需要的时间固定为1。
>  
> 每个任务都有最晚处理时间限制和积分值，在最晚处理时间点之前处理完成任务才可获得对应的积分奖励。
>  
> 可用于处理任务的时间有限，请问在有限的时间内，可获得的最多积分。

------

#### 🎃输入输出

> 输入
> 第一行为一个数N，表示有N个任务，1≤N≤100
> 第二行为一个数T，可于处理任务的时间，1≤T≤100
> 接下来N行，每行两个空格分隔的整数(SLA和V)，SLA表示任务的最晚处理时间，V表示任务对应的积分。（1≤SLA≤100 ，0≤V≤100000）
>  
> 输出
> 可获得的最多积分

------

#### 🎃样例1

```java
输入
4
3
1 2
1 3
1 4
1 5




输出
5


说明:
虽然有3个单位的时间用于处理任务，可是所有任务在时刻1之后都无效。
所以在第1个时间单位内，选择处理有5个积分的任务。1-3时无任务处理。

12345678910111213141516171819
```

------

#### 🎃样例2

```java
输入
4
3
1 2
1 3
1 4
3 5




输出
9

说明:
第1个时间单位内，处理任务3,获得4个积分
第2个时间单位内，处理任务4，获得5个积分
第3个时间单位内，无任务可处理
共获得9个积分

1234567891011121314151617181920
```

------

### 二、思路参考

------

1. 首先读入任务数量 N 和可用处理时间 T。
2. 动态创建一个大小为 N 的任务数组，并填充任务信息。
3. 使用排序算法（这里使用 Java 内置的排序函数），根据任务的最晚处理时间 SLA 对任务进行排序。
4. 初始化积分 totalScore 为 0。
5. 创建一个大小为 N 的布尔数组 processed，用来标记每个任务是否已经被处理，默认所有任务未被处理。
6. 从 T 开始递减处理每个时间单位。对于每个时间单位 time，从任务数组中查找满足以下条件的任务：该任务的最晚处理时间 SLA 大于等于当前时间 time，积分 V 是当前未处理任务中最大的，且任务未被处理过。
7. 如果找到这样的任务，将其标记为已处理，并将其积分加到 totalScore 上。
8. 循环结束后，输出 totalScore，即为最多可获得的积分总数。
9. 关闭 Scanner 对象以释放资源。

~~~java
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

// 定义任务类
class Task {
    int SLA; // 最晚处理时间
    int V;   // 积分

    public Task(int SLA, int V) {
        this.SLA = SLA;
        this.V = V;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取任务数量和可用处理时间
        int N = scanner.nextInt();
        int T = scanner.nextInt();

        // 创建任务数组
        Task[] tasks = new Task[N];

        // 读取任务信息
        for (int i = 0; i < N; i++) {
            int sla = scanner.nextInt();
            int v = scanner.nextInt();
            tasks[i] = new Task(sla, v);
        }

        // 根据最晚处理时间对任务进行排序
        Arrays.sort(tasks, new Comparator<Task>() {
            public int compare(Task taskA, Task taskB) {
                return taskA.SLA - taskB.SLA;
            }
        });

        // 初始化积分
        int totalScore = 0;

        // 初始化一个用于记录任务是否已经处理的数组
        boolean[] processed = new boolean[N]; // 默认初始化为false

        // 对于每个可用的时间单位，从后往前查找最优的任务处理
        for (int time = T; time > 0; time--) {
            // 初始化用于选择当前时间点的任务的变量
            int idx = -1;
            int maxScore = 0;
            for (int i = 0; i < N; i++) {
                // 如果当前任务可以在当前时间处理，并且积分高于已记录的最高积分，且未被处理
                if (tasks[i].SLA >= time && tasks[i].V > maxScore && !processed[i]) {
                    idx = i;
                    maxScore = tasks[i].V;
                }
            }
            // 如果找到了合适的任务，处理它
            if (idx != -1) {
                processed[idx] = true;  // 标记为已处理
                totalScore += maxScore;  // 增加积分
            }
        }

        // 输出最多可获得的积分
        System.out.println(totalScore);

        scanner.close();
    }
}
~~~



## 25.小明的幸运数

#### 🎃题目描述

> 小明在玩一个游戏，游戏规则如下：在游戏开始前，小明站在坐标轴原点处(坐标值为0)
> 给定一组指令和一个幸运数，每个指令都是一个整数， 小明按照指令前进指定步数或者后退指定步数。前进代表朝坐标轴的正方向走，后退代表朝坐标轴的负方向走
>  
> 幸运数为一个整数，如果某个指令正好和幸运数相等，则小明行进步数+1
>  
> 例如：
> 幸运数为3，指令为[2,3,0,-5]
>  
> 指令为2，表示前进2步；
> 指令为3，正好和幸运数相等，前进3+1=4步；
> 指令为0，表示原地不动，既不前进，也不后退。
> 指令为-5，示后退5步。
>  
> 请你计算小明在整个游戏过程中，小明所处的最大坐标值

------

#### 🎃输入输出

> 输入
> 第一行输入1个数字，代表指令的总个数n (1≤n≤ 100)
> 第二行输入1个数字，代表幸运数m (-100 ≤m≤100)
> 第三行输入n个指令，每个指令的取值范围为： -100 ≤指令值≤100
>  
> 输出
> 输出在整个游戏过程中，小明所处的最大坐标值。异常情况下输出： 12345

------

#### 🎃样例1

```java
输入
2
1
-5 1




输出
0


说明:
总共2个指令，幸运数为1,按照指令行进，依次如下游戏开始前，站在坐标轴原点，此时坐标值为0; 
指令为-5，后退5步，此时坐标值为-5;
指令为1,正好等于幸运数，前进1+1=2步， 此时坐标值为-3;
整个游戏过程中，小明所处的坐标值依次为[0, -5, -3],最大坐标值为0。
1234567891011121314151617
```

------

#### 🎃样例2

```java
输入
5
-5
-5 1 6 0 -7





输出
1

说明:
总共5个指令，幸运数为-5，依照指令行进，依次如下: 
游戏开始前，站在坐标轴原点，此时坐标值为0,
指令为-5，正好等于幸运数，后退5+1=6步，此时坐标值为-6; 
指令为1,前进1步，此时坐标值为-5;
指令为6,前进6步，此时坐标值为1;
指令为0，既不前进，也不后退，此时坐标值为1;
指令为-7，后退7步，此时坐标值为-6。
整个游戏过程中，小明所处的坐标值依次为:
[0,-6,-5, 1, 1,-6]， 最大坐标值为1。
12345678910111213141516171819202122
```

------

### 二、思路参考

------

1. 使用 `Scanner` 类从标准输入读取指令总个数 `n`、幸运数 `m` 和 `n` 个指令。
2. 定义 `maxCoordinate` 方法来计算过程中的最大坐标值。方法中，我们使用一个变量 `currentCoordinate` 来记录小明当前的坐标，另一个变量 `maxCoordinateValue` 来记录过程中的最大坐标值。
3. 遍历指令数组 `instructions`。如果指令等于幸运数 `m`，则小明的当前坐标减去 `m` 的绝对值加一；如果不是幸运数，则直接按照指令移动小明的坐标。
4. 每次移动后，更新 `maxCoordinateValue` 为 `currentCoordinate` 和 `maxCoordinateValue` 中的较大值。
5. 遍历完所有指令后，返回 `maxCoordinateValue`，即为过程中的最大坐标值。
6. 在 `main` 方法中调用 `maxCoordinate` 方法，并输出结果。
7. 最后关闭 `Scanner` 对象。

~~~java
import java.util.Scanner;

public class Main {

    // 计算过程中的最大坐标值的方法
    public static int maxCoordinate(int n, int m, int[] instructions) {
        // 初始化小明当前的坐标和过程中的最大坐标值
        int currentCoordinate = 0;
        int maxCoordinateValue = 0;

        // 遍历指令来更新小明的坐标
        for (int instruction : instructions) {
            // 当指令等于幸运数时，特殊处理
            if (instruction == m) {
                currentCoordinate -= (Math.abs(m) + 1);
            } else {
                // 正常情况下，根据指令前进或后退
                currentCoordinate += instruction;
            }

            // 更新过程中的最大坐标值
            maxCoordinateValue = Math.max(maxCoordinateValue, currentCoordinate);
        }

        // 返回过程中的最大坐标值
        return maxCoordinateValue;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 输入
        int n = scanner.nextInt();  // 指令的总个数
        int m = scanner.nextInt();  // 幸运数
        int[] instructions = new int[n];  // n个指令

        // 读取指令
        for (int i = 0; i < n; i++) {
            instructions[i] = scanner.nextInt();
        }

        // 输出
        System.out.println(maxCoordinate(n, m, instructions));

        scanner.close();
    }
}
~~~

