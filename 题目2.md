# 题目2

## 1.来自异国的客人

#### 🎃题目描述

> 有位客人来自异国，在该国使用m进制计数。该客人有个幸运数字 n(n<m)，每次购物时，其总是喜欢计算本次支付的花费(折算为异国的价格后)中存在多少幸运数字。问：当其购买一个在我国价值k的产品时， 其中包含多少幸运数字?

------

#### 🎃输入输出

> 输入
> 第一行输入为：k，n，m
>  
> 其中：
> k表示：该客人购买的物品价值(以十进制计算的价格)
> n表示：该客人的幸运数字
> m表示：该客人所在国度的采用的进制
>  
> 输出
> 输出幸运数字的个数
>  
> 补充说明:
> 当输入非法内容时，输出0

------

#### 🎃样例1

```java
输入
10 2 4

输出
2

说明: 
10用4进制表示时为22,同时，异国客人的幸运数字是2，故而此处输出为2,表示有2个幸运数字。
12345678
```

------

#### 🎃样例2

```java
输入
10 4 4


输出
0

说明:
此时客人的幸运数字为4,但是由于该国最大为4进制,故而在该国的进制下不可能出现幸运数字,故而返回0
123456789
```

------

### 二、思路参考

------

将十进制转为其他进制的一般思路如下：

1. 确定目标进制：确定要将十进制转换为哪种进制，常见的有二进制（base-2）、八进制（base-8）和十六进制（base-16）。
2. 除以目标进制的基数：将十进制数依次除以目标进制的基数，并记录余数。例如，对于二进制，基数为2；对于八进制，基数为8；对于十六进制，基数为16。
3. 重复步骤2直到商为0：重复上述步骤直到十进制数的商为0。每次得到的余数按照从低位到高位的顺序记录下来。
4. 反转余数序列：将步骤3中得到的余数序列反转，得到最终的转换结果。
5. 对于十六进制：如果转换为十六进制，需要将余数序列中的10-15分别表示为A-F，分别对应于十进制数10-15。

以将十进制数27转换为二进制为例：

1. 目标进制为二进制，基数为2。
2. 27 ÷ 2 = 13，余数为1。
   13 ÷ 2 = 6，余数为0。
   6 ÷ 2 = 3，余数为0。
   3 ÷ 2 = 1，余数为1。
   1 ÷ 2 = 0，余数为1。
3. 商为0，停止计算。
4. 反转余数序列，得到11011，即27的二进制表示为11011。

对于其他进制的转换，思路类似，只需要将基数和转换结果的符号调整为对应的进制即可。

------

1. 首先，我们定义了一个函数`convertToBase`，它将一个整数转换为指定进制的字符串。该函数使用了循环和取余操作来计算每个位上的数字，并将其转换为对应的字符。然后，我们通过反转字符串的方式得到了正确的进制表示。
2. 接下来，我们定义了一个函数`countOccurrences`，它计算字符串中特定数字出现的次数。该函数遍历字符串中的每个字符，将其转换为数字并与目标数字进行比较，如果相等则计数器加一。
3. 然后，我们定义了一个函数`countLuckyNumber`，它计算幸运数字在给定进制表示中出现的次数。该函数首先检查输入的合法性，然后将给定的整数转换为指定进制表示的字符串。接下来，使用`countOccurrences`函数计算幸运数字在该字符串中出现的次数。
4. 最后，在`main`函数中，我们使用`Scanner`从标准输入读取三个整数k、n和m。然后，调用`countLuckyNumber`函数计算幸运数字的个数，并将结果输出到标准输出。如果输入不合法，则输出0。

------

### 三、代码参考

```java
import java.util.Scanner;

public class Main {
    // 函数将整数num转换为base进制的字符串
    public static String convertToBase(int num, int base) {
        // 预估结果字符串的最大长度，每个数字至少占一个字符，加上一个字符用于字符串的结束符'\0'
        int max_length = Integer.SIZE / 8 + 1;
        char[] result = new char[max_length];

        int i = 0;
        do {
            int remainder = num % base;
            result[i++] = (char) ('0' + remainder); // 假设base小于10
            num /= base;
        } while (num > 0);

        result[i] = '\0'; // 添加字符串结束符

        // 反转字符串
        for (int j = 0; j < i / 2; j++) {
            char temp = result[j];
            result[j] = result[i - j - 1];
            result[i - j - 1] = temp;
        }

        return new String(result);
    }

    // 函数计算字符串value中数字lucky出现的次数
    public static int countOccurrences(String value, int lucky) {
        int count = 0;
        for (char c : value.toCharArray()) {
            if (c - '0' == lucky) {
                count++;
            }
        }
        return count;
    }

    public static int countLuckyNumber(int k, int n, int m) {
        // 检查输入是否非法
        if (k < 0 || n < 0 || m <= 1 || n >= m) {
            return 0;
        }

        // 将k转换为m进制
        String mBasedValue = convertToBase(k, m);

        // 计算幸运数字n在m进制表示中出现的次数
        int occurrences = countOccurrences(mBasedValue, n);

        return occurrences;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        if (scanner.hasNextInt()) {
            int k = scanner.nextInt();
            int n = scanner.nextInt();
            int m = scanner.nextInt();

            // 输出幸运数字的个数
            System.out.println(countLuckyNumber(k, n, m));
        } else {
            // 输入不合法
            System.out.println("0");
        }

        scanner.close();
    }
}

```



## 2。电脑病毒感染 

#### 🎃题目描述

> 一个局域网内有很多台电脑，分别标注为0 - N-1的数字。相连接的电脑距离不一样，所以感染时间不一样，感染时间用t表示。
> 其中网络内一个电脑被病毒感染，其感染网络内所有的电脑需要最少需要多长时间。如果最后有电脑不会感染，则返回-1，给定一个数组 times表示 一个电脑把相邻电脑感染所用的时间
>  
> 如： path[ i ]= {i，j，t}，表示电脑 -> j ，电脑 i 上的病毒感染j，需要时间 t

------

#### 🎃输入输出

> 输入
> 第一行输入N，表示局域网的电脑个数
> 第二行，表示多少条网络连接
>  
> 输出
> 电脑感染所用的时间

------

#### 🎃样例1

```java
输入
4
3
2 1 1
2 3 1
3 4 1
2

输出
2
12345678910
```

------

### 二、思路参考

------

首先，根据输入构建图的邻接表表示。然后，初始化一个距离数组，所有的距离初始化为无穷大，将起点的距离初始化为0。接下来，使用堆（优先队列）来得到当前最短的感染时间。将起点加入堆中，并开始循环，直到堆为空。在循环中，从堆中弹出当前最短的感染时间和对应的节点。如果当前的时间比已知的感染时间大，则不用继续处理该节点。否则，遍历当前节点的所有相邻节点，如果通过当前节点感染相邻节点的时间更短，则更新时间，并将相邻节点和时间加入堆中。最后，检查是否所有电脑都被感染，如果是，返回最大的感染时间；否则，返回-1。

------

### 三、代码参考

```java
import java.util.*;

class Main {
    static class Edge {
        int to;
        int weight;

        public Edge(int to, int weight) {
            this.to = to;
            this.weight = weight;
        }
    }

    public static int networkDelayTime(List<int[]> times, int N, int K) {
        // 构建图的邻接表表示
        Map<Integer, List<Edge>> graph = new HashMap<>(); // 使用HashMap来存储邻接表
        for (int i = 1; i <= N; i++) {
            graph.put(i, new ArrayList<>()); // 初始化邻接表
        }

        for (int[] time : times) {
            int u = time[0]; // 边的起点
            int v = time[1]; // 边的终点
            int w = time[2]; // 边的权重
            graph.get(u).add(new Edge(v, w)); // 将边添加到起点的邻接表中
        }

        // 初始化距离数组，所有的距离初始化为无穷大
        // 将起点的距离初始化为0
        Map<Integer, Integer> dist = new HashMap<>();
        for (int i = 1; i <= N; i++) {
            dist.put(i, Integer.MAX_VALUE);
        }
        dist.put(K, 0);

        // 使用堆（优先队列）来得到当前最短的感染时间
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        heap.offer(new int[]{0, K}); // 将起点加入堆中
        while (!heap.isEmpty()) {
            int[] curr = heap.poll(); // 弹出堆顶元素，即当前最短的感染时间和对应的节点
            int time = curr[0]; // 当前的感染时间
            int node = curr[1]; // 当前的节点

            // 如果当前的时间比已知的感染时间大，那么就不用继续处理
            if (time > dist.get(node)) {
                continue;
            }

            for (Edge edge : graph.get(node)) {
                int v = edge.to; // 相邻节点
                int w = edge.weight; // 边的权重

                // 如果通过当前节点感染相邻节点的时间更短，则更新时间
                if (time + w < dist.get(v)) {
                    dist.put(v, time + w);
                    heap.offer(new int[]{dist.get(v), v}); // 将更新后的节点和时间加入堆中
                }
            }
        }

        // 最后检查是否所有电脑都被感染，如果是，返回最大的感染时间
        int maxDist = Collections.max(dist.values());
        return maxDist < Integer.MAX_VALUE ? maxDist : -1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt(); // 电脑数量
        int connections = scanner.nextInt(); // 连接数量
        List<int[]> times = new ArrayList<>(); // 存储连接信息的列表
        for (int i = 0; i < connections; i++) {
            int u = scanner.nextInt(); // 边的起点
            int v = scanner.nextInt(); // 边的终点
            int w = scanner.nextInt(); // 边的权重
            times.add(new int[]{u, v, w}); // 将连接信息添加到列表中
        }
        int K = scanner.nextInt(); // 起点

        // 计算输出
        System.out.println(networkDelayTime(times, N, K));
        scanner.close();
    }
}
```



## 3.项目排期 、最快完成所有工作的天数 

#### 🎃题目描述

> 项目组共有N个开发人员，项目经理接到了M个独立的需求，每个需求的工作量不同，且每个需求只能由一个开发人员独立完成， 不能多人合作。假定各个需求直接无任何先后依赖关系，请设计算法帮助项目经理进行工作安排，使整个项目能用最少的时间交付

------

#### 🎃输入输出

> 输入
> 第一行输入为M个需求的工作量，单位为天， 用逗号隔开。
> 例如: X1，X2 ，X3… Xm
> 表示共有M个需求，每个需求的工作量分别为X1天，X2天… Xm天。 其中0<M<30； 0<Xm<200
> 第二行输入为项目组人员数量N，例如：表示共有5名员工，其中0<N<10
>  
> 输出
> 最快完成所有工作的天数

------

#### 🎃样例1

```java
输入
6 2 7 7 9 3 2 1 3 11 4
2

输出
28

说明:
共有两位员工，其中一位分配需求6 2 7 7 3 2 1共需要28天完成，另一位分配需求9 3 11 4共需要27天完成，故完成所有工作至少需要28天。
123456789
```

------

### 二、思路参考

------

1、首先，根据输入将需求的工作量存储在一个整型数组中。

2、然后，根据输入的项目组人员数量进行计算。

3、接下来，对工作量数组进行排序，按照降序排列，这样工作量较大的需求会被优先分配。

4、然后，初始化一个长度为项目组人员数量的整型数组，用于存储每个员工的工作量。

5、接着，使用贪心算法将每个需求分配给当前工作量最小的员工，即将工作量最小的员工分配给工作量最大的需求。

6、最后，找出工作量最大的员工，即为完成所有工作需要的最短天数。

------

### 三、代码参考

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        // 输入需求的工作量
        Scanner scanner = new Scanner(System.in);
        String[] input = scanner.nextLine().split(" ");
        int[] workloads = new int[input.length];
        for (int i = 0; i < input.length; i++) {
            workloads[i] = Integer.parseInt(input[i]);
        }

        // 输入项目组人员数量
        int N = scanner.nextInt();

        // 计算并输出结果
        int minDays = calculateMinimumDays(workloads, N);
        System.out.println(minDays);
    }

    // 计算完成所有工作的最短天数
    public static int calculateMinimumDays(int[] workloads, int N) {
        // 先对工作量进行降序排序，使得较大的工作量先被分配
        Arrays.sort(workloads);

        // 初始化每个员工的工作量数组
        int[] developers = new int[N];

        // 遍历所有工作量，贪心算法分配给当前工作量最小的员工
        for (int i = workloads.length - 1; i >= 0; i--) {
            int minWorkload = developers[0];
            int minIndex = 0;
            for (int j = 1; j < N; j++) {
                if (developers[j] < minWorkload) {
                    minWorkload = developers[j];
                    minIndex = j;
                }
            }
            // 分配工作，并更新该员工的总工作量
            developers[minIndex] += workloads[i];
        }

        // 找出工作量最大的员工，即为完成所有工作需要的最短天数
        int minDays = developers[0];
        for (int i = 1; i < N; i++) {
            if (developers[i] > minDays) {
                minDays = developers[i];
            }
        }
        return minDays;
    }
}
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354
```



## 4.虚拟游戏理财

#### 🎃题目描述

> 在一款虚拟游戏中生活，你必须进行投资以增强在虚拟游戏中的资产以免被淘汰出局。现有一家 Bank，它提供有若干理财产品 m，风险及投资回报不同，你有 N（元）进行投资，能接受的总风险值为 X。
>  
> 你要在可接受范围内选择最优的投资方式获得最大回报。
>  
> 说明：
>  
> 1、在虚拟游戏中，每项投资风险值相加为总风险值；
>  
> 2、在虚拟游戏中，最多只能投资 2 个理财产品；
>  
> 3、在虚拟游戏中，最小单位为整数，不能拆分为小数；
>  
> 投资额*回报率=投资回报

------

#### 🎃输入输出

> 输入
> 第一行：产品数(取值范围[1, 20])，总投资额(整数，取值范围[1, 10000])，可接受的总风险(整数，取值范围[1, 200])
>  
> 第二行：产品投资回报率序列，输入为整数，取值范围[1,60]
>  
> 第三行：产品风险值序列，输入为整数，取值范围[1,100]
>  
> 第四行：最大投资额度序列，输入为整数，取值范围[1,10000]
>  
> 输出
> 每个产品的投资额序列

------

#### 🎃样例1

```java
输入
5 100 10
10 20 30 40 50
3 4 5 6 10
20 30 20 40 30


输出
0 30 0 40 0


说明:
投资第二项 30 个单位，第四项 40 个单位，总的投资风险为两项相加为 4+6=10
12345678910111213
```

------

### 二、思路参考

------

1、首先，读取输入数据，包括产品数量、总投资额、最大可接受风险、每个产品的回报率、风险值和最大投资额度。

2、然后，定义一个函数`findBestInvestment`来寻找最佳投资组合。该函数接受产品数量m、总投资额N、最大可接受风险X、每个产品的回报率returns、风险值risks和最大投资额度maxInvestments作为参数。

3、在函数内部，首先初始化最佳投资额度数组`bestInvestment`，并将每个元素初始化为0。然后初始化最大回报为0。

4、接下来，使用双重循环遍历所有产品，尝试所有可能的投资组合。循环变量`i`和`j`分别表示两个产品的索引。

5、对于每一对产品，如果它们的风险之和不超过最大可接受风险X，则计算在风险限制内，对第i个产品的最大可能投资额度`investI`，以及在剩余投资额度和第j个产品的最大投资额度中，对第j个产品的实际投资额度`investJ`。

6、然后，计算这种投资组合的总回报`currentReturn`，即将第i个产品的投资额度乘以其回报率，再加上第j个产品的投资额度乘以其回报率。

7、如果当前回报大于已知的最大回报，则更新最大回报和最佳投资组合。将最佳投资数组`bestInvestment`重置为0，并更新第i个产品和第j个产品的投资额度。

8、最后，返回最佳投资组合的投资额度数组`bestInvestment`。

9、最终，在主函数中调用`findBestInvestment`函数，并输出最佳投资组合的投资额度。

------

### 三、代码参考

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // 读取输入数据
        Scanner scanner = new Scanner(System.in);
        int productCount = scanner.nextInt();  // 读取产品数量
        int totalInvestment = scanner.nextInt();  // 读取总投资额
        int maxRisk = scanner.nextInt();  // 读取最大可接受风险
        int[] returns = new int[productCount];  // 读取每个产品的回报率
        int[] risks = new int[productCount];  // 读取每个产品的风险值
        int[] maxInvestments = new int[productCount];  // 读取每个产品的最大投资额度
        for (int i = 0; i < productCount; i++) {
            returns[i] = scanner.nextInt();
        }
        for (int i = 0; i < productCount; i++) {
            risks[i] = scanner.nextInt();
        }
        for (int i = 0; i < productCount; i++) {
            maxInvestments[i] = scanner.nextInt();
        }

        // 计算最佳投资组合
        int[] investmentAmounts = findBestInvestment(productCount, totalInvestment, maxRisk, returns, risks, maxInvestments);

        // 输出最佳投资组合的投资额度
        for (int i = 0; i < productCount; i++) {
            System.out.print(investmentAmounts[i] + " ");
        }
    }

    // 定义寻找最佳投资组合的函数
    public static int[] findBestInvestment(int m, int N, int X, int[] returns, int[] risks, int[] maxInvestments) {
        // 初始化最佳投资额度数组
        int[] bestInvestment = new int[m];
        // 初始化最大回报为0
        int maxReturn = 0;

        // 对所有产品进行双重循环，尝试所有可能的投资组合
        for (int i = 0; i < m; i++) {
            for (int j = i; j < m; j++) {  // 从i开始，避免重复计算
                // 如果两个产品的风险之和不超过最大可接受风险X
                if (risks[i] + risks[j] <= X) {
                    // 计算在风险限制内，对第i个产品的最大可能投资额度
                    int investI = Math.min(N, maxInvestments[i]);
                    // 计算在剩余投资额度和第j个产品的最大投资额度中，对第j个产品的实际投资额度
                    int investJ = Math.min(N - investI, maxInvestments[j]);

                    // 计算这种投资组合的总回报
                    int currentReturn = investI * returns[i] + investJ * returns[j];

                    // 如果当前回报大于已知的最大回报，则更新最大回报和最佳投资组合
                    if (currentReturn > maxReturn) {
                        maxReturn = currentReturn;
                        bestInvestment = new int[m];  // 重置最佳投资数组
                        bestInvestment[i] = investI;  // 更新第i个产品的投资额度
                        bestInvestment[j] = investJ;  // 更新第j个产品的投资额度
                    }
                }
            }
        }

        // 返回最佳投资组合的投资额度数组
        return bestInvestment;
    }
}
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566
```



## 5.石头剪刀布游戏

#### 🎃题目描述

> 石头剪刀布游戏有 3 种出拳形状：石头、剪刀、布。分别用字母 A , B , C 表示。
>  
> 游戏规则:
>  
> 出拳形状之间的胜负规则如下： A > B；B > C；C > A；">"左边一个字母，表示相对优势形状。右边一个字母，表示相对劣势形状。
>  
> 当本场次中有且仅有一种出拳形状优于其它出拳形状，则该形状的玩家是胜利者。否则认为是平局。
>  
> 当发生平局，没有赢家。有多个胜利者时，同为赢家。
>  
> 例如 1： 三个玩家出拳分别是A, B, C ，由于出现三方优势循环(即没有任何一方优于其它出拳者)，判断为平局。
>  
> 例如 2： 三个玩家，出拳分别是 A, B ，出拳 A 的获胜。
>  
> 例如 3： 三个玩家，出拳全部是 A ，判为平局。

------

#### 🎃输入输出

> 输入
> 在一场游戏中，每个玩家的信息为一行。玩家数量不超过 1000 。每个玩家信息有 2 个字段，用空格隔开：
>  
> 1、玩家 ID：一个仅由英文字母和数字组成的字符串
> 2、出拳形状：以英文大写字母表示, A 、B 、C 形状。
>  
> 例：
> abc1 A
> xyz B
> 解释：玩家 abc1 出拳为石头( A )。玩家 xyz 出拳为剪刀( B )
>  
> 输出
> 输出为赢家的玩家 ID 列表(一个或多个)，每个 ID 一行，按字符串升序排列。如果没有赢家，输出为"NULL"字符串。例如：abc1

------

#### 🎃样例1

```java
输入
abc1 A
xyz B


输出
abc1


说明:
A 比 B 有优势，abc1 胜出
1234567891011
```

------

#### 🎃样例2

```java
输入
abc1 A
xyz A



输出
NULL


说明:
没有优胜的出拳形状，平局
123456789101112
```

------

#### 🎃样例3

```java
输入
abc1 A
def A
alic A
xyz B


输出
abc1
alic
def

说明:
A 为优胜方，有三个赢家。
1234567891011121314
```

------

### 二、思路参考

------

1. 导入所需的类和包。
2. 创建一个`Scanner`对象，用于从标准输入读取数据。
3. 创建一个`HashMap`，用于存储每种出拳形状对应的玩家ID列表。
4. 使用`put`方法初始化`HashMap`，将出拳形状（A、B、C）作为键，对应的空列表作为值。
5. 使用`while`循环读取输入，直到输入为空行。
6. 在每次循环迭代中，读取一行输入并将其分割成玩家ID和出拳形状。
7. 将玩家ID添加到对应出拳形状的玩家ID列表中。
8. 调用`determineWinner`函数来确定优胜的出拳形状的玩家ID列表。
9. 如果优胜的出拳形状的玩家ID列表为空，表示平局，输出"NULL"。
10. 否则，对优胜的出拳形状的玩家ID列表进行排序，并逐行输出。
11. 程序结束。

`determineWinner`函数的详细思路如下：

1. 接收一个`Map`对象，其中键是出拳形状，值是对应的玩家ID列表。
2. 如果只有一种出拳形状，或者三种出拳形状都有玩家，则返回一个空列表，表示平局。
3. 否则，获取出拳形状的列表。
4. 根据出拳形状列表的情况，确定优胜的出拳形状。
   - 如果A和B出拳形状都有玩家，则优胜的出拳形状为A。
   - 如果只有B出拳形状有玩家，则优胜的出拳形状为B。
   - 否则，优胜的出拳形状为C。
5. 获取优胜的出拳形状的玩家ID列表。
6. 对玩家ID列表进行排序，并返回该列表。

------

### 三、代码参考

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

public class RockPaperScissors {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Map<String, List<String>> playersByShape = new HashMap<>(); // 创建一个存储玩家ID列表的字典，以出拳形状作为键
        playersByShape.put("A", new ArrayList<>()); // 初始化A出拳形状的玩家ID列表
        playersByShape.put("B", new ArrayList<>()); // 初始化B出拳形状的玩家ID列表
        playersByShape.put("C", new ArrayList<>()); // 初始化C出拳形状的玩家ID列表

        while (scanner.hasNextLine()) { // 持续读取输入
            String input = scanner.nextLine(); // 读取一行输入
            if (input.isEmpty()) { // 如果输入为空行，结束循环
                break;
            }
            String[] tokens = input.split(" "); // 将输入按空格分割成玩家ID和出拳形状
            String playerId = tokens[0]; // 提取玩家ID
            String shape = tokens[1]; // 提取出拳形状
            playersByShape.get(shape).add(playerId); // 将玩家ID添加到对应出拳形状的列表中
        }

        List<String> winners = determineWinner(playersByShape); // 调用函数来确定赢家
        if (winners.isEmpty()) { // 如果赢家列表为空，表示平局
            System.out.println("NULL");
        } else {
            for (String winner : winners) { // 输出赢家列表中的每个玩家ID
                System.out.println(winner);
            }
        }
    }

    private static List<String> determineWinner(Map<String, List<String>> playersByShape) {
        if (playersByShape.values().stream().filter(players -> !players.isEmpty()).count() != 2) {
            return new ArrayList<>(); // 如果只有一种出拳形状，或者三种出拳形状都有玩家，则返回空列表，表示平局
        }

        List<String> shapes = new ArrayList<>(playersByShape.keySet()); // 获取出拳形状的列表
        String winningShape = "";
        if (shapes.contains("A") && shapes.contains("B")) { // 如果A和B出拳形状都有玩家，则优胜的出拳形状为A
            winningShape = "A";
        } else if (shapes.contains("B")) { // 如果只有B出拳形状有玩家，则优胜的出拳形状为B
            winningShape = "B";
        } else {
            winningShape = "C"; // 如果只有C出拳形状有玩家，则优胜的出拳形状为C
        }

        List<String> winners = playersByShape.get(winningShape); // 获取优胜出拳形状的玩家ID列表
        winners.sort(String::compareTo); // 对玩家ID列表进行升序排序
        return winners; // 返回优胜出拳形状的玩家ID列表
    }
}

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556
```



## 6.部门人力分配

#### 🎃题目描述

> 部门在进行需求开发时需要进行人力安排。当前部门需要完成 N 个需求，需求用 requirements表示，requirements[i] 表示第 i 个需求的工作量大小，单位：人月。这部分需求需要在 M 个月内完成开发，进行人力安排后每个月的人力是固定的。
>  
> 目前要求每个月最多有 2 个需求开发，并且每个月需要完成的需求不能超过部门人力。请帮部门评估在满足需求开发进度的情况下，每个月需要的最小人力是多少？

------

#### 🎃输入输出

> 输入
> 输入第一行为 M ，M 表示需要开发时间要求
> 输入第二行为 requirements ，requirements 表示每个需求工作量大小，N为requirements 长度
>  
> 输出
> 输出部门需要人力需求

------

#### 🎃样例1

```java
输入
3
3 5 3 4


输出
6


说明:
第一行输入数据 3 表示开发时间要求，第二行输入数据表示需求工作量大小，输出数据一行，表示部门人力需求。

当选择人力为6时，2个需求量为3的工作可以在1个月里完成，其他2个工作各需要1个月完成。可以在3个月内完成所有需求。

当选择人力为5时，4个工作各需要1个月完成，一共需要4个月才能完成所有需求。

因此6是部门最小的人力需求。
1234567891011121314151617
```

------

### 二、思路参考

------

1. 首先，读取输入的开发时间 `developmentTime` 和工作量列表 `workloads`。

2. 对工作量列表 `workloads` 进行降序排序。

3. 设置最小人力需求的范围，初始范围为最大工作量 `workloads[0]` 和所有工作量之和 `Arrays.stream(workloads).sum()`。

4. 使用二分搜索来找到满足需求开发进度的最小人力需求。循环条件为 `left < right`。

5. 在每次循环中，计算当前人力 `mid` 能在多少个月内完成所有工作。初始化 `months` 为 0，表示完成所有工作所需的月数；初始化 `total` 为 0，表示当前月的累计工作量。

6. 遍历工作量列表

    

   ```
   workloads
   ```

   ，对于每个工作量

    

   ```
   workload
   ```

   ：

   - 如果当前月的累计工作量加上 `workload` 大于 `mid`，则表示需要开始新的一个月，即 `months += 1`，并将累计工作量重置为 0。
   - 否则，将当前工作量 `workload` 累加到累计工作量 `total` 中。

7. 如果最后还有工作量没有完成，则需要增加一个月，即 `months += 1`。

8. 判断当前人力是否能满足开发时间要求：

   - 如果 `months <= developmentTime`，表示当前人力可以满足开发时间要求，将 `right` 更新为 `mid`，即可尝试减少人力。
   - 否则，表示当前人力不满足开发时间要求，将 `left` 更新为 `mid + 1`，即需要增加人力。

9. 循环结束后，返回最小人力需求 `left`，即为满足要求的最小人力需求。

------

### 三、代码参考

```java
import java.util.Arrays;
import java.util.Scanner;
import java.util.stream.Collectors;

public class Main {
    // 计算最小人力需求的函数
    public static int minManpower(int developmentTime, int[] workloads) {
        // 对工作量进行降序排序
        Arrays.sort(workloads);
        // 使用Lambda表达式逆序数组
        reverse(workloads);

        // 至少需要最大工作量那么多的人力
        int left = workloads[0];
        // 最多需要所有工作量之和那么多的人力
        int right = Arrays.stream(workloads).sum();

        // 二分搜索最小人力需求
        while (left < right) {
            int mid = (left + right) / 2;
            int months = 0; // 记录完成所有工作所需的月数
            int total = 0;  // 记录当前月的累计工作量

            // 计算当前人力能在几个月内完成所有工作
            for (int workload : workloads) {
                if (total + workload > mid) {
                    months += 1; // 开始新的一个月
                    total = 0;   // 重置累计工作量
                }
                total += workload; // 累加工作量
            }
            if (total > 0) { // 如果最后还有工作量没有完成，则还需要一个月
                months += 1;
            }

            // 判断当前人力是否能满足开发时间要求
            if (months <= developmentTime) {
                right = mid; // 可以尝试减少人力
            } else {
                left = mid + 1; // 需要增加人力
            }
        }

        return left; // 返回最小人力需求
    }

    // 逆序数组的函数
    private static void reverse(int[] array) {
        for (int i = 0; i < array.length / 2; i++) {
            int temp = array[i];
            array[i] = array[array.length - 1 - i];
            array[array.length - 1 - i] = temp;
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取输入的开发时间
        int developmentTime = scanner.nextInt();
        scanner.nextLine(); // 读取整数后的换行符

        // 读取输入的工作量列表
        String[] workloadStrings = scanner.nextLine().trim().split("\\s+");
        int[] workloads = new int[workloadStrings.length];
        for (int i = 0; i < workloadStrings.length; i++) {
            workloads[i] = Integer.parseInt(workloadStrings[i]);
        }

        // 输出最小人力需求
        System.out.println(minManpower(developmentTime, workloads));
    }
}

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374
```



## 7.机场航班调度

#### 🎃题目描述

> XX市机场停放了多架飞机，每架飞机都有自己的航班号CA3385，CZ6678, SC6508等，航班号的前2个大写字母(或数字)代表航空公司的缩写，后面4个数字代表航班信息。
>  
> 但是XX市机场只有一条起飞用跑道，调度人员需要安排目前停留在机场的航班有序起飞。为保障航班的有序起飞，调度员首先按照航空公司的缩写(航班号前2个字母)对所有航班进行排序，同一航空公司的航班再按照航班号的后4个数字进行排序最终获得安排好的航班的起飞顺序。
>  
> 请编写一段代码根据输入的航班号信息帮助调度员输出航班的起飞顺序。航空公司缩写排序按照从特殊符号$&*, 0~9， A ~Z排序

------

#### 🎃输入输出

> 输入
> 第一行输入航班信息，多个航班号之间用逗号(", ”)分隔，输入的航班号不超过100个例如：
> CA3385，CZ6678， SC6508，DU7523，HK4456 ，MK0987
>  
> 备注:：航班号为6位长度，后4位为纯数字，不考虑存在后4位重复的场景
>  
> 输出
> 航班的起飞顺序

------

#### 🎃样例1

```java
输入
CA3385,CZ6678,SC6508,DU7523,HK4456,MK0987


输出
CA3385,CZ6678,DU7523,HK4456,MK0987,SC6508


说明:
输入目前停留在该机场的航班号,输出为按照调度排序后输出的有序的航班号
12345678910
```

------

#### 🎃样例2

```java
输入
MU1087,CA9908,3U0045,FM1703



输出
3U0045,CA9908,FM1703,MU1087
1234567
```

------

### 二、思路参考

------

1. 首先定义一个函数 `sortFlights`，接受一个字符串数组 `flights` 作为参数，表示航班信息。
2. 使用 `Arrays.sort` 方法对航班信息进行排序，传入一个自定义的 `Comparator` 对象。
3. 在 `Comparator` 对象中，实现 `compare` 方法来定义排序规则。首先按照航空公司的缩写进行排序，使用 `substring` 方法截取航空公司缩写的部分，并使用 `compareTo` 方法进行比较。
4. 如果航空公司的缩写相同，则按照航班号的数字进行排序。使用 `substring` 方法截取航班号的数字部分，并使用 `Integer.parseInt` 方法将其转换为整数进行比较。
5. 返回排序后的航班信息数组。
6. 在 `main` 方法中，首先使用 `Scanner` 类从标准输入读取航班信息。
7. 对输入的航班信息进行去除两端的空白字符处理，使用 `trim` 方法去除空白字符，并使用 `split` 方法将输入字符串拆分为航班信息数组。
8. 调用 `sortFlights` 函数对航班信息进行排序，获取排序后的航班信息数组。
9. 使用 `String.join` 方法将排序后的航班信息数组连接为一个字符串，并使用 `System.out.println` 方法输出结果。

------

### 三、代码参考

```java
// 导入需要的类
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Main {
    // 定义一个函数来对航班号进行排序
    public static String[] sortFlights(String[] flights) {
        // 使用Comparator来定义排序规则
        Arrays.sort(flights, new Comparator<String>() {
            @Override
            public int compare(String flight1, String flight2) {
                // 首先按照航空公司的缩写进行排序
                int cmp = flight1.substring(0, 2).compareTo(flight2.substring(0, 2));
                if (cmp != 0) {
                    return cmp;
                }
                // 如果航空公司的缩写相同，则按照航班号的数字进行排序
                int flightNum1 = Integer.parseInt(flight1.substring(2));
                int flightNum2 = Integer.parseInt(flight2.substring(2));
                return Integer.compare(flightNum1, flightNum2);
            }
        });
        return flights;
    }

    public static void main(String[] args) {
        // 输入航班信息
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        // 对输入的航班信息进行去除两端的空白字符处理
        String[] inputFlights = input.trim().split(",");
        inputFlights = Arrays.stream(inputFlights)
                .map(String::trim)
                .toArray(String[]::new);
        // 调用排序函数获取排序后的航班信息
        String[] sortedFlights = sortFlights(inputFlights);
        // 输出排序后的航班起飞顺序，用逗号连接
        System.out.println(String.join(",", sortedFlights));
    }
}
1234567891011121314151617181920212223242526272829303132333435363738394041
```



## 8.连续字母长度

#### 🎃题目描述

> 给定一个字符串，只包含大写字母，求在包含同一字母的子串中，长度第k长的子串的长度，相同字母只取最长的那个子串

------

#### 🎃输入输出

> 输入
> 第一行有一个子串(1<长度<=100)，只包含大写字母
> 第二行为k的值
>  
> 输出
> 输出连续出现次数第k多的字母的次数

------

#### 🎃样例1

```java
输入
AAAAHHHBBCDHHHH
3


输出
2


说明:
同一字母连续出现的最多的是A和H,出现四次;
第二多的是H, 3次,但是H已经存在4个连续的,故不考虑;
下个最长子串是BB，所以最终答案应该输出2
12345678910111213
```

------

#### 🎃样例2

```java
输入
AABAAA
2


输出
1

说明：
同一字母连续出现的最多的是A,三次;
第二多的还是A,两次,但A已经存在最大连续次数三次,故不考虑;
下个最长子串是B,所以输出1

12345678910111213
```

------

#### 🎃样例3

```java
输入
ABC
4


输出
-1
1234567
```

------

#### 🎃样例4

```java
输入
HHHHHHHHH
5


输出
-1
1234567
```

------

#### 🎃样例5

```java
输入
AAABBBCCC
2


输出
3
1234567
```

------

#### 🎃样例6

```java
输入
ABBBCCCCCDDDDEEEEEE
4


输出
3
1234567
```

------

#### 🎃样例7

```java
输入
AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ
10


输出
2
1234567
```

------

#### 🎃样例8

```java
输入
AAABBBCCCDDDEEEFFFGGGHHHIIIIJJJKKKLLLMMMNNNNOOO
3


输出
3
1234567
```

------

#### 🎃样例9

```java
输入
AAAABBBBCCCCDDDDDEEEEEFFFFFGGGGGHHHHHIIIIIJJJJJ
2


输出
5
1234567
```

------

#### 🎃样例10

```java
输入
ABCDEFGHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
1


输出
36
```

### 二、思路参考

------

1. 创建一个HashMap（maxCounts），用于存储每个字符的最长连续出现次数。

2. 初始化当前连续子串的字母和长度，将字符串的第一个字符作为当前字符（currentChar），将计数器初始化为1（currentCount）。

3. 遍历字符串，从第二个字符开始。将每个字符与当前字符进行比较，如果相同则增加计数器（currentCount），否则说明当前连续子串结束，更新最长连续出现次数：

   a. 如果当前字符不在maxCounts中，或者当前计数器的值大于maxCounts中存储的值，则将当前计数器的值存储在maxCounts中。

   b. 重置当前连续子串的字母和长度，将当前字符更新为遍历到的字符，将计数器重置为1。

4. 将maxCounts中的值转换为一个int数组（sortedCounts），并按照升序排序。

5. 根据给定的k值，判断k是否小于等于sortedCounts数组的长度。如果是，则返回sortedCounts中倒数第k个元素（即第k长的子串长度）；否则，返回-1，表示没有第k长的子串。

最后，在main方法中读取输入，调用findKthLongestSubstring函数并输出结果。

------

### 三、代码参考

```java
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {
    public static int findKthLongestSubstring(String s, int k) {
        // 存储每个字母的最长连续出现次数
        Map<Character, Integer> maxCounts = new HashMap<>();

        // 当前连续子串的字母和长度
        char currentChar = s.charAt(0);
        int currentCount = 1;

        // 遍历字符串，找到每个字母的最长连续出现次数
        for (int i = 1; i < s.length() + 1; i++) {
            char c = (i == s.length()) ? '#' : s.charAt(i);
            if (c == currentChar) {
                currentCount++; // 如果字符与当前字符相同，则增加计数
            } else {
                // 如果字符不同，说明当前连续子串结束，更新最长出现次数
                if (!maxCounts.containsKey(currentChar) || currentCount > maxCounts.get(currentChar)) {
                    maxCounts.put(currentChar, currentCount);
                }

                // 重置当前连续子串的字母和长度
                currentChar = c;
                currentCount = 1;
            }
        }

        // 将最长连续出现次数按照次数降序排列
        int[] sortedCounts = maxCounts.values().stream().mapToInt(Integer::intValue).sorted().toArray();

        // 根据k值获取第k长的子串长度
        // 如果k值大于排序后的数组长度，则输出-1（表示没有第k长的子串）
        return (k <= sortedCounts.length) ? sortedCounts[sortedCounts.length - k] : -1;
    }

    public static void main(String[] args) {
        // 读取输入
        Scanner scanner = new Scanner(System.in);
        String inputString = scanner.nextLine().trim();
        int k = Integer.parseInt(scanner.nextLine().trim());

        // 调用函数并输出结果
        System.out.println(findKthLongestSubstring(inputString, k));
    }
}

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849
```



## 9.货车司机、高效货运

#### 🎃题目描述

> 老李是货运公司承运人，老李的货车额定载货重量为wt。
>  
> 现有两种货物，货物A单件重量为wa，单件运费利润为pa。货物B单件重量为wb，单件运费利润为pb。
>  
> 老李每次发车时载货总重量刚好为货车额定载货重量wt，车上必须同时有货物A和货物B，货物A、B 不可切割。
>  
> 老李单车次满载运输可获得的最高利润是多少？

------

#### 🎃输入输出

> 输入
> 输入一行五个正整数。
>  
> 第一个数字为货物A的单件重量wa，0<wa<10000
>  
> 第二个数字为货物B的单件重量wb，0<wb<10000
>  
> 第三个数字为货车的额定载重wt，0<wt<100000
>  
> 第四个数字为货物A的单件运费利润pa，0<pa<1000
>  
> 第五个数字为货物B的单件运费利润pb，0<pb<1000
>  
> 输出
> 单次满载运输的最高利润

------

#### 🎃样例1

```java
输入
10 8 36 15 7


输出
44

说明：
运送2个A货物，2个B货物。
123456789
```

------

#### 🎃样例2

```java
输入
1 1 2 1 1



输出
2
1234567
```

------

### 二、思路参考

------

1. 定义一个函数`calculateMaxProfit`，接收货物A的重量`wa`、货物B的重量`wb`、总重量上限`wt`、货物A的利润`pa`和货物B的利润`pb`作为参数。
2. 初始化最大利润`maxProfit`为0。
3. 考虑所有可能的装载方式，对货物A的数量进行遍历。从1开始，直到货物A的数量不超过`wt`除以`wa`的整数部分。
4. 对于每个货物A的数量，判断剩余重量`(wt - aCount * wa)`是否可以被货物B的重量`wb`整除。如果可以整除，则说明可以装载B货物。
5. 计算B货物的数量`bCount`，即剩余重量除以货物B的重量。
6. 如果B货物的数量大于0，则表示该装载方案可行，计算当前方案的利润`profit`，即货物A的数量乘以货物A的利润加上货物B的数量乘以货物B的利润。
7. 更新最大利润`maxProfit`，取当前利润`profit`和最大利润`maxProfit`中的较大值。
8. 遍历完所有可能的装载方案后，返回最大利润`maxProfit`。
9. 在`main`方法中，从标准输入读取货物A的重量、货物B的重量、总重量上限、货物A的利润和货物B的利润。
10. 调用`calculateMaxProfit`方法，传入读取的参数，计算最大利润。
11. 将最大利润输出到标准输出。

------

### 三、代码参考

```java
import java.util.Scanner;

public class Main {
    public static int calculateMaxProfit(int wa, int wb, int wt, int pa, int pb) {
        int maxProfit = 0;

        // 考虑所有可能的装载方式，对货物A的数量进行遍历
        for (int aCount = 1; aCount <= wt / wa; aCount++) {
            // 如果剩余重量可以被wb整除，则可以装载B货物
            if ((wt - aCount * wa) % wb == 0) {
                int bCount = (wt - aCount * wa) / wb;  // 计算B货物的数量
                if (bCount > 0) {  // 确保B货物数量大于0
                    int profit = aCount * pa + bCount * pb;  // 计算当前装载方案的利润
                    maxProfit = Math.max(maxProfit, profit);  // 更新最大利润
                }
            }
        }

        return maxProfit;  // 返回最大利润
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int wa = scanner.nextInt();  // 输入货物A的重量
        int wb = scanner.nextInt();  // 输入货物B的重量
        int wt = scanner.nextInt();  // 输入总重量上限
        int pa = scanner.nextInt();  // 输入货物A的利润
        int pb = scanner.nextInt();  // 输入货物B的利润
        scanner.close();

        System.out.println(calculateMaxProfit(wa, wb, wt, pa, pb));  // 输出最大利润
    }
}

12345678910111213141516171819202122232425262728293031323334
```



## 10.数的分解

#### 🎃题目描述

> 给定一个正整数n，如果能够分解为m(m > 1)个连续正整数之和，请输出所有分解中，m最小的分解
>  
> 如果给定整数无法分解为连续正整数，则输出字符串"N"。

------

#### 🎃输入输出

> 输入
> 输入数据为一整数，范围为(1, 2^30]
>  
> 输出
> 最小的分解

------

#### 🎃样例1

```java
输入
21


输出
21=10+11


说明:
21可以分解的连续正整数组合的形式有多种
21=1+2+3+4+5+6
21=6+7+8
21=10+11
因21=10+11,是最短的分解序列。所以答案是21=10+11
1234567891011121314
```

------

#### 🎃样例2

```java
输入
9


输出
9=4+5


说明:
9=2+3+4
9=4+5
1234567891011
```

------

#### 🎃样例3

```java
输入
1


输出
N
123456
```

------

#### 🎃样例4

```java
输入
15


输出
15=7+8

说明:
15=1+2+3+4+5
15=4+5+6
15=7+8
1234567891011
```

------

### 二、思路参考

------

1. 定义一个函数`findMinSequence`，接收一个正整数`n`作为参数。
2. 在循环中，从2到`n`之间的每个整数`m`，表示分解的个数。
3. 通过等差数列求和公式，计算出每个分解个数下的可能整数`x`的值，公式为`(n - m * (m - 1) / 2) / m`。
4. 判断`x`是否为正整数且大于0，即`x.is_integer()`和`x > 0`。
5. 如果满足条件，说明找到了最小的连续整数分解，构造分解序列的字符串表示。
6. 使用一个列表`sequence`来存储分解序列的每个整数，将每个整数转换为字符串并添加到`sequence`中。
7. 使用`join`函数将列表`sequence`中的每个元素按照"+"进行连接，得到分解序列的字符串表示。
8. 返回最终的结果字符串，格式为`n=分解序列`。
9. 如果循环结束后仍然没有找到符合条件的分解方式，说明不存在最小的连续整数分解，返回字符串"N"。
10. 在`main`方法中，设置样例输入`n`，调用`findMinSequence`方法并输出结果。

------

### 三、代码参考

```java
public class Main {
    public static String findMinSequence(int n) {
        for (int m = 2; m < n; m++) {
            // 通过等差数列求和公式来解出x
            double x = (n - m * (m - 1) / 2.0) / m;
            // 如果x是正整数，并且m使得x为正，那么我们找到了分解
            if (x % 1 == 0 && x > 0) {
                // 构造分解序列的字符串表示
                StringBuilder sequence = new StringBuilder();
                for (int i = 0; i < m; i++) {
                    sequence.append((int) (x + i)).append("+");
                }
                sequence.deleteCharAt(sequence.length() - 1);
                return n + "=" + sequence.toString();
            }
        }

        // 如果所有m都无法使得x为正整数，则返回"N"
        return "N";
    }

    public static void main(String[] args) {
        int n = 15;
        System.out.println(findMinSequence(n));
    }
}

123456789101112131415161718192021222324252627
```



## （难）11.跳马问题 

### 一、题目

------

#### 🎃题目描述

> 输入 m 和 n 两个数，m 和 n 表示一个 m*n 的棋盘。输入棋盘内的数据。棋盘中存在数字和".“两种字符，如果是数字表示该位置是一匹马，如果是”."表示该位置为空的，棋盘内的数字表示为该马能走的最大步数。
>  
> 例如棋盘内某个位置一个数字为 k，表示该马只能移动 1~k 步的距离。
>  
> 棋盘内的马移动类似于中国象棋中的马移动，先在水平或者垂直方向上移动一格，然后再将其移动到对角线位置。
>  
> 棋盘内的马可以移动到同一个位置，同一个位置可以有多匹马。
>  
> 请问能否将棋盘上所有的马移动到同一个位置，若可以请输入移动的最小步数。若不可以输出 0。

------

#### 🎃输入输出

> 输入
> 输入m 和 n 两个数，m 和 n 表示一个 m*n 的棋盘。输入棋盘内的数据。
>  
> 输出
> 能否将棋盘上所有的马移动到同一个位置，若可以请输入移动的最小步数。若不可以输出 0。

------

#### 🎃样例1

```java
输入
3 2
. .
2 .
. .



输出
0
12345678910
```

------

#### 🎃样例2

```java
输入
3 5
4 7 . 4 8
4 7 4 4 .
7 . . . .



输出
17
12345678910
```

------

### 二、思路参考

------

1. 定义一个二维数组DIRECTIONS，包含八个可能的马移动方向，每个方向用两个坐标表示。
2. 定义一个bfs方法，参数为棋盘的行数m、列数n、马的初始位置x、y和最大步数maxSteps。该方法用于计算从马的初始位置到达每个点的最小步数。
3. 在bfs方法中，首先初始化一个二维数组matrix，用于记录到达每个点的最小步数。将所有点的值初始化为-1，表示不可达。
4. 创建一个队列queue，将初始位置加入队列，并将初始位置的步数设为0。
5. 进入循环，直到队列为空或步数达到最大步数。
6. 在循环中，首先增加步数steps，并获取当前队列的大小size。
7. 遍历队列中的每个位置，对于每个位置，遍历八个方向。计算新位置的坐标newX和newY。
8. 如果新位置在棋盘内且之前没有被访问过（即matrix[newX][newY]的值为-1），则更新新位置的步数为steps，并将新位置加入队列。
9. 返回最终的matrix矩阵，其中记录了到达每个点的最小步数。
10. 定义一个minTotalSteps方法，参数为棋盘的行数m、列数n和马的列表horses。该方法用于计算所有马到达每个位置的总步数，并找出最小的总步数。
11. 在minTotalSteps方法中，首先初始化一个二维数组totalSteps，用于记录所有马到达每个位置的总步数。将所有点的值初始化为0。
12. 遍历马的列表horses，对于每匹马，获取其位置x、y和步数steps。
13. 调用bfs方法计算从该马的位置到达每个点的最小步数，得到一个可达性矩阵reachable。
14. 遍历棋盘的每个位置，对于每个位置，如果某匹马到不了该位置，则将totalSteps对应位置的值设为-1。
15. 如果该位置可达，则将totalSteps对应位置的值累加reachable对应位置的值。
16. 遍历totalSteps矩阵，找出最小的总步数minStep。如果找到了可达的位置，则返回minStep；否则返回-1。
17. 在main方法中，读取输入的行数m和列数n，并创建一个马的列表horses。
18. 遍历输入的棋盘，对于每个位置，如果不是空位置，则将该位置的坐标和步数加入马的列表。
19. 调用minTotalSteps方法计算并输出结果。如果无法到达任何位置，则输出0；否则输出最小步数。

------

### 三、详细题解

------

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1ac73eb2a94b4630aba64963bdf5cc72.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6eebc81df2d9454f99960345a6365322.png)

------

### 四、代码参考

```java
import java.util.*;

public class Main {
    // 八个可能的马移动方向
    private static final int[][] DIRECTIONS = {
            {2, 1}, {1, 2}, {-1, 2}, {-2, 1},
            {-2, -1}, {-1, -2}, {1, -2}, {2, -1}
    };

    // 为每匹马执行BFS搜索，返回一个矩阵，记录到达每个点的最小步数
    private static int[][] bfs(int m, int n, int x, int y, int maxSteps) {
        int[][] matrix = new int[m][n]; // 初始化矩阵
        for (int[] row : matrix) {
            Arrays.fill(row, -1); // -1表示不可达
        }
        matrix[x][y] = 0; // 起始点步数为0

        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{x, y}); // 使用队列进行BFS搜索
        int steps = 0;

        // BFS搜索，直到达到最大步数
        while (!queue.isEmpty() && steps < maxSteps) {
            steps++;
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] current = queue.poll();
                for (int[] dir : DIRECTIONS) { // 遍历八个方向
                    int newX = current[0] + dir[0];
                    int newY = current[1] + dir[1];
                    // 如果新位置在棋盘内且之前没有被访问过
                    if (newX >= 0 && newX < m && newY >= 0 && newY < n && matrix[newX][newY] == -1) {
                        matrix[newX][newY] = steps; // 更新步数
                        queue.offer(new int[]{newX, newY}); // 新位置入队
                    }
                }
            }
        }
        return matrix; // 返回记录步数的矩阵
    }

    // 计算所有马到达每个位置的总步数，并找出最小的总步数
    private static int minTotalSteps(int m, int n, List<int[]> horses) {
        int[][] totalSteps = new int[m][n]; // 初始化总步数矩阵
        for (int[] row : totalSteps) {
            Arrays.fill(row, 0);
        }

        for (int[] horse : horses) { // 遍历每匹马
            int x = horse[0];
            int y = horse[1];
            int steps = horse[2];
            int[][] reachable = bfs(m, n, x, y, steps); // 计算可达性矩阵
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (reachable[i][j] == -1) { // 如果某匹马到不了这个点
                        totalSteps[i][j] = -1; // 标记为不可达
                    } else if (totalSteps[i][j] != -1) { // 如果这个点可达
                        totalSteps[i][j] += reachable[i][j]; // 累加步数
                    }
                }
            }
        }

        int minStep = Integer.MAX_VALUE; // 初始化最小步数为无穷大
        for (int[] row : totalSteps) {
            for (int step : row) {
                if (step != -1) { // 如果这个点可达
                    minStep = Math.min(minStep, step); // 更新最小步数
                }
            }
        }
        return minStep != Integer.MAX_VALUE ? minStep : -1; // 返回最小步数，如果无法达到返回-1
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt(); // 读取行数
        int n = scanner.nextInt(); // 读取列数
        scanner.nextLine(); // 读取换行符
        List<int[]> horses = new ArrayList<>(); // 初始化马的列表

        for (int i = 0; i < m; i++) {
            String[] row = scanner.nextLine().split(" ");
            for (int j = 0; j < row.length; j++) {
                if (!row[j].equals(".")) { // 如果不是空位置
                    horses.add(new int[]{i, j, Integer.parseInt(row[j])}); // 添加马的位置和步数到列表
                }
            }
        }

        // 计算并输出结果
        int result = minTotalSteps(m, n, horses);
        System.out.println(result != -1 ? result : 0); // 如果无法到达输出0，否则输出最小步数
    }
}

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697
```



## 12.密码解密

#### 🎃题目描述

> 给定一段"密文"字符串s， 其中字符都是经过 “密码本” 映射的，现需要将密文解密并输出
>  
> 映射的规则(‘a’ ~ ‘i’) 分别用(‘1’ ~ ‘9’)表 示； (‘j’ ~ ‘z’) 分别用(" 10* " ~ " 26 * ")表示
>  
> 约束：映射始终唯一

------

#### 🎃输入输出

> 输入
> 密文字符串
>  
> 输出
> 明文字符串
>  
> 备注
> 翻译后的文本长度在100以内

------

#### 🎃样例1

```java
输入
20*19*20*


输出
tst
123456
```

------

### 二、思路参考

------

1. 创建一个映射表mapping，将数字映射为对应的字母。这里使用HashMap来实现映射关系。
2. 初始化明文字符串plaintext，用于存储解密后的结果。
3. 初始化一个缓存字符串temp，用于拼接多位数的数字。
4. 遍历密文字符串s中的每个字符。
5. 如果字符是数字，则将其添加到缓存字符串temp中。
6. 如果字符是’*'，则表示前面缓存的数字表示一个字母。根据缓存的数字从映射表mapping中获取对应的字母，并添加到明文字符串plaintext中。然后清空缓存字符串temp。
7. 如果字符不是数字也不是’*'，则不做任何处理。
8. 如果缓存字符串temp不为空，则需要处理剩余的数字（可能是最后一个字母）。根据缓存的数字从映射表mapping中获取对应的字母，并添加到明文字符串plaintext中。
9. 返回明文字符串plaintext作为解密结果。
10. 在main方法中，定义一个密文字符串cipherText。
11. 调用decrypt方法对密文字符串进行解密，得到解密后的明文字符串。
12. 输出解密后的明文字符串。

------

### 三、案例解析

```
输入: 20*19*20*

字典映射:
{
  '1': 'a', '2': 'b', ..., '9': 'i',
  '10*': 'j', '11*': 'k', ..., '26*': 'z'
}

初始化:
明文字符串: ""
临时字符串: ""

遍历密文字符串:
'2' -> 临时字符串变为 "2"
'0' -> 临时字符串变为 "20"
'*' -> 查找映射，找到 't'，添加到明文字符串 -> 明文字符串变为 "t"，清空临时字符串
'1' -> 临时字符串变为 "1"
'9' -> 临时字符串变为 "19"
'*' -> 查找映射，找到 's'，添加到明文字符串 -> 明文字符串变为 "ts"，清空临时字符串
'2' -> 临时字符串变为 "2"
'0' -> 临时字符串变为 "20"
'*' -> 查找映射，找到 't'，添加到明文字符串 -> 明文字符串变为 "tst"，清空临时字符串

结束遍历

输出明文字符串: "tst"
1234567891011121314151617181920212223242526
```

------

### 四、代码参考

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static String decrypt(String s) {
        // 创建一个映射表，将数字映射为对应的字母
        Map<String, Character> mapping = new HashMap<>();
        for (int i = 1; i <= 26; i++) {
            mapping.put(String.valueOf(i), (char) (96 + i));
        }

        // 初始化明文字符串
        StringBuilder plaintext = new StringBuilder();
        // 初始化一个缓存字符串，用于拼接多位数的数字
        StringBuilder temp = new StringBuilder();

        // 遍历密文字符串
        for (char c : s.toCharArray()) {
            if (Character.isDigit(c)) {  // 如果字符是数字，则将其添加到缓存字符串
                temp.append(c);
            } else if (c == '*') {  // 如果字符是'*'，则表示前面缓存的数字表示一个字母
                plaintext.append(mapping.get(temp.toString()));  // 将缓存的数字转换为字母，并添加到明文字符串
                temp.setLength(0);  // 清空缓存字符串
            } else {  // 其他情况
                // 不做任何处理
            }
        }

        // 如果缓存字符串不为空，则需要处理剩余的数字（可能是最后一个字母）
        if (temp.length() > 0) {
            plaintext.append(mapping.get(temp.toString()));
        }

        return plaintext.toString();
    }

    public static void main(String[] args) {
        String cipherText = "20*19*20*";
        System.out.println(decrypt(cipherText));
    }
}
1234567891011121314151617181920212223242526272829303132333435363738394041
```



## 13.快递员的烦恼

#### 🎃题目描述

> 快递公司每日早晨，给每位快递员推送需要送到客户手中的快递以及路线信息，快递员自己又查找了一些客户与客户之间的路线距离信息，请你依据这些信息，给快递员设计一条最短路径，告诉他最短路径的距离
>  
> 注意：
>  
> 1、不限制快递包裹送到客户手中的顺序，但必须保证都送到客户手中
>  
> 2、用例保证一定存在投递站到每位客户之间的路线，但不保证客户与客户之间有路线，客户位置及投递站均允许多次经过
>  
> 3、所有快递送完后，快递员需回到投递站

------

#### 🎃输入输出

> 输入
> 首行输入两个正整数n、m，接下来n行，输入快递公司发布的客户快递信息
>  
> 格式为：客户id 投递站到 客户之间的距离distance
>  
> 再接下来的m行，是快递员自行查找的客户与客户之间的距离信息
>  
> 格式为：客户1的id 客户2的id distance
>  
> 输出
> 最短路径距离，如无法找到，请输出-1

------

#### 🎃样例1

```java
输入
2 1
1 1000
2 1200
1 2 300          


输出
2500

说明:
2 1  分别表示 n,m
1 1000    表示客户1到投递站的距离distance
2 1200    表示客户2到投递站的距离distance
1 2 300   表示客户1与客户2之间的距离为300
123456789101112131415
```

------

#### 🎃样例2

```java
输入
5  1
5 1000
9 1200
17 300
132 700
500 2300
5 9 400
     


输出
9200


说明: 在所有可行的路径中，最短路径长度为1000 + 400 + 1200 + 300 + 300 + 700 + 700 + 2300 +
2300 = 9200
1234567891011121314151617
```

------

### 二、思路参考

------

首先，我们需要构建一个图，其中包含所有客户和投递站作为节点。接着，我们将使用这个图来找到一条路径，这条路径访问每个客户一次，并返回到投递站，同时尽可能地缩短总行进距离。

我们有以下输入：

客户和投递站之间的距离：

```
客户ID  距离
5       1000
9       1200
17      300
132     700
500     2300
123456
```

客户之间的距离：

```
客户ID  客户ID  距离
5       9       400
12
```

没有其他客户之间的直接距离，所以我们必须假设客户之间的其他路径会通过投递站来完成。

基于这些信息，我们的图看起来会像这样：

```
   投递站
  / | | | \
 5  9 17 132 500
123
```

在这个图中，所有客户都通过不同长度的路径与投递站相连。客户5和客户9之间有一个直接的连接，其距离为400。其他客户之间没有直接连接，所以他们的路径必须经过投递站。

在这个例子中，一个可能的路径是：

```
投递站 -> 客户5 -> 客户9 -> 投递站 -> 客户17 -> 投递站 -> 客户132 -> 投递站 -> 客户500 -> 投递站
1
```

这个路径的长度为：

```
1000 + 400 + 1200 + 300 + 300 + 700 + 700 + 2300 + 2300 = 9200
1
```

------

### 三、代码参考

```java
import java.util.*;

public class Main {


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取投递站点数量和客户之间直接距离的数量
        int n = scanner.nextInt();
        int m = scanner.nextInt();

        List<Pair> stationToCustomers = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int custId = scanner.nextInt();
            int dist = scanner.nextInt();
            stationToCustomers.add(new Pair(custId, dist));
        }

        List<Triple> customersToCustomers = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            int cust1 = scanner.nextInt();
            int cust2 = scanner.nextInt();
            int dist = scanner.nextInt();
            customersToCustomers.add(new Triple(cust1, cust2, dist));
        }

        // 计算最短路径距离
        int shortestDistance = findShortestPath(n, m, stationToCustomers, customersToCustomers);
        System.out.println(shortestDistance);

        scanner.close();
    }

    // 查找最短路径的函数
    public static int findShortestPath(int n, int m, List<Pair> stationToCustomers, List<Triple> customersToCustomers) {
        // 使用哈希表来存储节点之间的距离
        Map<Pair, Integer> graph = new HashMap<>();

        // 投递站到客户的距离
        for (Pair pair : stationToCustomers) {
            graph.put(new Pair(0, pair.customerId), pair.distance);
            graph.put(new Pair(pair.customerId, 0), pair.distance);
        }

        // 客户之间的距离
        for (int i = 0; i < stationToCustomers.size(); i++) {
            for (int j = 0; j < stationToCustomers.size(); j++) {
                if (i != j) {
                    Pair pairI = stationToCustomers.get(i);
                    Pair pairJ = stationToCustomers.get(j);

                    // 查找客户之间是否有直接的距离信息
                    OptionalInt directDistance = customersToCustomers.stream()
                            .filter(t -> (t.customer1 == pairI.customerId && t.customer2 == pairJ.customerId) ||
                                    (t.customer1 == pairJ.customerId && t.customer2 == pairI.customerId))
                            .mapToInt(t -> t.distance)
                            .findFirst();

                    // 如果没有直接距离，则通过投递站计算间接距离
                    if (!directDistance.isPresent()) {
                        int indirectDistance = graph.get(new Pair(pairI.customerId, 0)) +
                                graph.get(new Pair(0, pairJ.customerId));
                        graph.put(new Pair(pairI.customerId, pairJ.customerId), indirectDistance);
                    } else {
                        // 使用直接距离
                        graph.put(new Pair(pairI.customerId, pairJ.customerId), directDistance.getAsInt());
                    }
                }
            }
        }

        // 找出所有客户的排列组合
        List<Integer> allCustomers = new ArrayList<>();
        for (Pair pair : stationToCustomers) {
            allCustomers.add(pair.customerId);
        }

        // 初始化最短路径长度为无穷大
        int minDistance = Integer.MAX_VALUE;

        // 遍历所有的排列，寻找最短的路径
        List<List<Integer>> permutations = generatePermutations(allCustomers);
        for (List<Integer> perm : permutations) {
            // 计算当前排列的路径长度
            int currDistance = graph.get(new Pair(0, perm.get(0)));

            for (int i = 0; i < perm.size() - 1; i++) {
                currDistance += graph.get(new Pair(perm.get(i), perm.get(i + 1)));
            }

            // 加上最后一个客户返回投递站的距离
            currDistance += graph.get(new Pair(perm.get(perm.size() - 1), 0));

            // 更新最短路径长度
            minDistance = Math.min(minDistance, currDistance);
        }

        // 如果没有找到有效路径，返回-1
        return minDistance == Integer.MAX_VALUE ? -1 : minDistance;
    }

    // 辅助类，用于存储投递站到客户的距离
    static class Pair {
        int customerId;
        int distance;

        public Pair(int customerId, int distance) {
            this.customerId = customerId;
            this.distance = distance;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Pair pair = (Pair) o;
            return customerId == pair.customerId &&
                    distance == pair.distance;
        }

        @Override
        public int hashCode() {
            return Objects.hash(customerId, distance);
        }
    }

    // 辅助类，用于存储客户之间的直接距离
    static class Triple {
        int customer1;
        int customer2;
        int distance;

        public Triple(int customer1, int customer2, int distance) {
            this.customer1 = customer1;
            this.customer2 = customer2;
            this.distance = distance;
        }
    }

    // 生成所有可能的排列组合
    private static List<List<Integer>> generatePermutations(List<Integer> original) {
        if (original.isEmpty()) {
            List<List<Integer>> result = new ArrayList<>();
            result.add(new ArrayList<>());
            return result;
        }

        Integer firstElement = original.remove(0);
        List<List<Integer>> returnValue = new ArrayList<>();
        List<List<Integer>> permutations = generatePermutations(original);
        for (List<Integer> smallerPermutated : permutations) {
            for (int index = 0; index <= smallerPermutated.size(); index++) {
                List<Integer> temp = new ArrayList<>(smallerPermutated);
                temp.add(index, firstElement);
                returnValue.add(temp);
            }
        }
        return returnValue;
    }
}

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849
```



## 14.围棋的气、围棋气数

#### 🎃题目描述

> 围棋棋盘由纵横各19条线垂直相交组成，棋盘上一共19x19=361个交点，对弈双方一方执白棋，一方执黑棋，落子时只能将棋子于交点上。
>  
> "气"是围棋中很重要的一个概念，某个棋子有几口气，是指其上下左右方向四个相邻的交叉点中，几个交叉点没有棋子，由此可知：
>  
> 1、在棋盘的边缘上的棋子最多有3口气(黑1)，在棋盘角点的棋子最多有2口气(2)，其他情况最多有4口气(白1)
>  
> 2、所有同色棋子的气之和叫做该色棋子的气，要注意的是，同色棋子重合的气点，对于该颜色棋子来说，只能计算一次气，比如下图中，黑棋一共4口气，不是5口气，因为黑1和黑2中间红绝三角标出来的气是两个黑棋共有的，对于黑棋整体来说只能算一个气
>  
> 3、本题目只计算气，对于眼也按气计算，如果您不清楚眼的概念，可忽略,按照前面描述的规则计算即可
>  
> 现在，请根据输入的棋和白棋得到坐标位置，计算黑棋和白棋一共各有多少气?
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e7d8ecff22824628ada8c6c8a6767c69.png)

------

#### 🎃输入输出

> 输入
> 输入包含两行数据，每行数据以空格分隔，数据个数是2的整数倍，每两个数是一组，代表棋子在棋盘上的坐标；
>  
> 坐标的原点在棋盘左上角点，第一个值是行号，范围从0到18；第二个值是列号，范围从0到18
>  
> 如：
> 0 5 8 9 9 10
> 5 0 9 9 9 8
>  
> 第一行数据表示三个坐标(0，5) 、(8，9)、 (9，10)
>  
> 第一行表示黑棋的坐标，第二行表示白棋的坐标。
>  
> 输出
> 两个数字以空格分隔，第一个数代表黑棋的气数，第二个数代表白棋的气数。

------

#### 🎃样例1

```java
输入
0 5 8 9 9 10
5 0 9 9 9 8


输出
8 7


说明:
黑棋一共8口气，白棋一共7口气

123456789101112
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/37d8b9bf9d354cc18ba213eae854bd43.png)

------

### 二、思路参考

------

1. 首先，创建一个Scanner对象来读取用户的输入。
2. 提示用户输入黑棋的位置，使用`System.out.print`方法输出提示信息，然后使用`scanner.nextLine()`方法读取用户输入的字符串。
3. 同样地，提示用户输入白棋的位置，并使用`scanner.nextLine()`方法读取用户输入的字符串。
4. 创建一个`convertInputToStones`方法，用于将用户输入的字符串转换为棋子的坐标数组。该方法接受一个字符串作为参数，首先使用`split`方法将字符串按空格分割成坐标数组，然后遍历坐标数组，将每个坐标对转换为整数并存储在一个二维数组中，最后返回该二维数组。
5. 调用`convertInputToStones`方法将黑棋和白棋的位置字符串转换为对应的坐标数组。
6. 创建一个`calculateLiberties`方法，用于计算棋子的“气”。该方法接受两个二维数组作为参数，分别代表当前玩家的棋子和对手的棋子。首先初始化一个空的集合来存储“气”，然后遍历当前玩家的棋子数组。对于每个棋子，检查其上下左右四个方向的邻近位置是否为空，并且不被同色或对方棋子占据。如果满足条件，则将邻近位置的坐标加入集合中。最后返回集合的大小，即“气”的总数。
7. 调用`calculateLiberties`方法分别计算黑棋和白棋的“气”。
8. 使用`System.out.println`方法输出黑棋和白棋的“气”的数量。

------

### 三、代码参考

```java
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("黑棋: ");
        String blackInput = scanner.nextLine();
        System.out.print("白棋: ");
        String whiteInput = scanner.nextLine();

        // 将输入字符串转换为黑色和白色棋子的坐标数组
        int[][] blackStones = convertInputToStones(blackInput);
        int[][] whiteStones = convertInputToStones(whiteInput);

        // 计算黑棋和白棋的“气”
        int blackLiberties = calculateLiberties(blackStones, whiteStones);
        int whiteLiberties = calculateLiberties(whiteStones, blackStones);

        // 输出黑棋和白棋的“气”的数量
        System.out.println("黑棋的气: " + blackLiberties + ", 白棋的气: " + whiteLiberties);
    }

    // 将输入字符串转换为棋子的坐标数组
    private static int[][] convertInputToStones(String input) {
        String[] coordinates = input.split(" ");
        int[][] stones = new int[coordinates.length / 2][2];

        for (int i = 0; i < coordinates.length; i += 2) {
            stones[i / 2][0] = Integer.parseInt(coordinates[i]);
            stones[i / 2][1] = Integer.parseInt(coordinates[i + 1]);
        }

        return stones;
    }

    // 计算棋子的“气”
    private static int calculateLiberties(int[][] stones, int[][] opponentStones) {
        int boardSize = 19;
        Set<String> liberties = new HashSet<>();

        for (int[] stone : stones) {
            int x = stone[0];
            int y = stone[1];

            // 检查棋子的四个方向（上下左右）
            int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
            for (int[] direction : directions) {
                int nx = x + direction[0];
                int ny = y + direction[1];

                // 如果邻近位置在棋盘内，并且不被同色或对方棋子占据，则视为一个“气”
                if (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize &&
                        !containsStone(stones, nx, ny) && !containsStone(opponentStones, nx, ny)) {
                    liberties.add(nx + "," + ny);  // 将这个“气”添加到集合中
                }
            }
        }

        return liberties.size();  // 返回“气”的总数
    }

    // 检查棋子数组中是否包含指定坐标的棋子
    private static boolean containsStone(int[][] stones, int x, int y) {
        for (int[] stone : stones) {
            if (stone[0] == x && stone[1] == y) {
                return true;
            }
        }
        return false;
    }
}

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475
```



## 15.多段线数据压缩

#### 🎃题目描述

> 下图中，每个方块代表一个像素， 每个像素用其行号和列号表示。为简化处理，多段线的向只能是水平、斜向45度。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3d7fa2c9eaed483c8c47c4c86d42f167.png)

上图中的多段线可以用下面的坐标串表示： (2，8)， (3，7)，(3， 6)， (3， 5)，(4， 4)， (5， 3)， (6， 2)， (7， 3)， (8， 4)，(7，5)

但可以发现，这种表示不是最简的，其实只要存储6个色的关键点即可，它们是线段的起点、拐点、终点，而剩下4个点是冗余的

>  即可以简化为： (2，8) 、(3，7) 、(3，5) 、(6，2) 、(8，4) 、(7，5)

现在，请根据输入的包含有冗余数据的多段线坐标列表，输出其最简化的结果

------

#### 🎃输入输出

> 输入
> 一行坐标串
>  
> 输入说明：
> 1、所有数字以空格分隔，每两个数字一组，第一个数字是行号，第二个数字是列号；
> 2、行号和列号范围为[0，64)，用例输入保证不会越界，不必检查；
> 3、输入数据至少包含两个坐标点
>  
> 输出
> 压缩后的最简化坐标列表,和输入数据的格式相同
>  
> 输出说明：
> 输出的坐标相对顺序不能变化

------

#### 🎃样例1

```java
输入
2 8 3 7 3 6 3 5 4 4 5 3 6 2 7 3 8 4 7 5

输出
2 8 3 7 3 5 6 2 8 4 7 5


说明:
如上图所示，6个蓝色像素的坐标依次是(2,8) 、(3,7) 、(3,5) 、(6,2) 、(8,4) 、(7,5) 
123456789
```

------

### 二、思路参考

------

1. 读取用户输入的坐标字符串。
2. 将输入字符串转换为坐标列表。输入字符串按空格分隔，并将每个坐标值解析为整数，并存储在整数列表中。
3. 检查坐标点数量是否小于6个。如果是，则返回原始坐标列表，因为无法形成多于3个点的有效线段。
4. 将一维坐标列表转换为二维点列表。每个点由两个整数坐标值组成，并将其存储在二维列表中。
5. 创建一个新的简化坐标列表，并将第一个点添加到其中。
6. 遍历点列表的第二个到倒数第二个点。对于每个点，判断其是否为拐点。如果是拐点，则将其添加到简化坐标列表中。
7. 将最后一个点添加到简化坐标列表中。
8. 将简化的二维坐标列表转换为一维坐标列表，以符合输出格式。
9. 返回简化后的坐标列表。

------

### 三、代码参考

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        System.out.print("输入坐标: ");
        String input = scanner.nextLine();
        
        // 将输入字符串转换为坐标列表
        List<Integer> coords = convertInputToCoords(input);
        
        // 简化坐标
        List<Integer> simplifiedCoords = simplifyCoordinates(coords);
        
        // 输出简化后的坐标
        System.out.print("简化后的坐标: ");
        for (int i = 0; i < simplifiedCoords.size(); i++) {
            System.out.print(simplifiedCoords.get(i));
            if (i < simplifiedCoords.size() - 1) {
                System.out.print(" ");
            }
        }
    }
    
    // 将输入字符串转换为坐标列表
    private static List<Integer> convertInputToCoords(String input) {
        String[] inputArray = input.split(" ");
        List<Integer> coords = new ArrayList<>();
        for (String str : inputArray) {
            coords.add(Integer.parseInt(str));
        }
        return coords;
    }
    
    // 判断点p2是否为拐点
    private static boolean isTurningPoint(List<Integer> p1, List<Integer> p2, List<Integer> p3) {
        return (p2.get(0) - p1.get(0)) * (p3.get(1) - p2.get(1)) != (p3.get(0) - p2.get(0)) * (p2.get(1) - p1.get(1));
    }
    
    // 简化坐标
    private static List<Integer> simplifyCoordinates(List<Integer> coords) {
        if (coords.size() < 6) {
            return coords;
        }
        
        List<List<Integer>> points = new ArrayList<>();
        for (int i = 0; i < coords.size(); i += 2) {
            List<Integer> point = new ArrayList<>();
            point.add(coords.get(i));
            point.add(coords.get(i + 1));
            points.add(point);
        }
        
        List<List<Integer>> simplified = new ArrayList<>();
        simplified.add(points.get(0));
        
        for (int i = 1; i < points.size() - 1; i++) {
            if (isTurningPoint(points.get(i - 1), points.get(i), points.get(i + 1))) {
                simplified.add(points.get(i));
            }
        }
        
        simplified.add(points.get(points.size() - 1));
        
        List<Integer> simplifiedCoords = new ArrayList<>();
        for (List<Integer> point : simplified) {
            simplifiedCoords.add(point.get(0));
            simplifiedCoords.add(point.get(1));
        }
        
        return simplifiedCoords;
    }
}

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677
```



## 16.贪心歌手

#### 🎃题目描述

> 歌手准备从A城去B城参加演出
>  
> 有如下规则：
>  
> 1、按照合同，他必须在T天内赶到
>  
> 2、歌手途径N座城市
>  
> 3、歌手不能往回走
>  
> 4、每两座城市之间需要的天数都可以提前获知
>  
> 5、歌手在每座城市都可以在路边卖唱赚钱，经过调研，歌手提前获知了每座城市卖唱的收入预期，如果在一座城市第一 天卖唱可以赚M，后续每天的收入会减少D (第二天赚的钱是M-D，第三天是M-2D…)；如果收入减到0就不会再少了
>  
> 6、歌手到达后的第二天才能开始卖唱。如果今天卖过唱，第二天才能出发
>  
> 贪心的歌手最多可以赚多少钱?

------

#### 🎃输入输出

> 输入
>  
> 第一行两个数字T和N，中间用空格隔开，T代表总天数；N代表路上经过N座城市，0<T<1000，0<N<100
>  
> 第二行N+1个数字，中间用空格隔开，代表每两座城市之间耗费的时间，其总和<=T
>  
> 接下来N行，每行两个数字M和D，中间用空格隔开，代表每个城市的收入预期，0<M<1000，0<D<100
>  
> 输出
> 一个数字，代表歌手最多可以赚多少钱

------

#### 🎃样例1

```java
输入
10 2
1 1 2
120 20
90 10

输出
540

说明：
总共10天，路上经过2座城市
1234567891011
```

------

### 二、思路参考

------

1. 首先，从输入中获取总天数 T 和经过的城市数量 N。
2. 创建一个长度为 N+1 的数组 travelTimes，用来存储每两座城市之间的耗费时间。其中 travelTimes[0] 为起始城市到第一座城市的耗费时间，travelTimes[N] 为最后一座城市到终点城市的耗费时间。
3. 创建一个二维数组 cities，大小为 N×2，用来存储每个城市的初始收入和每天减少的收入。cities[i][0] 表示第 i 个城市的初始收入，cities[i][1] 表示第 i 个城市每天减少的收入。
4. 计算歌手能够唱歌的总天数 daysForSinging。首先将 travelTimes 数组中的所有元素相加得到路上所花费的总时间，然后用总天数 T 减去路上的总时间，即为歌手能够唱歌的总天数。
5. 创建一个列表 earnings，用来存储所有可能的每天收益。遍历 cities 数组，对于每个城市，计算出其初始收入和每天减少的收入。然后使用一个循环，从第一天开始，每天计算当前收入并将其加入 earnings 列表中，直到收入减少到 0。
6. 对 earnings 列表按照收益进行降序排序，即收益高的排在前面。
7. 创建一个变量 totalIncome，用来存储歌手的总收入。遍历 earnings 列表，对于每个收益，如果歌手还有剩余的唱歌天数，将该收益加到总收入中，并将剩余的唱歌天数减 1。如果唱歌天数用完了，则跳出循环。
8. 输出歌手最多可以赚多少钱，即 totalIncome。

------

### 三、代码参考

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();  // 总天数
        int N = scanner.nextInt();  // 城市数量

        int[] travelTimes = new int[N + 1];
        for (int i = 0; i <= N; i++) {
            travelTimes[i] = scanner.nextInt();
        }

        // cities数组存储每个城市的初始收入和每天减少的收入
        int[][] cities = new int[N][2];
        for (int i = 0; i < N; i++) {
            cities[i][0] = scanner.nextInt(); // M: 初始收入
            cities[i][1] = scanner.nextInt(); // D: 每天减少的收入
        }

        scanner.close();

        // 计算歌手能够唱歌的总天数
        int daysForSinging = T - Arrays.stream(travelTimes).sum();

        // 存储所有可能的每天收益
        List<int[]> earnings = new ArrayList<>();
        for (int[] city : cities) {
            int M = city[0];
            int D = city[1];
            int dayIncome = M;
            int day = 0;
            while (dayIncome > 0) {
                earnings.add(new int[]{dayIncome, day}); // 收益和对应天数
                day++;
                dayIncome -= D;
            }
        }

        // 按每天的收益进行降序排序
        earnings.sort((a, b) -> b[0] - a[0]);

        // 选择收益最高的天数，直到唱歌的天数用完
        int totalIncome = 0;
        for (int[] earning : earnings) {
            if (daysForSinging > 0) {
                totalIncome += earning[0];
                daysForSinging--;
            } else {
                break;
            }
        }

        System.out.println(totalIncome);
    }
}

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657
```



## 17.求幸存数之和

#### 🎃题目描述

> 给一个正整数列nums， 一个跳数jump，及幸存数量left，运算过程为：从索引为0的位置开始向后跳，中间跳过J个数字，命中索引为J+1的数字，该数被敲出，并从该点起跳。以此类推，直到幸存left个数为止。然后返回幸存数之和
>  
> 约束：
> 1、0是第一个起跳点
>  
> 2、起跳点和命中点之间间隔jump个数字，已被敲出的数字不计入在内
>  
> 3、跳到末尾时无缝从头开始(循环查找)，并可以多次循环
>  
> 4、若起始时left>len(nums)则无需跳数处理过程

/**

- @parm nums：正整数数列，长度范围[1，10000]

- @parm jump：跳数，范围[1，10000]

- @parm left 幸存数量,、，范围[0,100000]

- @parm return"幸存数之和

  */

int sumOfLeft(int[] nums， int jump，int left)

------

#### 🎃输入输出

> 输入
>  
> 第一行输入正整数数列
>  
> 第二行输入跳数
>  
> 第三行输入幸存数量
>  
> 输出
> 幸存数之和

------

#### 🎃样例1

```java
输入
[1,2,3,4,5,6,7,8,9],4,3


输出
13

说明:
从1 (索引为0)开始起跳,中间跳过4个数字因此依次删除6,2,8,5,4,7;剩余1,3,9,返回和为13
123456789
```

------

### 二、思路参考

------

1. 首先判断如果幸存数量大于等于数组长度，则不需要进行任何处理，直接返回数组中所有数字的和。
2. 定义一个变量current_index表示当前的索引位置，初始值为0。
3. 创建一个列表remainingNums用于存储剩余的数字，将输入的nums数组中的数字全部复制到remainingNums列表中。
4. 循环执行直到remainingNums列表中剩余的数字个数等于幸存数量。
5. 在循环中，计算跳过jump个数字后的索引位置，使用取模运算保证索引位置在列表范围内。
6. 删除命中的数字，即将当前索引位置的数字从remainingNums列表中移除。
7. 减去一个位置，即将currentIndex减1，这是因为下一次起跳点应该是当前弹出元素的下一个位置。需要注意的是，由于当前元素已被删除，下一个元素占据了当前索引的位置，所以需要使用加上列表长度再取模的方式来保证索引位置在列表范围内。
8. 循环结束后，remainingNums列表中剩余的数字个数等于幸存数量，计算剩余数字之和并返回。

------

### 三、代码参考

```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9};  // 输入的正整数数列
        int jump = 4;  // 输入的跳数
        int left = 3;  // 输入的幸存数量
        System.out.println(sumOfLeft(nums, jump, left));  // 输出幸存数之和
    }
    
    public static int sumOfLeft(int[] nums, int jump, int left) {
        // 如果幸存数量大于等于数组长度，则不需要进行任何处理
        if (left >= nums.length) {
            int sum = 0;
            for (int num : nums) {
                sum += num;
            }
            return sum;
        }

        // 定义当前的索引位置，初始从0开始
        int currentIndex = 0;
        // 创建一个列表用于存储剩余的数字
        List<Integer> remainingNums = new ArrayList<>();
        for (int num : nums) {
            remainingNums.add(num);
        }

        // 循环执行直到数组中剩余的数字等于幸存数量
        while (remainingNums.size() > left) {
            // 计算跳过jump个数字后的索引位置
            currentIndex = (currentIndex + jump) % remainingNums.size();
            // 删除命中的数字
            remainingNums.remove(currentIndex);
            // 减去一个位置，因为下一次起跳点应该是当前弹出元素的下一个位置
            // 由于当前元素已被删除，下一个元素占据了当前索引的位置
            currentIndex = (currentIndex - 1 + remainingNums.size()) % remainingNums.size();
        }

        // 返回幸存数字之和
        int sum = 0;
        for (int num : remainingNums) {
            sum += num;
        }
        return sum;
    }
}
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748
```



## 18.抢七游戏

#### 🎃题目描述

> A、B两个人玩抢7游戏，游戏规则为A先报一个起始数字 X (10<起始数字<10000)，B报下一个数字Y（X-Y<3)，A再报一个数字Z(Y-Z<3)，以此类推，直到其中一个抢到7，抢到7即为胜者，在B赢得比赛的情况下，一共有多少种组合?

------

#### 🎃输入输出

> 输入
> 起始数字M，如100，10<=M<=10000
>  
> 输出
> B能赢得比赛的组合次数

------

#### 🎃样例1

```java
输入
10


输出
1
123456
```

------

### 二、思路参考

------

1. 首先初始化胜利次数为0。
2. 使用一个循环从10到M遍历每个数字。
3. 对于每个数字，判断是否不是7的倍数，如果是则进入内层循环。
4. 内层循环从1到3遍历每个数字。
5. 对于每个数字，判断数字减去当前循环变量后是否是7的倍数，如果是则增加胜利次数，并跳出内层循环。
6. 循环结束后，返回胜利次数。

------

### 三、代码参考

```java
//本题题解仅通过这一个用例，后续需要进行别的用例测试
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int M = scanner.nextInt();  // 读取输入的数字
        System.out.println(winGame(M));  // 输出胜利次数
    }

    public static int winGame(int M) {
        int count = 0;  // 初始化胜利次数
        for (int i = 10; i <= M; i++) {  // 枚举起始的数字
            if (i % 7 != 0) {  // 如果当前的数不是7的倍数
                for (int j = 1; j <= 3; j++) {  // 对于1,2,3中的每一个数
                    if ((i - j) % 7 == 0) {  // 如果i-j是7的倍数
                        count++;  // 增加胜利次数
                        break;  // 跳出循环
                    }
                }
            }
        }
        return count;  // 返回胜利次数
    }
}
12345678910111213141516171819202122232425
```



## 19.提取字符串中的最长数学表达式 | 机试真题+思路参考+代码解析（C卷）

#### 题目描述

> 提取字符串中的最长合法简单数学表达式，字符串长度最长的，并计算表达式的值。如果没有，则返回0；
>  
> 简单数学表达式只能包含以下内容：0-9数字，符号 + 、- 、*
>  
> 说明：
>  
> 1、所有数字，计算结果都不超过long
>  
> 2、如果有多个长度一样的，请返回第一个表达式的结果
>  
> 3、数学表达式，必须是最长的，合法的
>  
> 4、操作符不能连续出现，如 + - - +1 是不合法的

------

#### 🎃输入输出

> 输入
> 字符串
>  
> 输出
> 表达式值

------

#### 🎃样例1

```java
输入
1-2abcd


输出
-1
123456
```

------

### 二、思路参考

------

1. 首先定义一个方法`isLegal`，用于判断一个表达式是否合法。合法的表达式满足以下条件：
   - 表达式的首字符和尾字符不能是运算符（+、-、*）
   - 连续的两个字符不能都是运算符
2. 定义一个方法`solve`，用于计算一个合法的表达式的值。该方法的思路如下：
   - 使用正则表达式提取表达式中的数字和运算符，并分别存储在`numbers`和`operators`列表中。
   - 按照运算优先级计算表达式的值。首先处理乘法，循环直到没有乘法运算符：
     - 找到第一个乘法运算符的索引，计算乘法结果，并将结果替换为第一个操作数。
     - 删除第二个操作数和乘法运算符。
   - 然后处理加法和减法，循环遍历所有的运算符：
     - 如果是加法运算符，计算加法结果，并将结果替换为第二个操作数。
     - 如果是减法运算符，计算减法结果，并将结果替换为第二个操作数。
   - 返回最终的结果。
3. 主函数`main`中的思路如下：
   - 从标准输入中读取一个字符串，并去除首尾空格。
   - 使用正则表达式提取字符串中的所有可能的表达式，并存储在`expressions`列表中。
   - 遍历所有的表达式，判断表达式是否合法，将合法的表达式存储在`legalExpressions`列表中。
   - 根据表达式的长度降序排序`legalExpressions`列表。
   - 获取最长的合法表达式。
   - 调用`solve`方法计算表达式的值，并输出结果。

------

### 三、代码参考

```java
import java.util.*;
import java.util.regex.*;

public class Main {
    // 判断表达式是否合法
    public static boolean isLegal(String s) {
        if (s.charAt(0) == '+' || s.charAt(0) == '-' || s.charAt(0) == '*'
            || s.charAt(s.length()-1) == '+' || s.charAt(s.length()-1) == '-'
            || s.charAt(s.length()-1) == '*') {
            return false;
        }
        for (int i = 0; i < s.length() - 1; i++) {
            if ((s.charAt(i) == '+' || s.charAt(i) == '-' || s.charAt(i) == '*')
                && (s.charAt(i+1) == '+' || s.charAt(i+1) == '-' || s.charAt(i+1) == '*')) {
                return false;
            }
        }
        return true;
    }

    public static int solve(String s) {
        // 提取数字和运算符
        Pattern numberPattern = Pattern.compile("\\d+"); // 匹配数字的正则表达式模式
        Matcher numberMatcher = numberPattern.matcher(s); // 创建匹配器
        List<String> numbers = new ArrayList<>(); // 存储匹配到的数字
        while (numberMatcher.find()) { // 循环匹配数字
            numbers.add(numberMatcher.group()); // 将匹配到的数字添加到列表中
        }

        Pattern operatorPattern = Pattern.compile("[\\+\\-\\*]"); // 匹配运算符的正则表达式模式
        Matcher operatorMatcher = operatorPattern.matcher(s); // 创建匹配器
        List<String> operators = new ArrayList<>(); // 存储匹配到的运算符
        while (operatorMatcher.find()) { // 循环匹配运算符
            operators.add(operatorMatcher.group()); // 将匹配到的运算符添加到列表中
        }

        // 按照运算优先级计算表达式的值
        // 首先处理乘法
        while (operators.contains("*")) { // 循环直到没有乘法运算符
            int index = operators.indexOf("*"); // 找到第一个乘法运算符的索引
            numbers.set(index, String.valueOf(Integer.parseInt(numbers.get(index)) * Integer.parseInt(numbers.get(index+1)))); // 计算乘法结果并将结果替换为第一个操作数
            numbers.remove(index+1); // 删除第二个操作数
            operators.remove(index); // 删除乘法运算符
        }

        // 然后处理加法和减法
        for (int i = 0; i < operators.size(); i++) {
            if (operators.get(i).equals("+")) { // 如果是加法运算符
                numbers.set(i+1, String.valueOf(Integer.parseInt(numbers.get(i)) + Integer.parseInt(numbers.get(i+1)))); // 计算加法结果并将结果替换为第二个操作数
            } else { // 如果是减法运算符
                numbers.set(i+1, String.valueOf(Integer.parseInt(numbers.get(i)) - Integer.parseInt(numbers.get(i+1)))); // 计算减法结果并将结果替换为第二个操作数
            }
        }

        return Integer.parseInt(numbers.get(numbers.size()-1)); // 返回最终的结果
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String string = scanner.nextLine().trim(); // 输入待处理的字符串并去除首尾空格

        // 提取所有可能的表达式
        Pattern expressionPattern = Pattern.compile("[\\d\\+\\-\\*]+"); // 匹配表达式的正则表达式模式
        Matcher expressionMatcher = expressionPattern.matcher(string); // 创建匹配器
        List<String> expressions = new ArrayList<>(); // 存储匹配到的表达式
        while (expressionMatcher.find()) { // 循环匹配表达式
            expressions.add(expressionMatcher.group()); // 将匹配到的表达式添加到列表中
        }

        // 提取最长的合法表达式
        List<String> legalExpressions = new ArrayList<>(); // 存储合法的表达式
        for (String exp : expressions) { // 循环遍历所有的表达式
            if (isLegal(exp)) { // 判断表达式是否合法
                legalExpressions.add(exp); // 将合法的表达式添加到列表中
            }
        }
        legalExpressions.sort((a, b) -> b.length() - a.length()); // 根据表达式的长度降序排序
        String longestLegalExpression = legalExpressions.get(0); // 获取最长的合法表达式

        // 计算表达式的值
        int result = solve(longestLegalExpression); // 计算表达式的值
        System.out.println(result); // 输出结果
    }
}
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384
```



## 20.贪吃的猴子

#### 🎃题目描述

> 一只贪吃的猴子，来到一个果园，发现许多串香蕉排成一行，每串香蕉上有若干根香蕉。每串香蕉的根数由数组numbers给出。猴子获取香蕉，每次都只能从行的开头或者末尾获取，并且只能获取N次，求猴子最多能获取多少根香蕉.

------

#### 🎃输入输出

> 输入
> 第一行为数组numbers的长度
> 第二行为数组numbers的值每个数字通过空格分开
> 第三行输入为N，表示获取的次数
>  
> 输出
> 能获取的最大数值

------

#### 🎃样例1

```java
输入
7
1 2 2 7 3 6 1
3

输出
10
1234567
```

------

#### 🎃样例2

```java
输入
3
1 2 3
3

输出
6

说明
全部获取所有的香蕉，因此最终根数为1+2+3 = 6
12345678910
```

------

#### 🎃样例3

```java
输入
4
4 2 2 3
2

输出
7

说明
第一次获取香蕉为行的开头，第二次获取为行的末尾，因此最终根数为4+3 =7
12345678910
```

------

### 二、思路参考

------

1. 首先定义一个方法`maxBanana`，用于计算猴子可以拿到的最大香蕉数。该方法的思路如下：
   - 首先计算香蕉的总数，即将输入的数组中的所有元素相加。
   - 窗口的大小为数组的长度减去获取次数N。
   - 计算初始窗口的香蕉数量，即将数组前windowSize个元素相加。
   - 初始化最小窗口的香蕉数量为初始窗口的香蕉数量。
   - 从窗口的右侧开始移动窗口，每次移动更新窗口的香蕉数量，并更新最小窗口的香蕉数量。
   - 返回总数减去最小窗口和，即猴子可以拿到的最大香蕉数。
2. 主函数`main`中的思路如下：
   - 首先使用`Scanner`类从标准输入中读取输入。
   - 读取输入的数组长度和获取次数。
   - 读取数组的值，并将其存储在`numbers`列表中。
   - 调用`maxBanana`方法计算猴子可以拿到的最大香蕉数，并输出结果。

------

### 三、代码参考

```java
import java.util.*;

public class Main {
    public static int maxBanana(List<Integer> numbers, int N) {
        int total = 0;
        for (int num : numbers) {
            total += num; // 计算香蕉的总数
        }

        int windowSize = numbers.size() - N; // 窗口的大小，即每次获取香蕉后剩余的香蕉数量
        int windowSum = 0;
        for (int i = 0; i < windowSize; i++) {
            windowSum += numbers.get(i); // 初始窗口的香蕉数量
        }

        int minWindowSum = windowSum; // 最小窗口的香蕉数量

        // 从窗口的右侧移动窗口，更新窗口的香蕉数量，并更新最小窗口的香蕉数量
        for (int i = windowSize; i < numbers.size(); i++) {
            windowSum = windowSum - numbers.get(i-windowSize) + numbers.get(i);
            minWindowSum = Math.min(minWindowSum, windowSum);
        }

        // 返回总数减去最小窗口和，即猴子可以拿到的最大香蕉数
        return total - minWindowSum;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int length = scanner.nextInt(); // 输入数组numbers的长度
        List<Integer> numbers = new ArrayList<>();
        for (int i = 0; i < length; i++) {
            numbers.add(scanner.nextInt()); // 输入数组numbers的值
        }
        int N = scanner.nextInt(); // 输入获取的次数

        System.out.println(maxBanana(numbers, N));
    }
}
123456789101112131415161718192021222324252627282930313233343536373839
```



## 21.符号运算

#### 🎃题目描述

> 给定一个表达式，求其分数计算结果
>  
> 表达式的限制如下：
>  
> 1、所有的输入数字皆为正整数(包括0)
>  
> 2、仅支持四则运算(±*/)和括号
>  
> 3、结果为整数或分数，分数必须化为最简格式(比如6，3/4，7/8，90/7)
>  
> 4、除数可能为0，如果遇到这种情况，直接输出"ERROR"
>  
> 5、输入和最终计算结果中的数字都不会超出整型范围
>  

------

#### 🎃输入输出

> 输入
> 字符串格式的表达式，仅支持±*/，数字可能超过两位，可能带有空格，没有负数，长度小于200个字符
>  
> 输出
> 表达式结果，以最简格式表达
> 如果结果为整数，那么直接输出整数
> 如果结果为分数，那么分子分母不可再约分，可以为假分数，不可表达为带分数
> 结果可能是负数，负号放在最前面

------

#### 🎃样例1

```java
输入
1+5*7/8


输出
43/8
123456
```

------

#### 🎃样例2

```java
输入
1 /(e- 5)


输出
-1/5
123456
```

### 二、思路参考

------

1. 首先，移除表达式中的空格，方便后续的解析。
2. 定义一个索引变量index，用于指示当前解析到表达式的哪个位置。
3. 定义一个表达式字符串变量expression，用于存储输入的表达式。
4. 定义一个calculate方法，接受一个表达式字符串作为参数，返回计算结果。
5. 在calculate方法中，调用parseExpression方法解析表达式，并得到计算结果。
6. parseExpression方法首先调用parseTerm方法解析项，并得到第一项的结果。
7. 然后，使用while循环遍历表达式字符串，每次循环取出一个操作符和下一个项，根据操作符进行加减运算，并更新结果。
8. parseTerm方法类似于parseExpression方法，调用parseFactor方法解析因子，并得到第一个因子的结果。
9. 然后，使用while循环遍历表达式字符串，每次循环取出一个操作符和下一个因子，根据操作符进行乘除运算，并更新结果。
10. parseFactor方法根据当前位置的字符判断是一个括号表达式还是一个数字，如果是括号表达式，则递归调用parseExpression方法解析括号内的表达式，并返回结果；如果是数字，则调用parseNumber方法解析数字，并返回结果。
11. parseNumber方法从当前位置开始，判断字符是否是数字，如果是，则继续向后遍历，直到不是数字为止，然后将数字转化为BigInteger类型，并返回结果。
12. 最后，在分数类Fraction中，定义了四则运算和化简的方法，用于处理分数的加减乘除运算和化简。
13. 分数类的化简方法simplify使用了BigInteger类的gcd方法求最大公约数，然后将分子和分母都除以最大公约数，使得分数变为最简形式。
14. 最后，输出计算结果，如果结果是整数，则直接输出整数；如果结果是分数，则输出最简形式的分数。
15. 如果分母为0，则输出"ERROR"。

------

### 三、代码参考

```java
import java.math.BigInteger;
import java.util.Stack;

public class Main  {

    private int index = 0;
    private String expression;

    public String calculate(String expr) {
        expression = expr.replaceAll("\\s+", ""); // 移除空格
        index = 0;
        try {
            Fraction result = parseExpression();
            if (result.denominator.equals(BigInteger.ZERO)) {
                return "ERROR";
            }
            return result.simplify().toString();
        } catch (ArithmeticException e) {
            return "ERROR";
        }
    }

    private Fraction parseExpression() {
        Fraction result = parseTerm();
        while (index < expression.length()) {
            char operator = expression.charAt(index);
            if (operator == '+' || operator == '-') {
                index++;
                Fraction next = parseTerm();
                result = operator == '+' ? result.add(next) : result.subtract(next);
            } else {
                break;
            }
        }
        return result;
    }

    private Fraction parseTerm() {
        Fraction result = parseFactor();
        while (index < expression.length()) {
            char operator = expression.charAt(index);
            if (operator == '*' || operator == '/') {
                index++;
                Fraction next = parseFactor();
                result = operator == '*' ? result.multiply(next) : result.divide(next);
            } else {
                break;
            }
        }
        return result;
    }

    private Fraction parseFactor() {
        if (expression.charAt(index) == '(') {
            index++; // 跳过'('
            Fraction result = parseExpression();
            index++; // 跳过')'
            return result;
        } else {
            return parseNumber();
        }
    }

    private Fraction parseNumber() {
        int start = index;
        while (index < expression.length() && Character.isDigit(expression.charAt(index))) {
            index++;
        }
        BigInteger value = new BigInteger(expression.substring(start, index));
        return new Fraction(value, BigInteger.ONE);
    }

    // 分数类，用于处理分数的加减乘除运算和化简
    private static class Fraction {
        BigInteger numerator;   // 分子
        BigInteger denominator; // 分母

        public Fraction(BigInteger numerator, BigInteger denominator) {
            this.numerator = numerator;
            this.denominator = denominator;
        }

        public Fraction add(Fraction other) {
            BigInteger newNumerator = numerator.multiply(other.denominator)
                    .add(denominator.multiply(other.numerator));
            BigInteger newDenominator = denominator.multiply(other.denominator);
            return new Fraction(newNumerator, newDenominator);
        }

        public Fraction subtract(Fraction other) {
            BigInteger newNumerator = numerator.multiply(other.denominator)
                    .subtract(denominator.multiply(other.numerator));
            BigInteger newDenominator = denominator.multiply(other.denominator);
            return new Fraction(newNumerator, newDenominator);
        }

        public Fraction multiply(Fraction other) {
            BigInteger newNumerator = numerator.multiply(other.numerator);
            BigInteger newDenominator = denominator.multiply(other.denominator);
            return new Fraction(newNumerator, newDenominator);
        }

        public Fraction divide(Fraction other) {
            BigInteger newNumerator = numerator.multiply(other.denominator);
            BigInteger newDenominator = denominator.multiply(other.numerator);
            return new Fraction(newNumerator, newDenominator);
        }

        public Fraction simplify() {
            BigInteger gcd = numerator.gcd(denominator);
            numerator = numerator.divide(gcd);
            denominator = denominator.divide(gcd);
            // 如果分母为负数，则调整符号使分母为正
            if (denominator.compareTo(BigInteger.ZERO) < 0) {
                numerator = numerator.negate();
                denominator = denominator.negate();
            }
            return this;
        }

        @Override
        public String toString() {
            if (denominator.equals(BigInteger.ONE)) {
                return numerator.toString();
            } else {
                return numerator + "/" + denominator;
            }
        }
    }

    public static void main(String[] args) {
        Main rd = new Main();
        System.out.println(rd.calculate("1+5*7/8"));

    }
}

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484
```



## 22.会议室占用时间

#### 🎃题目描述

> 现有若干个会议，所有会议共享一个会议室，用数组表示各个会议的开始时间和结束时间，格式为：
>  
> [[会议1开始时间，会议1结束时间]，[会议2开始时间，会议2结束时间]]
>  
> 请计算会议室占用时间段

------

#### 🎃输入输出

> 输入
> 第一行输入一个整数 n，表示会议数量
> 之后输入n行，每行两个整数，以空格分隔，分别表示会议开始时间，会议结束时间
>  
> 输出
> 输出多行，每个两个整数，以空格分隔，分别表示会议室占用时间段开始和结束

------

#### 🎃样例1

```java
输入
4
1 4
2 5
7 9
14  18


输出
1 5 
7 9
14 18
123456789101112
```

------

#### 🎃样例2

```java
输入
2
1 4
4 5


输出
1 5 
12345678
```

### 二、思路参考

------

1. 定义一个内部类`Interval`，用于表示时间段。该类包含两个属性：`start`表示开始时间，`end`表示结束时间。
2. 定义一个静态方法`mergeIntervals`，用于合并时间段。该方法接收一个`List`类型的参数，表示需要合并的时间段列表，并返回一个合并后的时间段列表。
3. 在`mergeIntervals`方法中，首先对时间段列表进行排序，以开始时间为关键字进行升序排序。可以使用`Collections.sort()`方法，并传入一个自定义的比较器，比较器的实现方式是使用lambda表达式来定义比较规则。
4. 初始化一个空的合并后的时间段列表`merged`。
5. 遍历排序后的时间段列表`intervals`。对于每个时间段`current`，进行以下操作：
   - 如果合并后的时间段列表`merged`为空，或者当前时间段的开始时间大于已合并时间段的结束时间，则将当前时间段添加到合并后的列表中。
   - 否则，当前时间段与已合并的最后一个时间段有重叠，更新已合并时间段的结束时间，即取已合并时间段的结束时间和当前时间段的结束时间中的较大值。
6. 返回合并后的时间段列表`merged`。
7. 在主函数`main`中，首先使用`Scanner`类从标准输入中读取输入的会议数量`n`。
8. 初始化一个空的会议时间段列表`intervals`。
9. 使用一个循环，读取每个会议的开始和结束时间，并将其作为`Interval`对象添加到会议时间段列表中。
10. 调用`mergeIntervals`方法合并时间段，将会议时间段列表作为参数传入，得到合并后的时间段列表`mergedIntervals`。
11. 使用一个循环，遍历合并后的时间段列表`mergedIntervals`，并打印每个时间段的开始时间和结束时间。

------

### 三、代码参考

```java
import java.util.*;

class Main {
    static class Interval {
        int start;
        int end;

        Interval(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }

    public static List<Interval> mergeIntervals(List<Interval> intervals) {
        Collections.sort(intervals, (a, b) -> a.start - b.start); // 对时间段进行排序，以开始时间为关键字进行排序

        List<Interval> merged = new ArrayList<>(); // 初始化合并后的时间段列表

        for (Interval current : intervals) {
            // 如果合并后的时间段列表为空，或者当前时间段的开始时间大于已合并时间段的结束时间
            // 则将当前时间段添加到合并后的列表中
            if (merged.isEmpty() || current.start > merged.get(merged.size()-1).end) {
                merged.add(current);
            } else {
                // 否则，当前时间段与已合并的最后一个时间段有重叠，更新已合并时间段的结束时间
                merged.get(merged.size()-1).end = Math.max(merged.get(merged.size()-1).end, current.end);
            }
        }

        return merged;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt(); // 读取输入的会议数量

        List<Interval> intervals = new ArrayList<>(); // 初始化会议时间段列表

        // 读取每个会议的开始和结束时间，添加到会议时间段列表中
        for (int i = 0; i < n; i++) {
            int start = scanner.nextInt();
            int end = scanner.nextInt();
            intervals.add(new Interval(start, end));
        }

        // 调用函数合并时间段
        List<Interval> mergedIntervals = mergeIntervals(intervals);

        // 打印合并后的会议室占用时间段
        for (Interval interval : mergedIntervals) {
            System.out.println(interval.start + " " + interval.end);
        }
    }
}
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354
```



## 23.员工派遣

#### 🎃题目描述

> 某公司部门需要派遣员工去国外做项目，现在，代号为x的国家和代号为y的国家分别需要cntx名和cnty名员工，部门每个员工有一个员工号(1，2，3…)，工号连续，从1开始
>  
> 部长派遣员工的规则：
>  
> 1、从[1，k]中选择员工派遣出去
> 2、编号为x的倍数的员工不能去x国；编号为y的倍数的员工不能去y国
>  
> 问题：找到最小的k，使得可以将编号在[1，k]中的员工分配给x国和y国，且满足x国和y国的需求

------

#### 🎃输入输出

> 输入
> 四个整数 x，y， cntx，cnty；
> (2<=x<y<=30000；x和y一定是质数；1<=cntx，cnty<10 ^ 9 ； cntx+cnty<=10^9)
>  
> 输出
> 满足条件的最小的k

------

#### 🎃样例1

```java
输入
2 3 3 1

输出
5

说明:
输入说明:
2-表示国家代号2
3-表示国家代号3
3-表示国家2需要3个人
1-表示国家3需要1个人
123456789101112
```

------

### 二、思路参考

------

通过二分查找来确定满足条件的最小的k值。我们要找到一个k值，使得在这个k值以下的员工中，既能满足x国的需求，又能满足y国的需求。

我们首先初始化一个搜索范围，左边界为1，右边界为2 * (cntx + cnty)，确保范围足够大。然后，我们在这个范围内进行二分查找，每次选择中间值mid。

对于每个mid值，我们需要判断是否能够通过这些员工满足两个国家的需求。我们首先计算出不能去x国和y国的员工数量：not_x = k / x，not_y = k / y，not_both = k / (x * y)。然后，计算出可以去x国的员工数量：can_go_x = k - not_x，可以去y国的员工数量：can_go_y = k - not_y，既可以去x国也可以去y国的员工数量：can_go_both = k - not_x - not_y + not_both。

我们需要满足以下条件才能保证只通过这些员工满足两个国家的需求：

1. 可以去x国的员工数量can_go_x要大于等于x国的需求cntx；
2. 可以去y国的员工数量can_go_y要大于等于y国的需求cnty；
3. 可以去x国的员工数量can_go_x + 既可以去x国也可以去y国的员工数量can_go_both要大于等于x国的需求cntx；
4. 可以去y国的员工数量can_go_y + 既可以去x国也可以去y国的员工数量can_go_both要大于等于y国的需求cnty。

如果满足了上述条件，说明当前的mid值是一个可能的解，我们将其记录下来，并继续搜索更小的k值。如果不满足上述条件，说明当前的mid值不是一个解，我们需要继续搜索更大的k值。

最终，当left > right时，我们找到了满足条件的最小的k值，将其作为结果返回。

------

### 三、代码参考

```java
import java.util.Scanner;

public class Main {
    public static boolean isValid(int k, int x, int y, int cntx, int cnty) {
        int not_x = k / x;  // 不能去x国的员工数量
        int not_y = k / y;  // 不能去y国的员工数量
        int not_both = k / (x * y);  // 不能去x国和y国的员工数量
        int can_go_x = k - not_x;  // 可以去x国的员工数量
        int can_go_y = k - not_y;  // 可以去y国的员工数量
        int can_go_both = k - not_x - not_y + not_both;  // 既可以去x国也可以去y国的员工数量

        // 需要确定是否能够只通过这些员工满足两个国家的需求
        // 优先考虑去x国的员工数量，因为我们总是可以从既能去x国又能去y国的员工中挑选出一些去y国
        if (can_go_x >= cntx && can_go_y >= cnty && can_go_x + can_go_both >= cntx && can_go_y + can_go_both >= cnty) {
            return true;
        }
        return false;
    }

    public static int findMinimumK(int x, int y, int cntx, int cnty) {
        int left = 1;  // 初始的搜索范围的左边界
        int right = 2 * (cntx + cnty);  // 初始的搜索范围的右边界，保证足够大
        int result = right;  // 存储最终结果，初始为最大可能值
        while (left <= right) {
            int mid = (left + right) / 2;  // 计算中间值
            if (isValid(mid, x, y, cntx, cnty)) {
                result = Math.min(result, mid);  // 更新结果为更小的k值
                right = mid - 1;  // 继续搜索更小的k值
            } else {
                left = mid + 1;  // 搜索更大的k值
            }
        }
        return result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int x = scanner.nextInt();  // x国的国家代号
        int y = scanner.nextInt();  // y国的国家代号
        int cntx = scanner.nextInt();  // x国需要的员工数量
        int cnty = scanner.nextInt();  // y国需要的员工数量
        System.out.println(findMinimumK(x, y, cntx, cnty));  // 输出结果
    }
}

123456789101112131415161718192021222324252627282930313233343536373839404142434445
```



## 24.查找一个有向网络的头节点和尾节点 | 机试真题+思路参考+代码解析（C卷）

#### 🎃题目描述

> 给定一个有向图，图中可能包含有环，图使用二维矩阵表示，每一行的第一列表示起始节点，第二列表示终止节点，如[0，1]表示从0到1的路径，每人节点用正整数表示，求这个数据的首节点与尾节点
>  
> 题目给的用例会是一个首节点，但可能存在多个尾节点。同时，图中可能含有环；如果图中含有环，返回[-1]
>  
> 说明：入度为0是首节点，出度为0是尾节点
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8bf72e103f6c45f98fd41a57ade414fe.png)

------

#### 🎃输入输出

> 输入
> 第一行为后续输入的键值对数量N>=0，第二行为2N个数字；每两个为一个起点，一个终点
>  
> 输出
> 输出一行头节点和尾节点；如果有多个尾节点，按从大到小的顺序输出；
> 如果图有环，输出为-1

------

#### 🎃样例1

```java
输入
4
0 1 0 2 1 2 2 3

输出
0 3
123456
```

------

#### 🎃样例2

```java
输入
2
0 1 0 2

输出
0 1 2
123456
```

------

### 二、思路参考

------

1. 读取输入：首先，从标准输入中读取输入的键值对数量（N），然后读取键值对并将其转换为整数列表（edges）。
2. 构建图和计算节点的入度和出度：使用一个哈希映射（HashMap）来构建图，并使用另外两个哈希映射（HashMap）来记录每个节点的入度和出度。同时，使用一个集合（HashSet）来记录图中所有的节点。
   - 遍历键值对列表，对于每个键值对 [start, end]：
     - 将 start 添加到图中的键中，值为一个列表，将 end 添加到列表中，表示 start 和 end 之间有一条边。
     - 将 start 的出度加一，如果该节点之前没有出度记录，则默认为0。
     - 将 end 的入度加一，如果该节点之前没有入度记录，则默认为0。
     - 将 start 和 end 添加到节点集合中。
3. 查找首节点和尾节点：
   - 初始化首节点为 -1。
   - 初始化尾节点列表为空。
   - 遍历节点集合中的每个节点：
     - 如果该节点没有入度，则将其设置为首节点，如果首节点已经存在，则说明图有问题，返回 [-1]。
     - 如果该节点没有出度，则将其添加到尾节点列表中。
   - 如果首节点为 -1 或尾节点列表为空，则说明图有问题，返回 [-1]。
4. 检查是否存在环：使用深度优先搜索（DFS）算法来检查图中是否存在环。
   - 构建一个辅助函数 dfs，该函数接受当前节点、图、已访问的节点集合和当前递归调用堆栈集合作为参数。
   - 在 dfs 函数中，将当前节点标记为已访问，并将其添加到当前递归调用堆栈集合中。
   - 如果图中包含当前节点的邻接节点：
     - 对于每个邻接节点：
       - 如果邻接节点未被访问，则递归调用 dfs 函数。
       - 如果邻接节点已被访问且在当前递归调用堆栈集合中，说明存在环，返回 true。
   - 从当前递归调用堆栈集合中移除当前节点，并返回 false。
5. 返回结果：
   - 如果存在多个首节点或没有尾节点，则说明图有问题，返回 [-1]。
   - 如果存在环，则说明图有问题，返回 [-1]。
   - 对尾节点列表进行排序。
   - 创建一个结果数组，长度为尾节点列表长度加一。
   - 将首节点放入结果数组的第一个位置。
   - 将排序后的尾节点依次放入结果数组中。
   - 返回结果数组。

------

### 三、代码参考

```java
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt(); // 读取输入的键值对数量
        int[] edges = new int[2 * N];
        for (int i = 0; i < 2 * N; i++) {
            edges[i] = scanner.nextInt(); // 读取键值对，转换成整数数组
        }

        List<int[]> pairs = new ArrayList<>();
        for (int i = 0; i < 2 * N; i += 2) {
            pairs.add(new int[]{edges[i], edges[i + 1]}); // 将输入转换成[start, end]形式的数组列表
        }

        int[] result = findStartAndEndNodes(pairs); // 找到首节点和尾节点

        for (int node : result) {
            System.out.print(node + " "); // 打印结果
        }
    }

    public static int[] findStartAndEndNodes(List<int[]> pairs) {
        Map<Integer, Integer> indegrees = new HashMap<>(); // 记录每个节点的入度
        Map<Integer, Integer> outdegrees = new HashMap<>(); // 记录每个节点的出度
        Set<Integer> allNodes = new HashSet<>(); // 记录图中所有节点

        for (int[] pair : pairs) {
            int start = pair[0];
            int end = pair[1];
            outdegrees.put(start, outdegrees.getOrDefault(start, 0) + 1); // 增加起始节点的出度
            indegrees.put(end, indegrees.getOrDefault(end, 0) + 1); // 增加结束节点的入度
            allNodes.add(start); // 添加起始节点到节点集合
            allNodes.add(end); // 添加结束节点到节点集合
        }

        int startNode = -1; // 首节点
        List<Integer> endNodes = new ArrayList<>(); // 尾节点列表
        for (int node : allNodes) {
            if (!indegrees.containsKey(node)) { // 如果节点没有入度，说明是首节点
                if (startNode == -1) {
                    startNode = node;
                } else {
                    return new int[]{-1}; // 如果找到多于一个的首节点，则图有问题，返回[-1]
                }
            }
            if (!outdegrees.containsKey(node)) { // 如果节点没有出度，说明是尾节点
                endNodes.add(node);
            }
        }

        if (startNode == -1 || endNodes.isEmpty()) { // 如果没有找到首节点或尾节点，返回[-1]
            return new int[]{-1};
        }

        if (hasCycle(allNodes, pairs)) { // 如果图中存在环，则返回[-1]
            return new int[]{-1};
        }

        Collections.sort(endNodes); // 对尾节点列表进行排序

        int[] result = new int[endNodes.size() + 1];
        result[0] = startNode; // 第一个元素是首节点
        for (int i = 0; i < endNodes.size(); i++) {
            result[i + 1] = endNodes.get(i); // 后续元素是尾节点列表
        }

        return result; // 返回首节点和尾节点数组
    }

    public static boolean hasCycle(Set<Integer> allNodes, List<int[]> pairs) {
        Map<Integer, List<Integer>> graph = new HashMap<>(); // 构建图，使用邻接表表示
        for (int[] pair : pairs) {
            int start = pair[0];
            int end = pair[1];
            if (!graph.containsKey(start)) {
                graph.put(start, new ArrayList<>());
            }
            graph.get(start).add(end); // 添加边到图中
        }

        Set<Integer> visited = new HashSet<>(); // 用于标记已访问的节点
        Set<Integer> recStack = new HashSet<>(); // 用于记录当前递归调用堆栈中的节点

        for (int node : allNodes) {
            if (!visited.contains(node)) {
                if (dfs(node, graph, visited, recStack)) { // 使用深度优先搜索检查是否存在环
                    return true; // 如果存在环，返回true
                }
            }
        }

        return false; // 如果不存在环，返回false
    }

    public static boolean dfs(int node, Map<Integer, List<Integer>> graph, Set<Integer> visited, Set<Integer> recStack) {
        visited.add(node);
        recStack.add(node);

        if (graph.containsKey(node)) {
            for (int neighbor : graph.get(node)) { // 对当前节点的所有邻接节点进行深度优先搜索
                if (!visited.contains(neighbor)) {
                    if (dfs(neighbor, graph, visited, recStack)) {
                        return true; // 如果存在环，返回true
                    }
                } else if (recStack.contains(neighbor)) {
                    return true; // 如果当前节点已经在递归调用堆栈中，说明存在环，返回true
                }
            }
        }

        recStack.remove(node);
        return false; // 如果没有环，返回false
    }
}

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117
```



## 25.田忌赛马

#### 🎃题目描述

> 给定两个只包含数字的数组a，b；调整数组a里面数字的顺序，使得尽可能多的a[i] > b[i]；数组a和b中的数字各不相同；输出所有可以达到最优结果的a数组数量

------

#### 🎃输入输出

> 输入
> 输入的第一行是数组a中的数字，其中只包含数字，每两个数字之间相隔一个空格，a数组大小不超过10
> 输入的第一行是数组b中的数字，其中只包含数字，每两个数字之间相隔一个空格，b数组大小不超过10
>  
> 输出
> 输出所有可以达到最优结果的a数组数量

------

#### 🎃样例1

```java
输入
11 8 20
10 13 7

输出
1
123456
```

------

#### 🎃样例2

```java
输入
11 12 20
10 13 7

输出
2

说明：
有两个a数组的排列可以达到最优结果，[12,20,11]和[11,20,12]，故输出2
123456789
```

------

#### 🎃样例3

```java
输入
1 2 3
4 5 6

输出
6

说明：
a怎么样都会输，所以输出a数组所有的排列
123456789
```

------

### 二、思路参考

------

1. 定义一个方法 `countOptimalArrangements`，该方法接受两个参数：列表 `a` 和列表 `b`，返回一个整数。

2. 初始化最优结果的数量 `optimalCount` 为 0，当前最优结果的最大匹配数 `maxMatches` 为 0。

3. 使用回溯法计算列表 `a` 的全排列，将结果保存在一个列表 `aPermutations` 中。

4. 遍历列表

    

   ```
   a
   ```

    

   的全排列

    

   ```
   aPermutations
   ```

   ，对于每个排列

    

   ```
   perm
   ```

   ：

   - 初始化匹配数量 `matches` 为 0。
   - 遍历列表 `perm` 的每个元素 `perm[i]`，如果 `perm[i] > b[i]`，则将匹配数量 `matches` 加一。
   - 如果匹配数量 `matches` 大于当前最优结果的匹配数 `maxMatches`，则更新最优结果的匹配数为 `matches`，并重置最优结果数量 `optimalCount` 为 1。
   - 如果匹配数量 `matches` 等于当前最优结果的匹配数 `maxMatches`，则将最优结果数量 `optimalCount` 加一。

5. 返回最优结果数量 `optimalCount`。

6. 在 `main` 方法中，读取输入的列表 `a` 和 `b`，调用方法 `countOptimalArrangements` 计算最优结果的数量，将结果输出。

------

### 三、代码参考

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

    // 计算所有a的排列中，尽可能多的满足a[i] > b[i]的数量
    public static int countOptimalArrangements(List<Integer> a, List<Integer> b) {
        // 最优结果的数量初始化为0
        int optimalCount = 0;
        // 当前最优结果的最大匹配数初始化
        int maxMatches = 0;

        // 计算a的全排列
        List<List<Integer>> aPermutations = permute(a);

        // 遍历a的全排列
        for (List<Integer> perm : aPermutations) {
            // 计算当前排列下a[i] > b[i]的匹配数量
            int matches = 0;
            for (int i = 0; i < perm.size(); i++) {
                if (perm.get(i) > b.get(i)) {
                    matches++;
                }
            }
            // 如果匹配数量大于当前最优结果的匹配数，则更新最优结果的匹配数，并重置最优结果数量
            if (matches > maxMatches) {
                maxMatches = matches;
                optimalCount = 1;
            }
            // 如果匹配数量等于当前最优结果的匹配数，则最优结果的数量增加1
            else if (matches == maxMatches) {
                optimalCount++;
            }
        }

        return optimalCount;
    }

    // 计算列表的全排列
    public static List<List<Integer>> permute(List<Integer> nums) {
        List<List<Integer>> permutations = new ArrayList<>();
        backtrack(nums, new ArrayList<>(), permutations);
        return permutations;
    }

    // 回溯法计算全排列
    public static void backtrack(List<Integer> nums, List<Integer> permutation, List<List<Integer>> permutations) {
        // 如果当前排列长度等于原列表长度，则将其添加到结果集合中
        if (permutation.size() == nums.size()) {
            permutations.add(new ArrayList<>(permutation));
        } else {
            // 遍历原列表中的每个元素
            for (int i = 0; i < nums.size(); i++) {
                // 如果当前元素已经在排列中，则跳过
                if (permutation.contains(nums.get(i))) {
                    continue;
                }
                // 将当前元素添加到排列中
                permutation.add(nums.get(i));
                // 递归调用下一层
                backtrack(nums, permutation, permutations);
                // 回溯，将当前元素从排列中移除
                permutation.remove(permutation.size() - 1);
            }
        }
    }

    public static void main(String[] args) {
        // 输入处理
        Scanner scanner = new Scanner(System.in);
        List<Integer> a = new ArrayList<>();
        List<Integer> b = new ArrayList<>();
        String[] aInput = scanner.nextLine().trim().split(" ");
        String[] bInput = scanner.nextLine().trim().split(" ");
        for (String s : aInput) {
            a.add(Integer.parseInt(s));
        }
        for (String s : bInput) {
            b.add(Integer.parseInt(s));
        }

        // 计算最优结果的数量
        int result = countOptimalArrangements(a, b);

        // 输出结果
        System.out.println(result);
    }
}
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091
```



## 26.结对编程

#### 🎃题目描述

> 某部门计划通过结队编程来进行项目开发，已知该部门有N名员工，每个员工有独一无二的职级，每三个员工形成一个小组进行结队编程，结队分组规则如下：
>  
> 从部门中选出序号分别为 i、j、k 的3名员工，他们的职级分贝为 level[i]，level[j]，level lk]，结队小组满足 level[i] < level[j] < level[k] 或者 level[i] > level[j] > level[k]，其中0<=i<=j<n
>  
> 请你按上述条件计算可能组合的小组数量，同一员工可以参加多个小组

------

#### 🎃输入输出

> 输入
> 第一行输入：员工总数 n
> 第二行输入： 按序号依次排列的员工的职级 level，中间用空格隔开
>  
> 输出
> 可能结队的小组数量

------

#### 🎃样例1

```java
输入
4
1 2 3 4

输出
4

说明：
可能结对成的组合(1,2,3)、(1,2,4)、(1,3,4)、(2,3,4)
123456789
```

------

#### 🎃样例2

```java
输入
3
5 4 7

输出
0


说明：
根据结对条件，无法组建小组
12345678910
```

------

### 二、思路参考

------

1. 定义一个方法 `countTeams`，该方法接受两个参数：整数 `n` 和整数数组 `levels`，返回一个整数。

2. 初始化小组数量 `count` 为 0。

3. 遍历每个可能成为中间职级的员工，使用变量 `j` 控制遍历。

4. 对于中间员工 `j`，初始化左侧较小职级的员工数量 `lessLeft` 和左侧较大职级的员工数量 `greaterLeft` 为 0。

5. 遍历中间员工

    

   ```
   j
   ```

    

   左侧的所有员工，使用变量

    

   ```
   i
   ```

    

   控制遍历。

   - 如果 `levels[i] < levels[j]`，则将 `lessLeft` 加一。
   - 如果 `levels[i] > levels[j]`，则将 `greaterLeft` 加一。

6. 对于中间员工 `j`，初始化右侧较小职级的员工数量 `lessRight` 和右侧较大职级的员工数量 `greaterRight` 为 0。

7. 遍历中间员工

    

   ```
   j
   ```

    

   右侧的所有员工，使用变量

    

   ```
   k
   ```

    

   控制遍历。

   - 如果 `levels[k] < levels[j]`，则将 `lessRight` 加一。
   - 如果 `levels[k] > levels[j]`，则将 `greaterRight` 加一。

8. 计算以 `j` 为中间职级的小组数量，并累加到总数 `count` 中，计算公式为 `lessLeft * greaterRight + greaterLeft * lessRight`。

9. 返回小组数量 `count`。

10. 在 `main` 方法中，读取输入的员工总数 `n` 和员工的职级 `levels`，调用方法 `countTeams` 计算小组数量，将结果输出。

------

### 三、代码参考

```java
import java.util.Scanner;

public class Main {

    public static int countTeams(int n, int[] levels) {
        // 初始化小组数量为0
        int count = 0;

        // 遍历每个可能成为中间职级的员工
        for (int j = 0; j < n; j++) {
            int lessLeft = 0;
            int greaterLeft = 0;

            // 对于中间员工j，遍历其左侧所有员工
            for (int i = 0; i < j; i++) {
                if (levels[i] < levels[j]) {
                    lessLeft++;
                } else if (levels[i] > levels[j]) {
                    greaterLeft++;
                }
            }

            int lessRight = 0;
            int greaterRight = 0;

            // 对于中间员工j，遍历其右侧所有员工
            for (int k = j + 1; k < n; k++) {
                if (levels[k] < levels[j]) {
                    lessRight++;
                } else if (levels[k] > levels[j]) {
                    greaterRight++;
                }
            }

            // 计算以j为中间职级的小组数量，并累加到总数中
            count += lessLeft * greaterRight + greaterLeft * lessRight;
        }

        return count;
    }

    public static void main(String[] args) {
        // 输入处理
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();  // 输入员工总数
        int[] levels = new int[n];  // 输入员工的职级，将其转换成整数数组
        for (int i = 0; i < n; i++) {
            levels[i] = scanner.nextInt();
        }

        // 调用函数并输出结果
        System.out.println(countTeams(n, levels));
    }
}
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354
```



## 27.文本统计分析

#### 🎃题目描述

有一个文件，包含以一定规则写作的文本，请统计文件中包含的文本数量
 
规则如下：

1、文本以"；“分隔，最后一条可以没有”；“，但空文本不能算语句，比如"COMMAND A;;” 只能算一条语句；注意：无字符/空白字符/制表都算作"空"文本；
 
2、文本可以跨行，比如下面，是一条文本，而不是三条

```c
COMMANDA
AND
COMMAND B;
123
```

3、文本支持字符串，字符串为成对的单引号(')或者成对的双号(“)，字符串可能出现用转义字符()处理的单双号(“your input is””) 和转义字符本身，比如：COMMAND A"Say “hello”“；
 
4、支持注释，可以出现在字符串之外的任意位置注释以”-"开头，到换行结束，比如：

COMMAND A；-this is comment
COMMAND -comment
A AND COMMAND B；
 
注意字符串内的"-"，不是注释

------

#### 🎃输入输出

> 输入
> 一个文本字符串
>  
> 输出
> 包含的文本数量

------

#### 🎃样例1

```java
输入
COMMAND TABLE IF EXISTS "UNITED STATE";
COMMAND A GREAT (
ID ADSAB,
download_length INTE-GER, -- test
file_name TEXT,
guid TEXT,
mime_type TEXT,
notifica-tionid INTEGER,
original_file_name TEXT,
pause_reason_type INTEGER,
resumable_flag INTEGER,
start_time INTEGER,
state INTEGER,
folder TEXT,
path TEXT,
total_length INTE-GER,
url TEXT
);


输出
2
1234567891011121314151617181920212223
```

------

### 二、思路参考

------

1. 初始化状态变量：`in_single_quote`、`in_double_quote`和`in_comment`都设置为`False`，`statement_count`设置为0，`escape`和`non_space_encountered`都设置为`False`。
2. 遍历输入文本中的每个字符：
   - 如果当前字符是`-`，且不在单引号和双引号内，并且下一个字符是`-`，则表示进入了注释，将`in_comment`设置为`True`，继续下一次循环。
   - 如果当前字符是换行符`\n`，则表示注释结束，将`in_comment`设置为`False`。
   - 如果当前在注释中，忽略当前字符，继续下一次循环。
   - 如果`escape`为`True`，表示当前字符是转义字符，将`escape`设置为`False`，继续下一次循环。
   - 如果当前字符是`\`，且在单引号或双引号中，则表示遇到了转义字符，将`escape`设置为`True`，继续下一次循环。
   - 如果当前字符是`'`，且不在双引号中，则表示进入了单引号内部，将`in_single_quote`取反，将`non_space_encountered`设置为`True`，继续下一次循环。
   - 如果当前字符是`"`，且不在单引号中，则表示进入了双引号内部，将`in_double_quote`取反，将`non_space_encountered`设置为`True`，继续下一次循环。
   - 如果当前字符不是空白字符（使用`strip()`方法判断），则将`non_space_encountered`设置为`True`。
   - 如果当前字符是`;`，且不在单引号和双引号中，则表示遇到了分隔符。如果`non_space_encountered`为`True`，表示之前遇到了非空字符，将`statement_count`加1，将`non_space_encountered`设置为`False`。
3. 检查是否有非空文本结尾：如果`non_space_encountered`为`True`，表示在循环结束前遇到了非空字符，将`statement_count`加1。
4. 返回`statement_count`作为结果。

------

### 三、代码参考

```java
public class Main {
    
    public static int countStatements(String inputText) {
        // 初始化状态
        boolean inSingleQuote = false; // 是否在单引号内
        boolean inDoubleQuote = false; // 是否在双引号内
        boolean inComment = false; // 是否在注释内
        int statementCount = 0; // 语句数量
        boolean escape = false; // 是否遇到转义字符
        boolean nonSpaceEncountered = false; // 是否遇到非空字符
        
        // 遍历文本字符
        for (int i = 0; i < inputText.length(); i++) {
            char c = inputText.charAt(i);
            
            // 检查注释
            if (c == '-' && !inSingleQuote && !inDoubleQuote && i < inputText.length() - 1 && inputText.charAt(i + 1) == '-') {
                inComment = true;
                continue;
            }
            
            // 检查换行符，结束注释
            if (c == '\n') {
                inComment = false;
            }
            
            // 如果在注释中，忽略当前字符
            if (inComment) {
                continue;
            }
            
            // 跳过转义的字符
            if (escape) {
                escape = false;
                continue;
            }
            
            // 检查转义字符
            if (c == '\\' && (inSingleQuote || inDoubleQuote)) {
                escape = true;
                continue;
            }
            
            // 检查单引号
            if (c == '\'' && !inDoubleQuote) {
                inSingleQuote = !inSingleQuote;
                nonSpaceEncountered = true;
                continue;
            }
            
            // 检查双引号
            if (c == '"' && !inSingleQuote) {
                inDoubleQuote = !inDoubleQuote;
                nonSpaceEncountered = true;
                continue;
            }
            
            // 如果字符不是空白，标记非空字符出现
            if (!Character.isWhitespace(c)) {
                nonSpaceEncountered = true;
            }
            
            // 检查分隔符；如果不在引号中，则计数
            if (c == ';' && !inSingleQuote && !inDoubleQuote) {
                if (nonSpaceEncountered) {
                    statementCount++;
                    nonSpaceEncountered = false;
                }
            }
        }
        
        // 检查最后是否有非空的文本
        if (nonSpaceEncountered) {
            statementCount++;
        }
        
        return statementCount;
    }
    
    public static void main(String[] args) {
        // 输入样例
        String inputText = "COMMAND TABLE IF EXISTS \"UNITED STATE\";\n" +
                "COMMAND A GREAT (\n" +
                "ID ADSAB,\n" +
                "download_length INTE-GER, -- test\n" +
                "file_name TEXT,\n" +
                "guid TEXT,\n" +
                "mime_type TEXT,\n" +
                "notifica-tionid INTEGER,\n" +
                "original_file_name TEXT,\n" +
                "pause_reason_type INTEGER,\n" +
                "resumable_flag INTEGER,\n" +
                "start_time INTEGER,\n" +
                "state INTEGER,\n" +
                "folder TEXT,\n" +
                "path TEXT,\n" +
                "total_length INTE-GER,\n" +
                "url TEXT\n" +
                ");";
        
        // 调用方法并输出结果
        System.out.println(countStatements(inputText));
    }
}

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105
```



## 28.两个字符串间的最短路径问题 | 机试真题+思路参考+代码解析（最新C卷抽中）

#### 🎃题目描述

> 给定两个字符串，分别为字符串A与字符串B；例如A字符串为ABCABBA，B字符串为CBABAC可以得到下图m*n的二维数组，定义原点为(0，0)，终点为(m，n)，水平与垂直的每一条边距离为1，映射成坐标系如下图
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/97489fa7411144deaa68ada59720f0d3.png)
>  
> 从原点(0，0)到(0，A)为水平边，距离为1，从(0，A)到(A，C)为垂直边，距离为1；假设两人字符串同一位置的两个字符相同则可以作一个斜边，如(A，C)到(B，B)最短距离为斜边，距离同样为1；
>  
> 作出所有的斜边如下图，(0，0)到(B，B)的距离为 1个水平边 +1个垂直边 + 1个斜边 =3
>  
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/06f6f62df1e84b2ba49358835b7415b4.png)
>  
> 根据定义可知，原点到终点的最短距离路径如下图红线标记，最短距离为9
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3f196b62f77846d990369f7e7927375d.png)

------

#### 🎃输入输出

> 输入
> 空格分割的两个字符串A与字符串B，字符串不为"空串”，字符格式满足正则规则：[A-Z]，字符串长度< 10000
>  
> 输出
> 原点到终点的最短距离

------

#### 🎃样例1

```java
输入
ABC ABC


输出
3
123456
```

------

#### 🎃样例2

```java
输入
ABCAABA  CBABAC


输出
9
123456
```

### 二、思路参考

------

1. 首先，获取输入字符串A和B的长度m和n。
2. 创建一个大小为(m+1) x (n+1)的二维数组dp，用于保存每个位置的最短距离。
3. 初始化边界条件，即只有水平或垂直移动的情况。对于dp[i][0]，表示A的前i个字符和B的前0个字符的最短距离，初始化为i，因为只能进行i次删除操作来匹配B的空字符串。对于dp[0][j]，表示A的前0个字符和B的前j个字符的最短距离，初始化为j，因为只能进行j次插入操作来匹配A的空字符串。
4. 使用动态规划的方式填表，从左上角开始逐步计算dp[i][j]。在计算dp[i][j]时，有两种情况：
   - 如果A的第i个字符和B的第j个字符相等，即A.charAt(i-1) == B.charAt(j-1)，则可以将这两个字符匹配，此时dp[i][j]等于dp[i-1][j-1] + 1，表示在A的前i-1个字符和B的前j-1个字符的最短距离上加上1。
   - 如果A的第i个字符和B的第j个字符不相等，即A.charAt(i-1) != B.charAt(j-1)，则无法将这两个字符匹配。此时，可以选择进行删除操作或插入操作，取删除操作和插入操作中的最短距离。删除操作对应的是dp[i-1][j]，表示在A的前i-1个字符和B的前j个字符的最短距离上加上1，表示删除A的第i个字符。插入操作对应的是dp[i][j-1]，表示在A的前i个字符和B的前j-1个字符的最短距离上加上1，表示在A的第i个字符后面插入B的第j个字符。
5. 最后，返回dp[m][n]，即从原点(0, 0)到终点(m, n)的最短距离，即A和B的最短距离。

------

### 三、代码参考

```java
public class Main {

    public static int shortestDistance(String A, String B) {
        int m = A.length();
        int n = B.length();

        // 创建一个 (m+1) x (n+1) 的二维数组 dp，所有元素初始化为0
        int[][] dp = new int[m+1][n+1];

        // 初始化边界条件，即只有水平或垂直移动的情况
        for (int i = 1; i <= m; i++) {
            dp[i][0] = i;
        }
        for (int j = 1; j <= n; j++) {
            dp[0][j] = j;
        }

        // 动态规划填表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 如果当前字符匹配，则可以斜线移动
                if (A.charAt(i-1) == B.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    // 否则，取水平移动和垂直移动中的最短路径
                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + 1;
                }
            }
        }

        // 返回从原点到终点的最短距离
        return dp[m][n];
    }

    public static void main(String[] args) {
        // 输入样例
        String A = "ABC";
        String B = "ABC";

        // 调用方法并输出结果
        System.out.println(shortestDistance(A, B));
    }
}

1234567891011121314151617181920212223242526272829303132333435363738394041424344
```

