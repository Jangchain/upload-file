
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="OD_2"></a>华为OD面试真题精选</h2> 
<p>🌟 强烈推荐：华为OD技术面试真题精选 🌟</p> 
<p>大家好！今天我给大家推荐一份备受赞誉的华为OD技术面试精选题目。 所有题目均为华为od实际面试过程中出现的问题。这些面试题主要涉及到编程八股文、职业态度以及独特的个性特点。让我们一起深入了解这个精心整理的面试题集吧！😊 希望这些问题能够帮助你在面试中脱颖而出，展现出你的技术实力和独特魅力。加油！💪💼</p> 
<p>专栏：<a href="https://blog.csdn.net/banxia_frontend/category_12436481.html">华为OD面试真题精选</a></p> 
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e9413fcd109f2f3d7297192eab0c0b2a.gif" alt="doutub_gif"></p> 
<h2><a id="stringlistliststring_14"></a>string怎么转list，list怎么转string</h2> 
<h3><a id="_16"></a>字符串转列表</h3> 
<h4><a id="Stringsplit_18"></a>使用String.split()</h4> 
<pre><code class="prism language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"apple,banana,orange"</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这是最常见和简单的方法。<code>split()</code>方法根据给定的正则表达式分隔字符串,返回一个字符串数组。然后使用<code>Arrays.asList()</code>将该数组转换为列表。</p> 
<p>注意<code>Arrays.asList()</code>返回的是一个受内部数组支持的固定大小列表,不能进行添加或删除操作。如果需要可变大小的列表,可以构造一个新的ArrayList:</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="StringTokenizer_33"></a>使用StringTokenizer</h4> 
<pre><code class="prism language-java"><span class="token class-name">StringTokenizer</span> st <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringTokenizer</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">hasMoreTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>StringTokenizer</code>是一个遗留的类,在处理基于分隔符的字符串时提供了一些额外的功能,比如识别连续的分隔符。但通常建议使用<code>split()</code>方法。</p> 
<h4><a id="Stream_45"></a>使用Stream</h4> 
<p>Java 8引入的Stream API提供了一种函数式编程风格:</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>
                           <span class="token punctuation">.</span><span class="token function">splitAsStream</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
                           <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这种方式代码更加简洁,但可读性和性能可能会受到影响。</p> 
<h3><a id="_57"></a>列表转字符串</h3> 
<h4><a id="Stringjoin_59"></a>使用String.join()</h4> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">,</span><span class="token string">"banana"</span><span class="token punctuation">,</span><span class="token string">"orange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>String.join()</code>是Java 8引入的一个静态方法,可以很方便地将列表元素拼接为字符串。第一个参数是分隔符,第二个参数是列表。</p> 
<h4><a id="StringJoiner_68"></a>使用StringJoiner</h4> 
<pre><code class="prism language-java"><span class="token class-name">StringJoiner</span> sj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringJoiner</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    sj<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> sj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>StringJoiner</code>类提供了一种简单的可重入格式化对象,可用于构造字符串连接操作的字符序列。</p> 
<h4><a id="StringBuilder_80"></a>使用StringBuilder</h4> 
<pre><code class="prism language-java"><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_97"></a>抽象类和接口的区别</h2> 
<h3><a id="Abstract_Class_99"></a>抽象类(Abstract Class)</h3> 
<ul><li>抽象类可以包含抽象方法(没有方法体)和具体方法</li><li>抽象类不能被实例化,需要被继承并重写其抽象方法</li><li>一个类只能继承一个抽象类</li><li>抽象类可以有构造方法,用于初始化</li><li>抽象类可以有静态方法和静态变量</li><li>抽象类可以有访问修饰符(public,protected,default,private)</li></ul> 
<h3><a id="Interface_108"></a>接口(Interface)</h3> 
<ul><li>接口完全是抽象的,只包含常量和抽象方法</li><li>接口不能被实例化,需要被实现(implements)</li><li>一个类可以实现多个接口</li><li>接口中所有的方法默认都是公有的(public)</li><li>接口中所有的字段默认都是公有的、静态的、最终的(public static final)</li><li>接口不能有构造方法</li><li>从Java 8开始,接口可以有默认方法和静态方法</li></ul> 
<h3><a id="_118"></a>主要区别</h3> 
<ol><li> <p><strong>继承 vs 实现</strong></p> 
  <ul><li>类继承抽象类,可以重写抽象方法</li><li>类实现接口,需要重写接口中的所有抽象方法</li></ul> </li><li> <p><strong>单继承 vs 多实现</strong></p> 
  <ul><li>一个类只能继承一个抽象类</li><li>一个类可以实现多个接口</li></ul> </li><li> <p><strong>访问修饰符</strong></p> 
  <ul><li>抽象类中的成员可以有不同的访问修饰符</li><li>接口中的所有方法和字段都是公有的</li></ul> </li><li> <p><strong>构造方法</strong></p> 
  <ul><li>抽象类可以有构造方法</li><li>接口不能有构造方法</li></ul> </li><li> <p><strong>字段</strong></p> 
  <ul><li>抽象类可以有实例字段</li><li>接口中只能有常量字段(public static final)</li></ul> </li><li> <p><strong>主要用途</strong></p> 
  <ul><li>抽象类主要用于代码复用,提供部分实现</li><li>接口主要用于定义规范,实现多重继承</li></ul> </li></ol> 
<p>总的来说,抽象类更适合做代码复用,接口更适合定义规范。</p> 
<h2><a id="_148"></a>分布式锁</h2> 
<p>分布式锁是一种在分布式系统中用于控制共享资源访问的机制。它确保在同一时间只有一个进程或线程可以访问共享资源,避免了并发访问导致的数据不一致问题。</p> 
<h3><a id="_154"></a>分布式锁的特点</h3> 
<ol><li><strong>互斥性</strong>: 在任意时刻,只有一个客户端能持有锁。</li><li><strong>高可用</strong>: 分布式锁服务需要高可用,不能存在单点故障。</li><li><strong>高性能</strong>: 获取和释放锁的操作需要快速高效。</li><li><strong>可重入</strong>: 同一个客户端可以多次获取同一把锁。</li><li><strong>安全性</strong>: 锁的持有和释放必须是同一个客户端,不能把别人的锁给释放了。</li><li><strong>死锁避免</strong>: 必须有超时机制或撤销机制,避免死锁。</li></ol> 
<h3><a id="_163"></a>分布式锁的实现方式</h3> 
<ol><li> <p><strong>基于数据库实现</strong></p> 
  <ul><li>利用数据库的唯一约束,如MySQL的<code>for update</code>语句。</li><li>优点: 简单,易于理解。</li><li>缺点: 性能差,容易产生死锁,不可重入。</li></ul> </li><li> <p><strong>基于缓存实现(如Redis)</strong></p> 
  <ul><li>利用Redis的<code>setnx</code>(set if not exists)命令。</li><li>优点: 性能好,可重入,避免死锁。</li><li>缺点: 需要考虑Redis的可用性和一致性问题。</li></ul> </li><li> <p><strong>基于Zookeeper实现</strong></p> 
  <ul><li>利用Zookeeper的临时有序节点。</li><li>优点: 高可用,可重入,避免死锁。</li><li>缺点: 实现复杂,需要考虑Zookeeper的性能和可靠性。</li></ul> </li><li> <p><strong>基于Etcd实现</strong></p> 
  <ul><li>利用Etcd的lease机制。</li><li>优点: 高可用,高性能,可重入。</li><li>缺点: 实现复杂,Etcd集群的运维成本高。</li></ul> </li></ol> 
<h3><a id="_185"></a>使用场景</h3> 
<p>分布式锁适用于以下场景:</p> 
<ol><li>分布式系统中的并发控制,如秒杀、抢红包等。</li><li>分布式任务调度,避免重复执行。</li><li>分布式缓存,避免缓存击穿和雪崩。</li><li>分布式事务,实现两阶段提交。</li></ol> 
<h3><a id="_194"></a>注意事项</h3> 
<p>使用分布式锁时需要注意以下问题:</p> 
<ol><li>锁的粒度不要太大,避免影响性能。</li><li>获取锁和释放锁要成对出现,避免死锁。</li><li>锁的有效期要合理设置,避免长时间持有锁。</li><li>要有重试机制和异常处理,提高系统的健壮性。</li><li>不同的实现方式各有优缺点,要根据实际需求选择。</li></ol> 
<h2><a id="sql_206"></a>sql注入</h2> 
<p>SQL注入是一种常见的Web安全漏洞,攻击者通过在用户输入中插入特殊字符或SQL语句片段,欺骗应用程序执行非预期的SQL查询,从而获取敏感信息或破坏数据完整性。</p> 
<h3><a id="SQL_212"></a>SQL注入的原理</h3> 
<p>SQL注入发生的原因是应用程序没有正确过滤或转义用户输入,直接将其拼接到SQL查询语句中。例如:</p> 
<pre><code class="prism language-java"><span class="token class-name">String</span> query <span class="token operator">=</span> <span class="token string">"SELECT * FROM users WHERE username='"</span> <span class="token operator">+</span> username <span class="token operator">+</span> <span class="token string">"' AND passwor d='"</span> <span class="token operator">+</span> passwor d <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">;</span>
</code></pre> 
<p>如果攻击者输入的username为<code>' OR 1=1--</code>,那么最终执行的SQL语句就变成了:</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> username<span class="token operator">=</span><span class="token string">''</span> <span class="token operator">OR</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token comment">--' AND passwor d=''</span>
</code></pre> 
<p>这样就绕过了身份验证,可以在不知道密码的情况下登录任意用户。</p> 
<h3><a id="SQL_228"></a>SQL注入的危害</h3> 
<p>SQL注入可能导致以下危害:</p> 
<ol><li>绕过身份验证,未授权访问。</li><li>窃取敏感数据,如用户信息、财务数据等。</li><li>篡改或删除数据,破坏数据完整性。</li><li>执行恶意操作,如向系统中插入木马、后门等。</li><li>导致拒绝服务攻击,耗尽服务器资源。</li></ol> 
<h3><a id="SQL_238"></a>防范SQL注入的措施</h3> 
<ol><li> <p><strong>使用预编译语句(PreparedStatement)</strong></p> 
  <ul><li>预编译语句会将SQL语句和参数分开处理,避免了拼接产生的漏洞。</li><li>示例:<pre><code class="prism language-java"><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"SELECT * FROM users WHERE username=? AND passwor d=?"</span><span class="token punctuation">;</span>
<span class="token class-name">PreparedStatement</span> stmt <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
stmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>
stmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> passwor d<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p><strong>使用ORM框架</strong></p> 
  <ul><li>像Hibernate、MyBatis这样的ORM框架会自动处理SQL参数,避免了手动拼接SQL的风险。</li></ul> </li><li> <p><strong>过滤和转义用户输入</strong></p> 
  <ul><li>对用户输入进行严格的验证和过滤,如长度限制、格式校验、特殊字符转义等。</li><li>可以使用一些成熟的过滤库,如OWASP的ESAPI。</li></ul> </li><li> <p><strong>限制数据库权限</strong></p> 
  <ul><li>为应用程序设置最小权限的数据库账号,避免权限过大带来的风险。</li></ul> </li><li> <p><strong>使用Web应用防火墙(WAF)</strong></p> 
  <ul><li>WAF可以检测和阻止常见的SQL注入攻击。</li></ul> </li></ol> 
<h2><a id="_269"></a>异常分类</h2> 
<p>在Java中,所有的异常都派生自<code>java.lang.Throwable</code>类。<code>Throwable</code>类有两个主要子类:<code>Error</code>和<code>Exception</code>。</p> 
<h3><a id="Error_275"></a>Error</h3> 
<p><code>Error</code>类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。这些错误通常是不可恢复的,应用程序不应该试图捕获或处理这些错误。一些常见的<code>Error</code>类型包括:</p> 
<ol><li><strong>OutOfMemoryError</strong>: 当Java虚拟机无法分配对象所需的内存时抛出。</li><li><strong>StackOverflowError</strong>: 当应用程序递归太深导致栈溢出时抛出。</li><li><strong>NoClassDefFoundError</strong>: 当Java虚拟机无法加载所需的类时抛出。</li></ol> 
<h3><a id="Exception_283"></a>Exception</h3> 
<p><code>Exception</code>类是程序员可以捕获和处理的异常。<code>Exception</code>类又分为两种类型:</p> 
<h4><a id="1_Checked_Exception_287"></a>1. 已检查异常(Checked Exception)</h4> 
<p>已检查异常是编译器可以检测到的异常,程序员必须显式地捕获或抛出这些异常。一些常见的已检查异常包括:</p> 
<ul><li><strong>IOException</strong>: 当发生输入/输出操作失败时抛出。</li><li><strong>SQLException</strong>: 当发生数据库操作失败时抛出。</li><li><strong>ClassNotFoundException</strong>: 当Java虚拟机无法加载所需的类时抛出。</li></ul> 
<h4><a id="2_Unchecked_Exception_295"></a>2. 未检查异常(Unchecked Exception)</h4> 
<p>未检查异常是编译器无法检测到的异常,程序员可以选择捕获或不捕获。未检查异常通常是由于程序错误导致的,如空指针引用、数组下标越界等。一些常见的未检查异常包括:</p> 
<ul><li><strong>NullPointerException</strong>: 当应用程序试图在null对象上调用实例方法时抛出。</li><li><strong>ArrayIndexOutOfBoundsException</strong>: 当应用程序试图访问数组中不存在的索引时抛出。</li><li><strong>ArithmeticException</strong>: 当发生算术运算错误时抛出,如除数为零。</li></ul> 
<h3><a id="_303"></a>异常处理</h3> 
<p>在Java中,我们可以使用<code>try-catch-finally</code>语句块来捕获和处理异常。<code>try</code>块包含可能抛出异常的代码,<code>catch</code>块捕获并处理异常,<code>finally</code>块用于执行必须执行的清理代码。</p> 
<pre><code class="prism language-java"><span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 可能抛出异常的代码</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception1</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 处理Exception1异常</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception2</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 处理Exception2异常</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 清理代码</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="redis_321"></a>redis过期策略</h2> 
<p>Redis是一个高性能的内存数据库,支持多种数据结构和丰富的功能。其中,Redis的过期策略是一个重要的特性,用于自动删除过期的键,释放内存空间。</p> 
<h3><a id="Redis_327"></a>Redis的过期策略</h3> 
<p>Redis提供了两种过期策略:</p> 
<ol><li> <p><strong>被动过期(Passive Expiration)</strong></p> 
  <ul><li>当客户端访问一个键时,Redis会检查该键是否已过期。如果已过期,则删除该键并返回空值。</li><li>优点是节省CPU资源,只有在访问键时才进行过期检查。</li><li>缺点是可能存在过期键未被及时删除,占用内存空间。</li></ul> </li><li> <p><strong>主动过期(Active Expiration)</strong></p> 
  <ul><li>Redis会定期随机抽取一些键进行过期检查,如果发现过期键则删除。</li><li>优点是可以及时删除过期键,释放内存空间。</li><li>缺点是会占用一定的CPU资源进行过期检查。</li></ul> </li></ol> 
<h3><a id="_341"></a>过期键的删除策略</h3> 
<p>Redis采用了以下策略来删除过期键:</p> 
<ol><li> <p><strong>惰性删除(Lazy Deletion)</strong></p> 
  <ul><li>在访问键时,如果发现键已过期,则删除该键。</li><li>优点是节省CPU资源,只有在访问键时才进行删除操作。</li><li>缺点是可能存在过期键未被及时删除,占用内存空间。</li></ul> </li><li> <p><strong>定期删除(Periodic Deletion)</strong></p> 
  <ul><li>Redis会定期随机抽取一些键进行过期检查,如果发现过期键则删除。</li><li>定期删除的频率和检查的键数量可以通过配置文件进行调整。</li><li>优点是可以及时删除过期键,释放内存空间。</li><li>缺点是会占用一定的CPU资源进行过期检查。</li></ul> </li></ol> 
<h3><a id="_356"></a>过期键的淘汰策略</h3> 
<p>当Redis内存不足时,会触发内存淘汰机制。Redis提供了以下几种淘汰策略:</p> 
<ol><li><strong>noeviction</strong>: 不淘汰任何键,当内存不足时,新写入操作会报错。</li><li><strong>allkeys-lru</strong>: 淘汰整个键值字典中最久未使用(Least Recently Used)的键。</li><li><strong>volatile-lru</strong>: 淘汰设置了过期时间的键中最久未使用的键。</li><li><strong>allkeys-random</strong>: 随机淘汰整个键值字典中的键。</li><li><strong>volatile-random</strong>: 随机淘汰设置了过期时间的键。</li><li><strong>volatile-ttl</strong>: 淘汰设置了过期时间的键中剩余寿命(Time To Live)最短的键。</li></ol> 
<p>可以根据实际需求选择合适的淘汰策略,平衡内存使用和数据持久性。</p> 
<h3><a id="_369"></a>过期时间的设置</h3> 
<p>可以使用以下命令为键设置过期时间:</p> 
<ul><li><code>EXPIRE key seconds</code>: 为键设置秒级过期时间。</li><li><code>PEXPIRE key milliseconds</code>: 为键设置毫秒级过期时间。</li><li><code>EXPIREAT key timestamp</code>: 为键设置秒级Unix时间戳过期时间。</li><li><code>PEXPIREAT key milliseconds-timestamp</code>: 为键设置毫秒级Unix时间戳过期时间。</li></ul> 
<h2><a id="RocketMQ_380"></a>RocketMQ怎么保证集群模式下顺序消费</h2> 
<p>RocketMQ是一个分布式消息队列系统,支持集群部署以提高可用性和吞吐量。在集群模式下,RocketMQ通过以下机制来保证消息的顺序消费:</p> 
<h3><a id="1__386"></a>1. 消息队列的顺序性</h3> 
<p>RocketMQ的消息队列是一个FIFO(First In First Out)队列,即先进入队列的消息会先被消费。每个消息队列内部的消息是有序的,消费者按照消息在队列中的顺序进行消费。</p> 
<h3><a id="2_Message_Partitioning_390"></a>2. 消息分区(Message Partitioning)</h3> 
<p>RocketMQ支持将消息按照一定的规则分区,将具有相同特征的消息发送到同一个消息队列中。通常,可以根据消息的某个字段(如订单ID)进行分区,保证相关联的消息在同一个队列中,从而实现顺序消费。</p> 
<h3><a id="3__394"></a>3. 消费者的顺序消费</h3> 
<p>RocketMQ的消费者可以通过设置消费模式为<code>CONSUME_FROM_FIRST_OFFSET</code>或<code>CONSUME_FROM_LAST_OFFSET</code>来保证顺序消费。</p> 
<ul><li><code>CONSUME_FROM_FIRST_OFFSET</code>: 从队列的开头开始消费,保证消费者按照消息在队列中的顺序进行消费。</li><li><code>CONSUME_FROM_LAST_OFFSET</code>: 从队列的末尾开始消费,保证消费者按照消息到达队列的顺序进行消费。</li></ul> 
<h3><a id="4__401"></a>4. 消费者的并发控制</h3> 
<p>为了保证顺序消费,RocketMQ要求同一个消费者组内的消费者数量不能超过订阅的消息队列数量。这样可以确保每个消费者只消费一个或多个特定的消息队列,而不会出现多个消费者同时消费同一个队列的情况,从而保证了顺序消费。</p> 
<h3><a id="5__405"></a>5. 消息重试机制</h3> 
<p>RocketMQ提供了消息重试机制,当消费者消费消息失败时,消息会重新发送给消费者进行消费。重试机制确保了消息不会因为消费失败而丢失,同时也保证了消息的顺序性。</p> 
<h2><a id="spring_413"></a>spring事务的传播</h2> 
<p>在Spring框架中，事务传播行为定义了业务方法对事务的控制方式，即当一个事务管理的方法被另一个事务管理的方法调用时，这个事务如何被传播。Spring提供了多种事务传播行为选项，这些选项允许开发者根据具体需求选择最合适的事务管理策略。以下是Spring支持的事务传播行为类型及其说明：</p> 
<ol><li> <p><strong><code>REQUIRED</code></strong>（默认）: 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p> </li><li> <p><strong><code>SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</p> </li><li> <p><strong><code>MANDATORY</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p> </li><li> <p><strong><code>REQUIRES_NEW</code></strong>: 总是启动一个新的事务，如果当前存在事务，则将当前事务挂起。</p> </li><li> <p><strong><code>NOT_SUPPORTED</code></strong>: 总是以非事务方式执行，如果当前存在事务，则将当前事务挂起。</p> </li><li> <p><strong><code>NEVER</code></strong>: 总是以非事务方式执行，如果当前存在事务，则抛出异常。</p> </li><li> <p><strong><code>NESTED</code></strong>: 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则其行为与<code>REQUIRED</code>一样。</p> </li></ol> 
<p>这些传播行为让开发者可以精确控制事务的边界和方式，确保业务逻辑的正确执行。例如，使用<code>REQUIRES_NEW</code>传播行为可以保证被调用的方法具有自己的独立事务，不受调用者事务的影响，这在需要确保某个业务操作不被外部事务影响时非常有用。而<code>NESTED</code>传播行为允许在同一个事务中创建多个保存点，使得内部事务可以独立于外部事务进行回滚，而不影响外部事务的完整性。</p> 
<h2><a id="spring_cloud_439"></a>spring cloud的组成</h2> 
<p>Spring Cloud是一个基于Spring Boot的工具集，用于构建分布式系统中的一些常见模式（如配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、领导选举、分布式会话和集群状态）。它利用Spring Boot的开发便利性简化了分布式系统基础设施的开发，使得开发者可以快速地启动和构建自己的服务。</p> 
<p>Spring Cloud的主要组件包括但不限于：</p> 
<ol><li> <p><strong>Spring Cloud Config</strong>: 提供服务端和客户端支持，用于外部化配置的管理。它可以使用一个中心化的外部配置仓库，如Git或SVN，来管理所有环境中应用程序的配置。</p> </li><li> <p><strong>Spring Cloud Netflix</strong>:</p> 
  <ul><li><strong>Eureka</strong>: 服务发现组件，提供了服务注册和发现的机制。</li><li><strong>Hystrix</strong>: 提供了断路器功能，用于控制服务间调用的点对点压力。</li><li><strong>Zuul</strong>: 提供了API网关服务，管理进出应用程序的流量。</li></ul> </li><li> <p><strong>Spring Cloud Consul</strong>: 提供了服务发现和配置管理的功能，通过整合Consul实现。</p> </li><li> <p><strong>Spring Cloud Gateway</strong>: 是一个新的基于Spring Framework 5, Project Reactor和Spring Boot 2.0的网关服务，旨在提供一种简单有效的方式来路由到API，并为它们提供跨域处理、安全、监控/指标和弹性。</p> </li><li> <p><strong>Spring Cloud Sleuth</strong>: 提供了分布式追踪的解决方案，帮助开发者了解服务间的调用链路。</p> </li><li> <p><strong>Spring Cloud Stream</strong>: 用于构建消息驱动的微服务，提供了与Apache Kafka、RabbitMQ等消息中间件的集成。</p> </li><li> <p><strong>Spring Cloud Bus</strong>: 通过轻量消息代理连接分布式系统的节点，用于广播状态更改或事件（如配置更改事件）。</p> </li><li> <p><strong>Spring Cloud Security</strong>: 提供了一套安全的机制，用于构建安全的微服务。</p> </li><li> <p><strong>Spring Cloud OpenFeign</strong>: 一个声明式的Web服务客户端，它使得编写Web服务客户端变得更简单。</p> </li></ol>
                </div>
</body>
</html>
